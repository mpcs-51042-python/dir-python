{
  "hash": "5df107ac25b07252478fa266f6f1c50e",
  "result": {
    "engine": "jupyter",
    "markdown": "# Arguments\n\nWhile sometimes we can write a function that takes no arguments, usually we'll want to parameterize a function.\n\nWe call the variables that are passed in to a function *arguments* or *parameters*.\n\n## Passing Arguments\n\nIn some languages, you can pass arguments by value or by reference.\nIn Python all values are \"passed by assignment\".\n\n```python\ndef func(a, b):\n    ...\n    \nx = 7\ny = [1, 2, 3]\nfunc(x, y)\n\n# you can think of the function starting with assignments to its parameters\na = x\nb = y\n```\n\nThis means mutability determines whether or not a function can modify a parameter in the outer scope.\n\nUnless otherwise specified, function arguments are **required**, and can be passed either **by position** or **by name**.\n\nAs we will see, we can also make optional arguments, as well as arguments that can only be passed by position or by name.\n\n```python\ndef calculate_cost(items, tax):\n    pass\n\n# all arguments passed by position\ncalculate_cost([\"salmon\", \"eggs\", \"bagels\"], 0.05)\n# tax passed by name\ncalculate_cost([\"salmon\", \"eggs\", \"bagels\"], tax=0.05)\n```\n\n## Optional Arguments\n\nPython allows default values to be assigned to function parameters.\n\nArguments with default values are not required.  Passed in values will override default.\n\n::: {.cell tags='[]' execution_count=1}\n``` {.python .cell-code}\n# default arguments\ndef is_it_freezing(temp, is_celsius=True):\n    if is_celsius:\n        freezing_line = 0\n    else:\n        freezing_line = 32\n    return temp < freezing_line\n```\n:::\n\n\n::: {.cell tags='[]' execution_count=2}\n``` {.python .cell-code}\nprint(is_it_freezing(65))\nprint(is_it_freezing(30))\nprint(is_it_freezing(30, False))\nprint(is_it_freezing(-1, is_celsius=True))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nFalse\nTrue\nTrue\n```\n:::\n:::\n\n\nYou can have as many optional parameters as you wish, but they must all come after any required parameters.\n\n```python\n# intentional error\ndef bad_function(a, b=\"spam\", c):\n    pass\n```\n\n## Argument Matching\n\nThere are two important rules in determining which arguments matched to which parameters:\n\n- Positional arguments are matched from left to right.\n- Keywords matched by name.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# print() as an example [call help to see docstring]\nhelp(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(\"hello\", \"positional\", \"world\", sep=\"~\", end=\";\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello~positional~world;\n```\n:::\n:::\n\n\n## keyword and positional-only arguments\n\nIncluding a bare `*` as a parameter means everything after can only be passed by keyword.\n\n\nFor example:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef request_page(\n    url,\n    verify,\n    cache=True,\n    retry_if_fail=False,\n    send_cookies=False,\n    https_only=True):\n    pass\n\nrequest_page(\"https://example.com\", True, False, True, False)\n# or did you mean\nrequest_page(\"https://example.com\", True, False, False, True)\n```\n:::\n\n\n```python\n# instead, use keyword-only\ndef request_page(url, *, verify, follow_redirects=False, cache=True, send_cookies=False, https_only=True):\n    pass\n\n# forces keyword parameters\n# & allows you to change the function definition leter\nrequest_page(\"https://example.com\", verify=True)\n```\n\nIncluding a bare `/` means everything beforehand is positional only:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef pos_only(x1, x2, /):\n    print(x1, x2)\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\npos_only(\"hello\", \"world\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello world\n```\n:::\n:::\n\n\n```python\n# ERROR: not allowed\npos_only(x1=\"hello\", x2=\"world\")\n```\n\n## Variable Length Arguments\n\nSometimes we want a function that can take any number of parameters (seen above in `print`).\n\nCollect arbitrary positional arguments with `*param_name`. (Often `*args`)\n\nCollect arbitrary named arguments with `**param_name`. (Often `**kwargs`)\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# *args example\n\ndef add_many(*args):\n    #print(args, type(args))\n    total = 0\n    for num in args:\n        total += num\n    return total\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nadd_many(1, 2, 3, 4, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n15\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# **kwargs example\n\ndef show_table(**kwargs):\n    for name, val in kwargs.items():\n        print(f\"{name:>10} | {val}\")\n\n```\n:::\n\n\n(Using advanced string formatting, see <https://docs.python.org/3/library/string.html#formatstrings>)\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nshow_table(spam=100, eggs=12, other=42.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      spam | 100\n      eggs | 12\n     other | 42.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# combining args & kwargs\ndef func(a, *args, n=5, **kwargs):\n    print(a, args, n, kwargs, sep=\"\\n\")\n\nfunc(1, 2, 3, 4, c=1, b=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n(2, 3, 4)\n5\n{'c': 1, 'b': 2}\n```\n:::\n:::\n\n\n```python\n# ERROR: why?\nfunc(x=7, x=8)\n```\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nfunc(1, 2, 3, rest=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n(2, 3)\n5\n{'rest': 5}\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# some built-in functions work this way as well\nmax(1, 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n4\n```\n:::\n:::\n\n\n## Unpacking/Splatting\n\n`*` and `**` are also known as unpacking or splatting operators.\n\nWhen in a function signature, they coalesce arguments into a `tuple` and `dict` as we've seen.\n\nWhen used on a parameter when calling a function, they \"unpack\" the values from a sequence or dict.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef takes_many(a, b, c, d):\n    print(f\"{a=} {b=} {c=} {d=}\")\n\n# any iterable can be splatted\nthree = [\"A\", \"B\", \"C\"]\nfour = (1, 2, 3, 4)\nfive = (False, False, False, False, False)\n```\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ntakes_many(*four)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na=1 b=2 c=3 d=4\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ntakes_many(*three, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na='A' b='B' c='C' d=4\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ntakes_many(4, *three)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na=4 b='A' c='B' d='C'\n```\n:::\n:::\n\n\n```python\n# ERROR\ntakes_many(*five)\n```\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# double-splat, unpack a dictionary into keyword args\nkeywords = {\"a\": \"sun\", \"c\": \"venus\", \"b\": \"mars\"}\ntakes_many(**keywords, d=\"moon\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na='sun' b='mars' c='venus' d='moon'\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=20}\n``` {.python .cell-code}\nimport math\n\n\ndef distance(x1, y1, x2, y2):\n    \"\"\"\n    Find distance between two points.\n    \n    Inputs:\n        point1: 2-element tuple (x, y)\n        point2: 2-element tuple (x, y)\n\n    Output: Distance between point1 and point2 (float).\n    \"\"\"\n    return math.sqrt(math.pow(x2-x1, 2) + math.pow(y2-y1, 2))\n```\n:::\n\n\n::: {.cell tags='[]' execution_count=21}\n``` {.python .cell-code}\n# we can use sequence-unpacking to turn tuples/lists into multiple arguments\na = (3, 4)\nb = [5, 5]\ndistance(*a, *b) # our 2 parameters become 4\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n2.23606797749979\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\na = [1,2,3,4]\na[0:2], a[2:]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n([1, 2], [3, 4])\n```\n:::\n:::\n\n\n```python\nhttp_params = {\"verify\": False, \"https_only\": True, \"timeout_sec\": 3}\nrequest_page(\"http://example.com\", **http_params)\n```\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndef fn1(url, kw1=None, kw2=None, kw3=None):\n    ...\n    \ndef fn2(url, **kwargs):\n    if is_valid(url):\n        kwargs[\"additional_arg\"] = 4\n        return fn1(url, **kwargs)\n    return None\n\n```\n:::\n\n\n## Caveat: Mutable Default Arguments\n\nAn important rule to remember is that the declaration (`def` statement) of a function is only evaluated once, not every time the function is called.\n\nThis can lead to surprising behavior at first.\nIt is important to understand & remember that only the inner-block of a function is executed on each call.\n\nThis is a common cause of bugs when a mutable is a part of the default arguments.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ndef add_many(item, n, base_list=[]):\n    print(\"adding to\", id(base_list))\n    base_list.extend([item] * n)\n    return base_list\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# passing in a list for base_list works as expected...\nanimals = [\"cow\"]\nprint(\"animals id\", id(animals))\nadd_many(\"bear\", 3, animals)\nadd_many(\"fish\", 5, animals)\nprint(animals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nanimals id 4359564096\nadding to 4359564096\nadding to 4359564096\n['cow', 'bear', 'bear', 'bear', 'fish', 'fish', 'fish', 'fish', 'fish']\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=26}\n``` {.python .cell-code}\n# let's invoke without a base_list parameter\nanimals2 = add_many(\"dog\", 3)\nprint(animals2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadding to 4359648640\n['dog', 'dog', 'dog']\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=27}\n``` {.python .cell-code}\nanimals3 = add_many(\"turtle\", 4)\nprint(animals3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadding to 4359648640\n['dog', 'dog', 'dog', 'turtle', 'turtle', 'turtle', 'turtle']\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=28}\n``` {.python .cell-code}\nanimals2\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n['dog', 'dog', 'dog', 'turtle', 'turtle', 'turtle', 'turtle']\n```\n:::\n:::\n\n\n::: {.cell tags='[]' execution_count=29}\n``` {.python .cell-code}\nanimals2 is animals3\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\nTrue\n```\n:::\n:::\n\n\nThe correct pattern is to **avoid mutable defaults** and instead assign a fresh\nmutable within the function as needed:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# fixed version\ndef add_many(item, n, base_list=None):\n    if base_list is None:\n        base_list = []\n    base_list.extend([item] * n)\n    return base_list\n```\n:::\n\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ntemp = []\nprint(id(temp))\nreturned = add_many(\"fish\", 3)\nprint(returned)\nprint(id(returned))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4359502208\n['fish', 'fish', 'fish']\n4359707136\n```\n:::\n:::\n\n\nThis is not a bug per se, but a somewhat unfortunate side effect of how Python proceses statements and handles mutables.\n\nThere *are* times when it can be used to your advantage.\n\nIn the below example, the `cache_dict` persists between calls, allowing it to be used\nas a sort of cache/memory for the calling function.\n This should only be done thoughtfully and with ample commenting to explain the intended behavior.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ndef add_cached(x, y, cache_dict={}):\n    print(cache_dict)\n    if (x, y) not in cache_dict:\n        print(\"did calculation\", x, y)\n        cache_dict[x, y] = x + y\n    return cache_dict[x, y]\n```\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nadd_cached(4, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{}\ndid calculation 4 5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n9\n```\n:::\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nadd_cached(6, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{(4, 5): 9}\ndid calculation 6 10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n16\n```\n:::\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# will use cache\nadd_cached(4, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{(4, 5): 9, (6, 10): 16}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n9\n```\n:::\n:::\n\n\n## Discussion\n\n### What types are `args` and `kwargs`?\n\n### When should you use defaults, name-only, positional-only?\n\nYour function provides an \"interface\" for other programmers to interact with.\n\nProper choices help other programmers understand how to call your functions and should be chosen to make things easier for others.\n\nWhat would you prefer?\n\n`get(\"https://example.com\", [500, 501, 503], 2.5, 2, False)`\n\nor\n\n`get(\"https://example.com\", retry_if=[500, 501, 503], timeout_sec=2.5, retries=2, verify_ssl=False)`\n\n**Always consider \"future you\" among those hypothetical \"other programmers\".**\n\n### Examples\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# two required args\ndef f(x, y):\n    print(f\"{x=} {y=}\")\n```\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# a default argument\ndef g(x, y=3):\n    print(f\"{x=} {y=}\")\n```\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# all default args\ndef h(x=\"abc\", y=3, z=True):\n    print(f\"{x=} {y=} {z=}\")\n```\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# mixture of arg types\ndef j(x, *args, y=3, **kwargs):\n    print(f\"{x=} {y=} {args=} {kwargs=}\")\n```\n:::\n\n\n```python\n\n# 1.\nf()\n\n# 2.\nf(x=1, 2)\n\n# 3.\nd = {\"x\": 0, \"y\": 0}\nf(**d)\n\n# 4.\ng(**d)\n\n# 5.\ng(**d, x=2)\n\n# 6.\ng(x=1)\n\n# 7.\nh()\n\n# 8.\nh(**d)\n\n# 9.\nh(z=False, **d)\n\n# 10.\nj(1, 2, 3, 4, 5, 6, 7)\n\n# 11.\nj(**d)\n\n# 12.\nt = (9, 9, 9, 9, 9, 9)\nj(t)\n\n# 13.\nj(*t)\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": []
  }
}