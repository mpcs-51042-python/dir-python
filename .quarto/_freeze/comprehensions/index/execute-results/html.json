{
  "hash": "9e382c239af31280f61db709810ef52b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Comprehensions\n\n*Comprehensions* are a special kind of *expression* in Python that perform significant work within a `list`, `dict`, `set` literal.\n\nIt is common to have code that converts one iterable to a new iterable, often building one element at a time:\n\n```python\nsome_iterable = [1, 2, 4, 8, 9, 12]\nnew_iterable = []\nfor i in some_iterable:\n    if some_cond:\n        new_iterable.append(some_func(i))\nreturn new_iterable\n```\n\nComprehensions allow us to reduce the above to a single line. Additionally, they can be much more efficient than building a list, dict, or set one element at a time. \n**assuming we want to use the new_iterable**.\n\nThis is not true if you are just trying to iterate: if you just want to do work in a `for` loop, continue to use a for loop as you have been!\n\n## List Comprehensions\n\nCreate a new list from another iterable.\n\nRemember that we can take any iterable and convert it to a list by calling `list()`:\n\n::: {#c0a9bc1b .cell execution_count=1}\n``` {.python .cell-code}\ns = \"hello world\"\nlist(s)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']\n```\n:::\n:::\n\n\nThe simplest list comprehension does the same thing (you should prefer `list` if this is all you are doing):\n\n::: {#0e17462c .cell execution_count=2}\n``` {.python .cell-code}\nt = (1, 2, 3, 4, 5)\n[i for i in t]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n[1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\nThis looks a bit like an inside-out for loop:\n\n```python\n# basic list comprehension syntax\nnew_list = [expression for var in iterable]\n```\n\nThe `for var in iterable` portion declares a new temporary variable for iteration, just like a traditional for loop, but\nThe benefit comes in when we start modifying the expression portion:\n\n::: {#2459b0b2 .cell execution_count=3}\n``` {.python .cell-code}\n[i**2 for i in t]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[1, 4, 9, 16, 25]\n```\n:::\n:::\n\n\n::: {#8758ba77 .cell execution_count=4}\n``` {.python .cell-code}\n[c.upper() for c in s]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n['H', 'E', 'L', 'L', 'O', ' ', 'W', 'O', 'R', 'L', 'D']\n```\n:::\n:::\n\n\nThese list comprehensions *map* values from the original iterable to new values, the same as `map`!\n\nBut they do not need to be one-to-one, we can remove some items conditionally with one more optional clause:\n\n```python\n# full list comprehension syntax with optional if clause\nnew_list = [expression for var in iterable if condition]\n```\n\n::: {#11201a65 .cell execution_count=5}\n``` {.python .cell-code}\ndef isvowel(c):\n    return c in \"aeiou\"\n\n[c.upper() for c in s if isvowel(c)]\n# or [c.upper() for c in s if c in \"aeiou\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n['E', 'O', 'O']\n```\n:::\n:::\n\n\nThis can replace `filter`!\n\n### Nested Comprehensions\n\nSince comprehensions are expressions, and the first clause needs to be an expression, we can nest comprehensions:\n\n::: {#f10b54ca .cell execution_count=6}\n``` {.python .cell-code}\n# possible to nest comprehensions, but beware readability\nfaces = (\"K\", \"Q\", \"J\")\nsuits = (\"♠\", \"♣\", \"♦\", \"♥\")\n[(face + suit) for face in faces for suit in suits if face != \"K\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n['Q♠', 'Q♣', 'Q♦', 'Q♥', 'J♠', 'J♣', 'J♦', 'J♥']\n```\n:::\n:::\n\n\n## Set & Dict Comprehensions\n\nIt is also possible to make `set` and `dict` comprehensions by using `{}`.\n\n::: {#3521fb20 .cell execution_count=7}\n``` {.python .cell-code}\n# powers of two set\n{2 ** n for n in [1,1,2,2,3,3,3,4,4,4]}\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n{2, 4, 8, 16}\n```\n:::\n:::\n\n\n::: {#f558b54c .cell execution_count=8}\n``` {.python .cell-code}\n# powers of two mapping\n{n+2: n+1 for n in range(5) if n > 0}\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n{3: 2, 4: 3, 5: 4, 6: 5}\n```\n:::\n:::\n\n\nIf the expression contains a `:` (colon), result is a dictionary.\n\n\n## Thinking in List Comprehensions\n\nHere is a way of thinking about list comprehensions that may help you write more complex comprehensions in a natural way:\n\n::: {#b573a5a0 .cell execution_count=9}\n``` {.python .cell-code}\ndef make_powers_lc(n, inputs):\n    \"\"\"\n    Given list of inputs, return each input raised to the 1st-Nth power\n    \n    e.g.\n    >>> make_powers_lc(4, range(10))\n    [[0, 0, 0, 0],\n     [1, 1, 1, 1],\n     [2, 4, 8, 16],\n     [3, 9, 27, 81],\n     [4, 16, 64, 256],\n     [5, 25, 125, 625],\n     [6, 36, 216, 1296],\n     [7, 49, 343, 2401],\n     [8, 64, 512, 4096],\n     [9, 81, 729, 6561]]\n    \"\"\"\n```\n:::\n\n\n::: {#b4d8390c .cell execution_count=10}\n``` {.python .cell-code}\n# 1) start with shape: \n# Output will be a list of list of ints, \n# so create simplest version of that\ndef make_powers_lc(n, inputs):\n    return [[1]]\nmake_powers_lc(4, range(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n[[1]]\n```\n:::\n:::\n\n\n::: {#399ac25f .cell execution_count=11}\n``` {.python .cell-code}\n# 2) expand outer list comprehension to have correct number of elements\n# using inputs as foundation, we haven't modified the first term yet\ndef make_powers_lc(n, inputs):\n    return [[1] for x in inputs]\nmake_powers_lc(4, range(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n[[1], [1], [1], [1], [1], [1], [1], [1], [1], [1]]\n```\n:::\n:::\n\n\n::: {#2ee37922 .cell execution_count=12}\n``` {.python .cell-code}\n# 3) Now expand inner list to have correct number of elements.\ndef make_powers_lc(n, inputs):\n    return [[1 for y in range(n)] for x in inputs]\nmake_powers_lc(4, range(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n[[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]]\n```\n:::\n:::\n\n\n::: {#6f58f59f .cell execution_count=13}\n``` {.python .cell-code}\n# 4) Fix initial term to do calculation\ndef make_powers_lc(n, inputs):\n    return [[x**y for y in range(n)] for x in inputs]\nmake_powers_lc(4, range(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n[[1, 0, 0, 0],\n [1, 1, 1, 1],\n [1, 2, 4, 8],\n [1, 3, 9, 27],\n [1, 4, 16, 64],\n [1, 5, 25, 125],\n [1, 6, 36, 216],\n [1, 7, 49, 343],\n [1, 8, 64, 512],\n [1, 9, 81, 729]]\n```\n:::\n:::\n\n\n::: {#fecb220e .cell execution_count=14}\n``` {.python .cell-code}\n# 5) With correct shape, make modifications to ranges/etc. as needed\ndef make_powers_lc(n, inputs):\n    return [[x**y for y in range(1, n+1)] for x in inputs]\nmake_powers_lc(4, range(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[[0, 0, 0, 0],\n [1, 1, 1, 1],\n [2, 4, 8, 16],\n [3, 9, 27, 81],\n [4, 16, 64, 256],\n [5, 25, 125, 625],\n [6, 36, 216, 1296],\n [7, 49, 343, 2401],\n [8, 64, 512, 4096],\n [9, 81, 729, 6561]]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}