{
  "hash": "5be6152cc92ce116a6fefb8e1f655536",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Decorators\njupyter: python3\n---\n\n## Decorators\n\nA common pattern in functional programs, are functions that are built to \"wrap\" other functions.\n\nThis pattern allows one to attach behavior before or after a function call, making it possible to:\n\n- log function calls\n- validate or modify arguments (before)\n- validate or modify return value (after)\n- check performance or other characteristics of the function (e.g. time elapsed)\n- replace the inner function wholesale, for any purpose\n\n::: {#710715a4 .cell execution_count=1}\n``` {.python .cell-code}\n# a simple example\ndef print_before_and_after(func):\n    def newfunc(*args, **kwargs):\n        print(\"BEFORE\", func)\n        func(*args, **kwargs)\n        print(\"AFTER\", func)\n    return newfunc\n```\n:::\n\n\nThis function `print_before_and_after` is called a decorator, it takes a function, and returns a new function.\n\nTypically this new function will call the original function, but that is not required!\n\n::: {#40fdd22b .cell execution_count=2}\n``` {.python .cell-code}\ndef inner(a, b, c):\n    print(\"inner function\", a, b, c)\n```\n:::\n\n\n::: {#720d736a .cell execution_count=3}\n``` {.python .cell-code}\nwrapped_inner = print_before_and_after(inner)\n\nwrapped_inner(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBEFORE <function inner at 0x103e08b80>\ninner function 1 2 3\nAFTER <function inner at 0x103e08b80>\n```\n:::\n:::\n\n\n::: {#07d05384 .cell execution_count=4}\n``` {.python .cell-code}\n# often we want to replace the function altogether\ninner = print_before_and_after(inner)\ninner(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBEFORE <function inner at 0x103e08b80>\ninner function 1 2 3\nAFTER <function inner at 0x103e08b80>\n```\n:::\n:::\n\n\n## Decorator Syntax\n\nWanting to replace a function with its decorated form is so common, we have a special syntax:\n\n::: {#5be983be .cell execution_count=5}\n``` {.python .cell-code}\n@print_before_and_after\ndef add_nums(a, b, c):\n    print(f\"{a} + {b} + {c} =\", a + b + c)\n\nadd_nums(1, 2, 3)\n# same as add_nums = print_before_and_after(add_nums)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBEFORE <function add_nums at 0x103e085e0>\n1 + 2 + 3 = 6\nAFTER <function add_nums at 0x103e085e0>\n```\n:::\n:::\n\n\nWe can apply multiple decorators, here we'll apply the same one twice:\n\n::: {#574d611c .cell execution_count=6}\n``` {.python .cell-code}\n@print_before_and_after\n@print_before_and_after\ndef mult_nums(a, b, c):\n    print(f\"{a} * {b} * {c} =\", a * b * c)\n\nmult_nums(1, 2, 3)\n# same as mult_nums = print_before_and_after(print_before_and_after(add_nums))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBEFORE <function print_before_and_after.<locals>.newfunc at 0x103e08540>\nBEFORE <function mult_nums at 0x103e08680>\n1 * 2 * 3 = 6\nAFTER <function mult_nums at 0x103e08680>\nAFTER <function print_before_and_after.<locals>.newfunc at 0x103e08540>\n```\n:::\n:::\n\n\n### Creating a Cache\n\nWe saw that we can use enclosing scope to create a cache, now we can do that in a generic way that will work for any function:\n\n::: {#7c08f1de .cell execution_count=7}\n``` {.python .cell-code}\ndef cache(func):\n    inner_cache = {}\n    \n    def newfunc(*args):\n        if args not in inner_cache:\n            inner_cache[args] = func(*args)\n        return inner_cache[args]\n    \n    return newfunc\n```\n:::\n\n\n::: {#e6b183cf .cell execution_count=8}\n``` {.python .cell-code}\n@cache\ndef expensive_calculation(a, b, *, c=0):\n    print(f\"doing expensive calculation on {a} {b}...\")\n    return a ** b\n\n@cache\ndef cheap_calculation(a, b):\n    print(f\"doing cheap calculation on {a} {b}...\")\n    return a + b\n```\n:::\n\n\n::: {#65de6fe2 .cell execution_count=9}\n``` {.python .cell-code}\nexpensive_calculation(4, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndoing expensive calculation on 4 10...\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n1048576\n```\n:::\n:::\n\n\n::: {#925e2507 .cell execution_count=10}\n``` {.python .cell-code}\nexpensive_calculation(4, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n1048576\n```\n:::\n:::\n\n\n::: {#85dc1207 .cell execution_count=11}\n``` {.python .cell-code}\n# independent cache\ncheap_calculation(4, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndoing cheap calculation on 4 10...\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n14\n```\n:::\n:::\n\n\n::: {#031da926 .cell execution_count=12}\n``` {.python .cell-code}\nexpensive_calculation(5, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndoing expensive calculation on 5 6...\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n15625\n```\n:::\n:::\n\n\n::: {#04c23cc1 .cell execution_count=13}\n``` {.python .cell-code}\nexpensive_calculation(5, 6)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n15625\n```\n:::\n:::\n\n\n### Decorators with Arguments\n\nPython has a built in `functools.lru_cache` function, which gives us a cache of a defined size:\n\n```python\n@lru_cache(100)\ndef some_calc(a, b, c):\n    pass\n```\n\nTo write a decorator that takes additional arguments, you must write one more function.\n\nWe already had:\n\n- decorator function: takes function, returns function\n- inner function: takes *args, **kwargs typically, since outer function isn't known, returns same type as wrapped func\n\nNow we add one more outside that decorator function, a **factory function** that returns a decorator!\n\n::: {#edc2057f .cell execution_count=14}\n``` {.python .cell-code}\ndef repeat(n):  # factory: takes integer, returns decorator\n    def repeat_decorator(func):                  # decorator: takes function, returns function\n        def newfunc(*args, **kwargs):            # inner function: takes ?, returns ?\n            for i in range(n):\n                func(*args, **kwargs)\n        return newfunc\n    return repeat_decorator\n\n@repeat(10)\ndef print_backwards(s):\n    print(s[::-1])\n\nprint_backwards(\"backwards\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\n```\n:::\n:::\n\n\n::: {#4fd9e991 .cell execution_count=15}\n``` {.python .cell-code}\n# we can see the layers if we call one step at a time:\n# first, obtain the decorator from the factory\nrepeat_10 = repeat(10) \nprint(repeat_10)\n# apply the decorator to the wrapped function\nprint_backwards = repeat_10(print_backwards)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<function repeat.<locals>.repeat_decorator at 0x103e08720>\n```\n:::\n:::\n\n\n## Function Properties\n\nLet's look at `functools.partial` again:\n\n<https://docs.python.org/3/library/functools.html#functools.partial>\n\n::: {#d4593a94 .cell execution_count=16}\n``` {.python .cell-code}\nimport functools\nprint_hello_names = functools.partial(print, \"Hello\", sep=\", \")\n```\n:::\n\n\n::: {#a5661134 .cell execution_count=17}\n``` {.python .cell-code}\nprint_hello_names(\"Scott\", \"Paul\", \"Lauren\")\n# \"hello\" already bound, as is sep, so this is the same as:\n# print(\"Hello\", \"Scott\", \"Paul\", \"Lauren\", sep=\", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Scott, Paul, Lauren\n```\n:::\n:::\n\n\nPartial stores attributes on the function, **functions are mutable!**\n\n::: {#a38712ed .cell execution_count=18}\n``` {.python .cell-code}\n# bound args\nprint_hello_names.args\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n('Hello',)\n```\n:::\n:::\n\n\n::: {#a8083f50 .cell execution_count=19}\n``` {.python .cell-code}\n# bound keywords\nprint_hello_names.keywords\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n{'sep': ', '}\n```\n:::\n:::\n\n\n::: {#778876a8 .cell execution_count=20}\n``` {.python .cell-code}\n# original func\nprint_hello_names.func\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n<function print(*args, sep=' ', end='\\n', file=None, flush=False)>\n```\n:::\n:::\n\n\n::: {#cafdba26 .cell execution_count=21}\n``` {.python .cell-code}\n# since functions are objects, we can attach arbitrary values to them\ndef wrapper(func):\n    def newfunc(*args, **kwargs):\n        return func(*args, **kwargs)\n    # we can do whatever we like after defining newfunc, but before returning it\n    newfunc.xyz = \"hello\"*2\n    return newfunc\n```\n:::\n\n\n::: {#9ca4fb91 .cell execution_count=22}\n``` {.python .cell-code}\n# property is assigned to all wrapped functions\n@wrapper\ndef our_function():\n    print(\"inside our function\")\n\nour_function.xyz\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n'hellohello'\n```\n:::\n:::\n\n\n### Writing our own `partial`\n\n::: {#5217c4d1 .cell execution_count=23}\n``` {.python .cell-code}\ndef our_partial(func, /, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = {**keywords, **fkeywords}\n        return func(*args, *fargs, **newkeywords)\n    # assign these properties from within the closure\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\n```\n:::\n\n\n::: {#7b4e39f5 .cell execution_count=24}\n``` {.python .cell-code}\nprint_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Scott, Paul, Lauren!\n```\n:::\n:::\n\n\n::: {#254179be .cell execution_count=25}\n``` {.python .cell-code}\n#print_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\", sep=\"?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello?Scott?Paul?Lauren!\n```\n:::\n:::\n\n\n::: {#30f07180 .cell execution_count=26}\n``` {.python .cell-code}\nprint_hello_names2.args\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n('Hello',)\n```\n:::\n:::\n\n\n::: {#5dc3c510 .cell execution_count=27}\n``` {.python .cell-code}\nprint_hello_names2.keywords\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n{'sep': ', '}\n```\n:::\n:::\n\n\n::: {#07f6270c .cell execution_count=28}\n``` {.python .cell-code}\nprint_hello_names2.func\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n<function print(*args, sep=' ', end='\\n', file=None, flush=False)>\n```\n:::\n:::\n\n\n## More Decorator Examples\n\n### Not Calling the Wrapped Function\n\n::: {#637b5578 .cell execution_count=29}\n``` {.python .cell-code}\ndef disable(f):\n    def newfunc(*args, **kwargs):\n        print(\"would have called \", f.__name__)\n    return newfunc\n\n@disable\ndef expensive_func(a, b):\n    print(\"expensive!\")\n\nexpensive_func(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwould have called  expensive_func\n```\n:::\n:::\n\n\n### Modifying Arguments within newfunc\n\n::: {#5412671c .cell execution_count=30}\n``` {.python .cell-code}\ndef reverse_args(func):\n    def newfunc(*args):\n        # within newfunc we are able to write whatever we'd like\n        # we could decide that we want to reverse the arguments\n        reversed_args = reversed(args)\n        return func(*reversed_args)\n    return newfunc\n\n\n@reverse_args\ndef print_args(*args):\n    for arg in args:\n        print(arg)\n```\n:::\n\n\n::: {#7aabf4b8 .cell execution_count=31}\n``` {.python .cell-code}\nprint_args(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n2\n1\n```\n:::\n:::\n\n\n::: {#3232a9b0 .cell execution_count=32}\n``` {.python .cell-code}\n@reverse_args\ndef divide(a, b):\n    return a / b\n\ndivide(10, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n0.2\n```\n:::\n:::\n\n\n### Example: Authorization\n\n::: {#4de54932 .cell execution_count=33}\n``` {.python .cell-code}\n# perhaps we want a function that checks if a user can perform an action\ndef auth_required(func):\n    \n    # list of allowed users. in practice, we'd look this up in a database\n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, **kwargs):\n        # here, we're actually using an argument within newfunc\n        # by checking if it is in the kwargs dictionary\n        if kwargs.get(\"auth_user\") in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# these functions must also accept auth_user so that the above call to func(*args, **kwargs)\n# doesn't send an invalid parameter through\n@auth_required\ndef withdraw_funds(account, amount, auth_user):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account, auth_user):\n    print(\"deleted\", account)\n```\n:::\n\n\n::: {#35c21d8a .cell execution_count=34}\n``` {.python .cell-code}\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwithdrew 100 funds from account=jim\n```\n:::\n:::\n\n\n::: {#a9d4de4b .cell execution_count=35}\n``` {.python .cell-code}\ndelete_account(\"kevin\", auth_user=\"jim\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nACCESS DENIED\n```\n:::\n:::\n\n\n### Modifying Keyword Parameters\n\n::: {#58b43418 .cell execution_count=36}\n``` {.python .cell-code}\n# if we didn't want auth_user to be passed through, we'd make a small modification to newfunc\n\ndef auth_required(func):    \n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, auth_user, **kwargs):\n        # newfunc now requires auth_user, and passes through all *other* parameters\n        if auth_user in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# auth_user is no longer seen in the definition of these functions \n# but it can be passed in since the newfunc returned from auth_required accepts it\n@auth_required\ndef withdraw_funds(account, amount):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account):\n    print(\"deleted\", account)\n```\n:::\n\n\n::: {#e03b9478 .cell execution_count=37}\n``` {.python .cell-code}\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwithdrew 100 funds from account=jim\n```\n:::\n:::\n\n\n::: {#6022d66a .cell execution_count=38}\n``` {.python .cell-code}\ndelete_account(\"kevin\", auth_user=\"jim\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nACCESS DENIED\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}