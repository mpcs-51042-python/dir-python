{
  "hash": "cdbce0dc54a55252a4038613b5dc30c6",
  "result": {
    "engine": "jupyter",
    "markdown": "# Exceptions\n<!-- on loan from PDM, but maybe it belongs here -->\n\n---\n\n**Goals**\n\n- Understand why we use exceptions.\n- Explore Python's exception handling syntax.\n\n---\n\n## Error Handling\n\nNo matter how good your code is, there's always going to be a chance that something goes wrong.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef my_func(a, b):\n    \"\"\" what can go wrong with this function? \"\"\"\n    if a > b:\n        return a / b\n    else:\n        return a * c\n```\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Error One\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntry:\n    my_func(3, 0)\nexcept Exception as e:\n    print(repr(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nZeroDivisionError('division by zero')\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Error Two\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ntry:\n    my_func(10, 12)\nexcept Exception as e:\n    print(repr(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNameError(\"name 'c' is not defined\")\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Error Three\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntry:\n    my_func(\"two\", \"three\")\nexcept Exception as e:\n    print(repr(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTypeError(\"unsupported operand type(s) for /: 'str' and 'str'\")\n```\n:::\n:::\n\n\n:::\n\n\nIf we were to try to handle all errors, we'd need to return some error value, perhaps `None`.\n\n```python\ndef my_func(a, b):\n  # make sure both variables are numeric\n  if not isinstance(a, (int, float, complex)):\n      return None\n  if not isinstance(b, (int, float, complex)):\n      return None\n    if a > b:\n        if b == 0:\n            return None   # can't divide by zero\n        return a / b\n    else:\n        return a * b\n```\n\nBut this has issues of it's own: \n\n- The function is significantly harder to read, now half the code is dedicated to error handling.\n- There are other numeric types, such as `fraction.Fraction`, the function is now artificially constrained to only work with those that the author considered.\n- By returning `None` we get no information about what happened. This would make debugging harder if we found a `None` result later in our program.\n- Now code using this function will always need to check if it got a numeric value or `None` on result.\n\nCode winds up littered with:\n\n```python\nq = my_func(r, s)\nif q is not None:\n  ... # good path\nelse:\n  ... # error path\n  \n```\n\nSome languages, like C, do not have exceptions, and as a result correct C code is commonly filled with checks like the above examples.\n\n## Exceptions\n\nIn Python we have **exceptions**, which allow us to write our code *assuming that things went well*.\nThis means we can generally call functions and use their return values without checking for an error result between each step.\n\nThis makes it possible to write concise code:\n\n```python\nurl = get_url()\nresp = httpx.get(url)\nroot = lxml.html.fromstring(resp.text)\n\n# or even as a single line\nroot = lxml.html.fromstring(httpx.get(get_url()).text)\n```\n\nMost of the time, that code should work as intended, but errors might occur:\n\n- `get_url()` might have a bug and return `None` or an invalid URL.\n- The server might be down, so `httpx.get` encounters a timeout.\n- `lxml.html.fromstring` might not be able to parse the HTML.\n\nInstead of a long potentially complex series `if/else` statements, we can write the code assuming things will go well.\nIf something *exceptional* happens, the functions will *raise an exception*.\n\nIf we write nothing else, any exception will force the program to exit.\nOften that's the desired behavior. For example, if the program depends on a website being up, exiting if the server is unavailable is a reasonable choice.\n\nSometimes however, there might be some code that we'd like to run when something exceptional happens.\n\nSome examples:\n\n- some errors are *recoverable*, perhaps the site was down momentarily and we can retry after a short wait\n- save/close open files so no work is lost before exiting\n- or perhaps just printing a user-friendly error message before exiting\n\nExceptions are very useful in Python, so sometimes we may even use them for non-error conditions, just to handle a less-common case.\n\n\n## Handling Exceptions\n\nWe surround the \"risky\" code with a `try/except` statement.\n\n```python\ntry:\n    might_encounter_error()\n    maybe_works()\nexcept (ValueError, KeyError) as exc:\n    handle_error(exc)\n\nthen_this()\n```\n\nIf either of the lines of code within the `try` portion produce an exception, Python will check the type against the `except` statement.\n\n**If the type matches any of the listed types**, it will assign the exception to `exc`, then run the block under the matching `except`.\n   (The variable name is your choice, common names are `e`, `err`, `exc`).\n\n**If no exception is raised**, the next line of code to execute would be after the `except` block, the function `then_this()`.\n\n### Multiple Exception Types\n\nIf you are only handling a single type you would use `except ExceptionType`.\nIf you are handling multiple exceptions you can combine them in a tuple if you want the same code to handle multiple types, as we saw above.\n\nSometimes however, you may want to handle different exceptions differently:\n\n```python\ntry:\n    response = httpx.get('http://example.com')\n    response.raise_for_status()\n    print(f\"Success! Status code: {response.status_code}\")\nexcept (httpx.RequestError, httpx.TimeoutException) as e:\n    # Handles network-related errors (DNS failures, connection errors, etc.)\n    #  as well as timeouts.\n    print(f\"Server error occurred: {e}\")\nexcept httpx.HTTPStatusError as e:\n    # Handles HTTP status errors (4xx, 5xx responses)\n    print(f\"HTTP error occurred: {e}\")\n```\n\nHere we use multiple `except` statements to execute different code depending on the kind of error encountered.\nLike `elif` statements, only the first `except` to match will be executed.\n\nThis means that when the server is down, we can retry after some time.\nHowever, if the error is that the password is invalid there's no benefit in retrying with the same data.\n\n### try-except-else-finally\n\nA `try/except` may have:\n\n- one `try` block\n- as many `except` blocks as desired\n- an optional `else`\n- an optional `finally`\n\nThe `else` statement only executes if no exception is raised. (Somewhat akin to the `else` executing if no `elif` runs.)\n\n`finally` is unique to exception handling. It executes **no matter what**, after any other blocks are evaluated.\n\n```python\ntry:\n    something()\nexcept ValueError as e:\n    ...   # executes only if ValueError was raised\nexcept (IndexError, KeyError) as e:\n    ...   # executes only if IndexError or KeyError was raised\nelse:\n    ...   # executes if no exception raised\nfinally:\n    ...   # executes after try/except/else no matter what\n```\n\n## Raising Exceptions\n\nIf *your code* encounters a condition that it cannot handle, you can `raise` an exception.\n\nTo raise an exception, you use the `raise` keyword, which similarly to `return` exits a function immediately.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef f(positive):\n    if positive < 0:\n        raise ValueError(\"f requires a positive argument\")\n    return positive * positive\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nf(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n9\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ntry:\n    y = f(-1)\nexcept ValueError as exc:\n    y = 0\n    print(\"got an error: \", exc)\nprint(\"y=\", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngot an error:  f requires a positive argument\ny= 0\n```\n:::\n:::\n\n\n### Propagation\n\nExceptions **propagate** unless caught, you've encountered this in your own code:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef inner():\n    raise Exception(\"example\")\n\ndef middle():\n    inner()\n\ndef outer():\n    middle()\n\ntry:\n    outer()\nexcept Exception as e:\n    # this code being used for this example to show\n    # stack output in notebook\n    print(\"Uncaught: \", repr(e))\n    import traceback\n    print(traceback.format_exc())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUncaught:  Exception('example')\nTraceback (most recent call last):\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_52716/2424353647.py\", line 11, in <module>\n    outer()\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_52716/2424353647.py\", line 8, in outer\n    middle()\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_52716/2424353647.py\", line 5, in middle\n    inner()\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_52716/2424353647.py\", line 2, in inner\n    raise Exception(\"example\")\nException: example\n\n```\n:::\n:::\n\n\nThis is sometimes called \"bubbling up\", the uncaught exception *pops functions off the call stack*, exiting them in LIFO \"last-in-first-out\" order.\n\nA `try/except` may catch the exception at any level. If the exception is caught within `middle` for instance, execution will resume in that function's `except` block.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndef inner():\n    raise Exception(\"example\")\n\ndef middle():\n    try:\n       inner()\n    except Exception:\n       print(\"caught in the middle, stops propagation\")\n\ndef outer():\n    middle()\n\ntry:\n    outer()\nexcept Exception as e:\n    # this code being used for this example to show\n    # stack output in notebook\n    print(\"Uncaught: \", repr(e))\n    import traceback\n    print(traceback.format_exc())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncaught in the middle, stops propagation\n```\n:::\n:::\n\n\n### re-raising \n\nWhile an `except` usually stops propagation, sometimes you want to handle an exception and then still allow it to propagate/end the program.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef risky_code():\n    print(\"running risky code...\")\n    raise Exception(\"!\")\n\ndef save_data():\n    print(\"saving data!\")\n\ndef main():\n    try:\n        risky_code()\n    except Exception as e:\n        print(f\"Handling Error: {e}\")\n        raise\n    finally:\n        save_data()\n\n\ntry:\n    main()\nexcept Exception as e:\n    # this code being used for this example to show\n    # stack output in notebook\n    print(\"Uncaught: \", repr(e))\n    import traceback\n    print(traceback.format_exc())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrunning risky code...\nHandling Error: !\nsaving data!\nUncaught:  Exception('!')\nTraceback (most recent call last):\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_52716/2649118250.py\", line 19, in <module>\n    main()\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_52716/2649118250.py\", line 10, in main\n    risky_code()\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_52716/2649118250.py\", line 3, in risky_code\n    raise Exception(\"!\")\nException: !\n\n```\n:::\n:::\n\n\nThis example runs the function `risky_code`, and if an error occurs will print the error message\n\n## Exception Types\n\nExceptions in Python form a hierarchy.\n\nThe exceptions you're used to seeing inherit from `Exception`:\n\n* `Exception` (base type)\n  * `ValueError`\n  * `TypeError`\n  * `KeyError`\n  * `IndexError`\n  * `NotImplementedError`\n  * `OSError`\n      * `FileNotFoundError`\n\nThe [Python exception documentation](https://docs.python.org/3/library/exceptions.html#exception-hierarchy) contains the full hierarchy.\n\nAn `except OSError` will also catch `FileNotFoundError` since the second is a child of the first.\n\nThis means that if you catch `Exception` almost all of the common exceptions.\n\n\n::: {.callout-warning}\n## except Exception & bare except:\n\n`except Exception` is **usually a bug**.\nRarely do you want to handle all exceptions in the same manner.\n\nOne time that it would be acceptable to do this would be to print a human readable error message.\nYou can catch `Exception` in your `main` function and print a more useful error message.\n\nThough not shown in any of the examples on this page, `except:` without any exception at all is also valid syntax.\nThis will catch *all exceptions*, not just those that are children of `Exception`.\n\nThis is an even worse idea, and the general advice is to **never use this**.\nIt will include special exceptions like `SystemExit` which are raised when someone tries to quit your program.\nThis means that programs that catch `except:` can appear to be stuck.\n\n:::\n\n### Defining Custom Exception Types\n\nSometimes a built-in exception type is a natural fit, if you are writing a dictionary-like object you would probably use `KeyError` if an invalid key is accessed.\n\nMost of the time, it is a good idea to define your own exception type, or types.\n\nCustom exception types let you handle your own errors differently from Python's built in types:\n\n```python\nclass InvalidColor(Exception):\n    \"\"\" This exception is raised when an invalid color is passed. \"\"\"\n    pass\n\nVALID_COLORS = (...)\n\ndef draw_point(x, y, color):\n    if color not in VALID_COLORS:\n        raise InvalidColor(\"color should be one of the valid colors\")\n```\n\nException classes must inherit from `Exception` or another exception.\nThis will define their place in the exception hierarchy.\n\nIf you're unfamiliar with inheritance at this point, this refers to the `(Exception)` portion of the above declaration.\n\n## Best Practices\n\nWhen a programmer first encounters `except` it may feel tempting to just catch every error.\nDoing so doesn't magically make your code work, it just hides errors and makes debugging impossible.\n\nInstead, you want to keep exception handling to cases that your code intends to *handle*, not use `except` to *ignore* errors.\n\nBest practices are to keep error handling *as narrow as possible*:\n\n* Try to keep your `try` blocks as small as possible, only including the code that might raise an exception.\n* Catch the most specific exception possible, and only catch exceptions that you can handle.\n* `raise` the most specific exception that you can, `DivisionByZeroError` tells you more than `ArithmeticError`.\n  * Create & use custom exception types liberally!\n* Always avoid catching `Exception`, or omitting the exception type entirely. \n* Provide useful messages to augment common exception types, for example `raise ValueError(\"say why the value was rejected\")`.\n\n\n## Further Exploration\n\n* [Python Docs - Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html)\n* [Python Docs - Context Managers](https://docs.python.org/3/reference/datamodel.html#context-managers)\n* [Python Docs - with Statement](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": []
  }
}