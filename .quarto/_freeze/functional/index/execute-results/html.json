{
  "hash": "1be96c5ed2da51857622fc4dcec217db",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Functional Programming\njupyter: python3\n---\n\n## Procedural vs. Functional\n\nThe style of programming we've been doing is called **imperative** or **procedural**.  Statements run in sequence and change a program's state.\n\nFrom the \"procedural\" point of view, a function (procedure) is a set of statements that can be called more than once, we use parameters to make our procedures more reusable.\n\nThis is the \"recipe\" model of programming, \na procedure is a recipe: a series of steps to follow to achieve a result.\n\nOur first paradigm, **procedural programming** leans heavily on the constructs we've seen: loops, conditionals, and the use of functions to break large procedures into smaller ones.\n\nSome languages make a distinction between procedures and functions. In Python we don't make this distinction, but we will soon see another style of programming where we'll think differently about how we use functions.\n\nBenefits of procedures (functions):\n\n- Encapsulation: package logic so \"user\" does not need to understand *implementation*, only *interface*.\n- Avoid copy/paste to repeat same task: maximize code reuse and minimize redundancy.\n- Procedural decomposition: split our program into subtasks (i.e., functions) with separate roles.\n    - Small functions are easier to test, easier to write, and easier to refactor.\n    - Makes life easier for debugging, testing, doing maintenance on code.\n\n## Functional Programming\n\nLanguages like LISP, Haskell, and Racket are purely functional & differ significantly from procedural & object-oriented languages.\n\nFunctional programming uses a definition of functions more compatible with the mathematical definition. Instead of the recipe model of procedural programming, mathematical functions take input(s) and return an output. \n\nThese functions do not have the concept of \"state\": the same call with the same parameters always results in the same result.\nthat is, calling a function in math creates a mapping from inputs to outputs.\n\nWhen we call `sin(x)` we do not speak of it modifying its inputs, just returning a value.\n\nSimilarly, when we workin a functional style we'll often write smaller functions that we chain together, instead of long procedures that rely on internal state.\n\nPython has many features that stem from pure functional languages & support functional programming:\n\n- Functions as first class objects\n- Lambda expressions\n- map/filter\n- `functools`\n- comprehensions\n\n## Functions as \"first-class objects\"\n\nA key feature of Python that makes it possible to write code in the functional style is the fact that functions are objects. (Everything in Python is an object.)\n\nThis means functions don't have special rules about how they can be used compared to other types, any variable can reference a function. (Remember, a variable is an association between a name & object.)\n\n::: {#c89403ee .cell tags='[]' execution_count=1}\n``` {.python .cell-code}\ndef echo(message):\n    print(message, message)\n    \nprint(f\"echo = {echo}\")\nprint(f\"type(echo) = {type(echo)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\necho = <function echo at 0x103df8c20>\ntype(echo) = <class 'function'>\n```\n:::\n:::\n\n\n::: {#15732fd7 .cell execution_count=2}\n``` {.python .cell-code}\n# we can assign names to objects, including functions\nx = echo\nx(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello hello\n```\n:::\n:::\n\n\n::: {#62c30b93 .cell execution_count=3}\n``` {.python .cell-code}\nid(x), id(echo)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n(4359949344, 4359949344)\n```\n:::\n:::\n\n\n::: {#f7d69cbf .cell execution_count=4}\n``` {.python .cell-code}\n# we can also store functions in other types, like list\nfunc_list = [print, echo, print, echo]\nfor i, func in enumerate(func_list):\n    func(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1 1\n2\n3 3\n```\n:::\n:::\n\n\n::: {#64f718c7 .cell execution_count=5}\n``` {.python .cell-code}\n# dictionaries too\nfunc_mapping = {False: print, True: echo}\n\nprint_twice = True\nfunc_mapping[True](\"twice\")\n\nprint_twice = False\nfunc_mapping[print_twice](\"once\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntwice twice\nonce\n```\n:::\n:::\n\n\n::: {#8b6ee3be .cell execution_count=6}\n``` {.python .cell-code}\n# we can pass functions into other functions\ndef add(a, b):\n    return a + b\n\ndef sub(a, b):\n    return a - b\n\ndef perform_op(op_func, a, b):\n    return op_func(a, b)\n\nprint(\"add, 3, 4 = \", perform_op(add, 3, 4))\nprint(\"sub, 3, 4 = \", perform_op(sub, 3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadd, 3, 4 =  7\nsub, 3, 4 =  -1\n```\n:::\n:::\n\n\n::: {#2080305c .cell execution_count=7}\n``` {.python .cell-code}\n# and we can return functions from other functions\ndef get_op(name):\n    if name == \"div\":\n        def f(a, b):\n            return a / b\n    elif name == \"mod\":\n        def f(a, b):\n            return a % b\n    return f\n```\n:::\n\n\n::: {#9185bd39 .cell tags='[]' execution_count=8}\n``` {.python .cell-code}\nfn = get_op(\"mod\")\nfn(100, 5)\n#perform_op(fn, 10, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n0\n```\n:::\n:::\n\n\n### `sorted` example\n\nIt isn't uncommon in Python for functions to take other functions, let's look at `sorted`\n\n::: {#dcfad50c .cell execution_count=9}\n``` {.python .cell-code}\nhelp(sorted)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on built-in function sorted in module builtins:\n\nsorted(iterable, /, *, key=None, reverse=False)\n    Return a new list containing all items from the iterable in ascending order.\n\n    A custom key function can be supplied to customize the sort order, and the\n    reverse flag can be set to request the result in descending order.\n\n```\n:::\n:::\n\n\n::: {#0aa00eec .cell tags='[]' execution_count=10}\n``` {.python .cell-code}\nd = [(\"Nick\", 1), (\"Nick\", -100), (\"Yusong\", 9000), (\"Emma\", 100)]\n\ndef second_key(item):\n    return item[1]\n\ndef negate(item):\n    return -item[1]\n```\n:::\n\n\n::: {#52e35d20 .cell execution_count=11}\n``` {.python .cell-code}\n# default sort\nsorted(d)    \n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n[('Emma', 100), ('Nick', -100), ('Nick', 1), ('Yusong', 9000)]\n```\n:::\n:::\n\n\n::: {#1bbff40e .cell execution_count=12}\n``` {.python .cell-code}\nsorted(d, key=negate)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n[('Yusong', 9000), ('Emma', 100), ('Nick', 1), ('Nick', -100)]\n```\n:::\n:::\n\n\n::: {#33974aae .cell execution_count=13}\n``` {.python .cell-code}\nsorted(d, key=second_key)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n[('Nick', -100), ('Nick', 1), ('Emma', 100), ('Yusong', 9000)]\n```\n:::\n:::\n\n\n## lambda functions\n\nPython also provides another way to generate function objects.\n\nThese are called lambda functions (aka anonymous functions), which:\n\n- Are expressions that return a function object that can be called later without providing a name (hence ``anonymous\")\n- Can be used in places where def statement is not syntactically legal (inside a literal list, inlined as a function argument, etc.)\n\nThe body of an lambda function is a single expression, not a block of statements.  The body is similar to a return statement in a def statement.\n\n```python\n\nlambda arg1, arg2: expression\n\n# essentially the same as\n\ndef __(arg1, arg2):\n    return expression\n```\n\n(0 or more arguments, but *must* have an expression)\n\n### Reminder: expressions vs. statements\n\nRemember that expressions evaluate to a value, and can be assigned to a variable.\n\nExpresssions are valid in assignment, function calls, sequence values, etc.  (Anywhere a value is needed.)\n\nWhen it comes to `lambda`:\n* a `lambda` defines a function that maps input to a single expression, `def` can be used if statements are needed\n* a `lambda` is itself an expression, it can be used anywhere other expresssions are needed\n\nAs an expression, `lambda` can be used as a parameter:\n\n::: {#1e74bc2d .cell execution_count=14}\n``` {.python .cell-code}\nperform_op(lambda a, b: a * b, 5, 6)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n30\n```\n:::\n:::\n\n\n::: {#e44b09f1 .cell execution_count=15}\n``` {.python .cell-code}\nwords = [\"abc\", \"Abb\", \"aaa\", \"ABC\", \"AAB\"]\nsorted(words)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n['AAB', 'ABC', 'Abb', 'aaa', 'abc']\n```\n:::\n:::\n\n\n::: {#3e2ee8da .cell execution_count=16}\n``` {.python .cell-code}\nsorted(words, key=lambda s: s.upper())\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n['aaa', 'AAB', 'Abb', 'abc', 'ABC']\n```\n:::\n:::\n\n\n::: {#004692d4 .cell execution_count=17}\n``` {.python .cell-code}\n# can be assigned to a variable\nmul = lambda a, b: a * b\nmul(5, 6)\n\n# same as\ndef mul2(a, b):\n    return a * b\n```\n:::\n\n\n::: {#a958d783 .cell tags='[]' execution_count=18}\n``` {.python .cell-code}\ntype(mul), type(mul2)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n(function, function)\n```\n:::\n:::\n\n\n**General rule: If you're giving a lambda a name, use a function.**\n\n\n## Functional Methods\n\nPython has several built in methods that are useful when writing programs with a functional mindset.\n\n`map`, `filter`, `functools`\n\n### map\n\n`map(function, iterable1, [...iterableN])`\n\nReturns a new iterable that calls `function` with parameters from `iterable1 ... iterableN`.\n\n::: {#ace6cee5 .cell tags='[]' execution_count=19}\n``` {.python .cell-code}\ndef add_two(x):\n    print(\"called add_two\", x)\n    return x + 2\n\nfor x in map(add_two, [1, 2, 3]):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncalled add_two 1\n3\ncalled add_two 2\n4\ncalled add_two 3\n5\n```\n:::\n:::\n\n\n::: {#31117abe .cell tags='[]' execution_count=20}\n``` {.python .cell-code}\nhelp(map)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on class map in module builtins:\n\nclass map(object)\n |  map(func, *iterables) --> map object\n |\n |  Make an iterator that computes the function using arguments from\n |  each of the iterables.  Stops when the shortest iterable is exhausted.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(...)\n |      Return state information for pickling.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n\n```\n:::\n:::\n\n\n::: {#e24d6271 .cell tags='[]' execution_count=21}\n``` {.python .cell-code}\nx = list(map(add_two, [1, 2, 3]))\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncalled add_two 1\ncalled add_two 2\ncalled add_two 3\n[3, 4, 5]\n```\n:::\n:::\n\n\n::: {#185b8c4e .cell tags='[]' execution_count=22}\n``` {.python .cell-code}\n# commonly used with lambdas\nfor x in map(lambda x, y: x+y, (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"]):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA!\nB?\nC.\n```\n:::\n:::\n\n\n::: {#9602d25a .cell execution_count=23}\n``` {.python .cell-code}\n# number of parameters must match number of iterables\nfor x in map(lambda x, y, z: x+(y*z), (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"], [2, 3, 4]):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA!!\nB???\nC....\n```\n:::\n:::\n\n\n::: {#531d4741 .cell tags='[]' execution_count=24}\n``` {.python .cell-code}\n# operator module contains all of the common operators in function form\nimport operator\noperator.sub(20, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n15\n```\n:::\n:::\n\n\n`map` returns a special kind of *iterable*, can be wrapped in things other than list.\n\n::: {#da870719 .cell execution_count=25}\n``` {.python .cell-code}\nset(map(operator.sub, [20, 19], [10, 9]))\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n{10}\n```\n:::\n:::\n\n\n::: {#84ba74ac .cell execution_count=26}\n``` {.python .cell-code}\n# can use anywhere you can use an iterable\ntuple(map(lambda x: x * 3, (\"A\", \"B\", \"C\")))\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n('AAA', 'BBB', 'CCC')\n```\n:::\n:::\n\n\n### filter\n\n`filter(function, iterable)` \n\nreturns an iterable that contains all items from iterable for which `function(item)` returns True\n\nWe call this kind of function a *predicate*.\n\n::: {#45dff96d .cell execution_count=27}\n``` {.python .cell-code}\nlist(filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\", \"\"]))\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n['ABC', 'XYZ']\n```\n:::\n:::\n\n\n::: {#64e50cf6 .cell tags='[]' execution_count=28}\n``` {.python .cell-code}\nlist(map(lambda s: s*2, filter(str.isupper, [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n['ABCABC', 'XYZXYZ']\n```\n:::\n:::\n\n\n::: {#ecc1c6df .cell tags='[]' execution_count=29}\n``` {.python .cell-code}\nlist(filter(str.isupper, map(lambda s: s.title(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n['A']\n```\n:::\n:::\n\n\n::: {#afa7e5f0 .cell tags='[]' execution_count=30}\n``` {.python .cell-code}\nlist(map(lambda s: s.lower(), filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n['abc', 'xyz']\n```\n:::\n:::\n\n\n### functools\n\n<https://docs.python.org/3/library/functools.html>\n\n::: {#ebc5f65f .cell execution_count=31}\n``` {.python .cell-code}\nimport functools\n[name for name in dir(functools) if name[0].islower()]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n['cache',\n 'cached_property',\n 'cmp_to_key',\n 'get_cache_token',\n 'lru_cache',\n 'namedtuple',\n 'partial',\n 'partialmethod',\n 'recursive_repr',\n 'reduce',\n 'singledispatch',\n 'singledispatchmethod',\n 'total_ordering',\n 'update_wrapper',\n 'wraps']\n```\n:::\n:::\n\n\n``functools.reduce(function, iterable[, initializer])``\n\nApply ``function`` to pairs of items successively and return a single value as the result. You can optionally specify the initial value.\n\n::: {#c99d001b .cell execution_count=32}\n``` {.python .cell-code}\nimport functools \nimport operator \n\n# accumulator = 0\n# for item in my_list:\n#     accumulator += item\n\n# 1st iteration: Call operator.add(1,2) -> 3 \n# 2nd iteration: Call operator.add(3,3) -> 6 \n# 3rd iteration: Call operator.add(6,4) -> 10 \n# final result = 10 \nfunctools.reduce(operator.add, [1,2,3,4])\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n10\n```\n:::\n:::\n\n\n::: {#140a32a5 .cell execution_count=33}\n``` {.python .cell-code}\nnames = [\"Ben\", \"Martha\", \"Susan\"]\n# 1st iteration: call f(0, \"Ben\") -> 0 + len(\"Ben\") -> 3\n# 2nd iteration: call f(3, \"Martha\") -> 3 + len(\"Martha\") -> 9\n# 3rd iteration: call f(9, \"Susan\") -> 9 + len(\"Susan\") -> 14\nfunctools.reduce(lambda accumulator, new_val: accumulator + len(new_val), \n                 names, \n                 0)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n14\n```\n:::\n:::\n\n\n::: {#75e9447b .cell execution_count=34}\n``` {.python .cell-code}\n# What happens if you pass in an initial value \n# 1st iteration: Call operator.mul(2,1) -> 2 \n# 2nd iteration: Call operator.mul(2,2) -> 4 \n# 3rd iteration: Call operator.mul(4,3) -> 12 \n# 4th iteration: Call operator.mul(12,4) -> 48 \n# Final result = 48 \nfunctools.reduce(operator.mul, [1,2,3,4], 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n48\n```\n:::\n:::\n\n\n::: {#b1278948 .cell tags='[]' execution_count=35}\n``` {.python .cell-code}\nfunctools.reduce(lambda a,b: a+b, [1, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n6\n```\n:::\n:::\n\n\n```functools.partial(func, *args, **kwargs)```\n\n`functools.partial` returns a new function that \"binds\" any passed args & kwargs, and leaves other parameters unbound.\n\n::: {#9d05430b .cell execution_count=36}\n``` {.python .cell-code}\nimport operator\noperator.mul(2, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n20\n```\n:::\n:::\n\n\n::: {#a7c4049e .cell execution_count=37}\n``` {.python .cell-code}\nimport functools\nnegate = functools.partial(operator.mul, -1)\nnegate(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n-5\n```\n:::\n:::\n\n\n::: {#276d73fb .cell execution_count=38}\n``` {.python .cell-code}\nlist(map(negate, [1, 2, 3, 4]))\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n[-1, -2, -3, -4]\n```\n:::\n:::\n\n\n::: {#ab2d48b1 .cell execution_count=39}\n``` {.python .cell-code}\ndef calls_twice(f):\n    print(f())\n    print(f())\n    \n\ng = functools.partial(operator.mul, 4, 4)\n#print(g())\ncalls_twice(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n16\n16\n```\n:::\n:::\n\n\n::: {#53e86605 .cell execution_count=40}\n``` {.python .cell-code}\nprint_ex = functools.partial(print, sep=\"!\")\nprint_ex(\"a\", \"b\", \"c\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na!b!c\n```\n:::\n:::\n\n\n```python\n# ERROR: parameters must be valid\nprint_foo = functools.partial(print, foo=\"x\")\n```\n\n::: {#6f0c9c64 .cell execution_count=41}\n``` {.python .cell-code}\n# another way to deal with functions we're calling with the same args repeatedly\ndef request_page(url, verify, cache=True, send_cookies=False, https_only=True):\n    pass\n\nsecure_request = functools.partial(request_page, verify=True, https_only=True)\n```\n:::\n\n\n::: {#809d25ab .cell tags='[]' execution_count=42}\n``` {.python .cell-code}\nsecure_request(\"\", verify=False)\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}