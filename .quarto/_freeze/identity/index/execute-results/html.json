{
  "hash": "d12ba3aa157639a47737ffa16034127a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Identity & References\njupyter: python3\n---\n\nNow that we've seen all of the built-in types we can take a second look\nat mutability and explore what Python is doing under the hood, so that we are less likely to be surprised by the behavior.\n\n## Names & Mutability Revisited\n\nRemember that when we do an assignment, we are associating a **name** with an **object**, a value in memory.\n\nIt is the object that has a **type**, not the name.\n\n```python\n# a name is bound to the result of the expression\nx = 1 + 1\n# the name is re-assigned, we aren't changing data\nx = x + 1\n# this is why we can re-assign to a different type\nx = \"hello\"\n```\n\n#### Immutable Types\n\n - `str`\n - `tuple`\n - `frozenset`\n - scalars: `int`, `float`, `complex`, `bool`, `None`\n\nFor immutable types, this is the only option, any changes require *reassignment*.\n\n#### Mutable Types\n\n- `list`\n- `dict`\n- `set`\n\nOn the other hand, mutable values can be changed **in place**.\n\n```python\nx = [1, 2, 3]\nx.append(4)  # no re-assignment needed!\nprint(x)\n```\n\n### Object\n\nAll types in Python share an internal representation as an **object** (`PyObject` in C).\n\n```python\nll = [1, 2, 3, 4]\nyy = ll           # increase ref count\n```\n\n**object**\n\n| Field | Example | Purpose |\n|-|-|-|\n| id | 393239323 | uniquely identify object within Python interpreter |\n| refcount | 2 | count how many names currently point to this object |\n| type | `list` | type of object |\n| data | 0x80000000 | memory address where the *actual* data is stored |\n| length | 4 | Only present on collection types, stores pre-computed length. |\n\nNotice that name is not stored on the **object**! Why not?\n\n## Shared references\n\nMultiple names can refer to the same object in memory, this is noticable when the objects in question are mutable.\n\n::: {#e8e6966f .cell execution_count=1}\n``` {.python .cell-code}\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(f\"{y=}\")\n# spooky action at a distance\nprint(f\"{x=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny=[1, 2, 3, 4]\nx=[1, 2, 3, 4]\n```\n:::\n:::\n\n\nFor immutables, any change causes reassignment:\n\n::: {#342ab38b .cell execution_count=2}\n``` {.python .cell-code}\na = 3\nb = a\na *= 2         # reassignment!\nprint(f\"{a=} {b=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na=6 b=3\n```\n:::\n:::\n\n\n## Garbage Collection\n\nPython is a garbage collected language.  \n\nWe don't free our own memory, Python does instead.\n\nBehind the scenes, Python stores a reference counter on each `object`.  How many names/objects reference the object.\n\nWhen reference count drops to zero, Python can reclaim the memory.\n\n## Identity\n\nThe built-in `id(...)` function returns the identity of an object, which is an integer value guaranteed to be unique and constant for lifetime of object\n\nIn the official (\"CPython\") Interpreter we are using in this class, it is the address of the memory location storing the object.\n\n::: {#ae71e8c5 .cell execution_count=3}\n``` {.python .cell-code}\nx = \"Orange\" \nprint(id(x))  # Unique integer-value for the object pointed by x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4375914096\n```\n:::\n:::\n\n\n::: {#c0b6369c .cell execution_count=4}\n``` {.python .cell-code}\ny = \"Apple\" \nprint(id(y)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4393888736\n```\n:::\n:::\n\n\n::: {#dd925c16 .cell execution_count=5}\n``` {.python .cell-code}\nfruit1 = (\"Apples\", 4)\nfruit2 = (\"Apples\", 4)\nfruit3 = fruit2\nprint(f\"Fruit1 id = {id(fruit1)} \\n Fruit2 id = {id(fruit2)}\")\nprint(f\"Fruit3 id= {id(fruit3)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFruit1 id = 4394173120 \n Fruit2 id = 4394173184\nFruit3 id= 4394173184\n```\n:::\n:::\n\n\n::: {#d016e4e7 .cell execution_count=6}\n``` {.python .cell-code}\nfruit1 is fruit2\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nFalse\n```\n:::\n:::\n\n\n#### Equality vs. Identity\n\nTwo different ways of testing if objects are the \"same\":\n\n- Equality operator (`==`): Returns true if two objects are equal (i.e., have the same value)\n- Identity operator (`is`): Returns true if two objects identities are the same.\n\n`a is b` means `id(a) == id(b)`\n\n::: {#26dd06f3 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=7}\n``` {.python .cell-code}\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(\"a == b\", a == b)\n\nprint(id(a))\nprint(id(b))\nprint(\"a is b\", a is b)  # The id values are different\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na == b True\n4394339968\n4394170176\na is b False\n```\n:::\n:::\n\n\n::: {#13185132 .cell execution_count=8}\n``` {.python .cell-code}\nprint(id(None))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4340290104\n```\n:::\n:::\n\n\n::: {#27beb42c .cell execution_count=9}\n``` {.python .cell-code}\ndef f():\n    pass\nid(f())\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n4340290104\n```\n:::\n:::\n\n\n#### `is None`\n\nIf you ever need to check if a value is `None`, you'd use `is None` or `is not None`\n\n### list / string mutability revisited\n\n::: {#23db38d0 .cell execution_count=10}\n``` {.python .cell-code}\n# list d\nd = [1, 2, 3]\nprint(id(d))\nd.append(4)\nprint(d)\nprint(id(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4394340224\n[1, 2, 3, 4]\n4394340224\n```\n:::\n:::\n\n\n::: {#264cd37d .cell execution_count=11}\n``` {.python .cell-code}\n# str D\ns = \"Hello\"\nprint(id(s))\ns += \" World\"\nprint(s)\n\n# did s change?\nprint(id(s))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4393893152\nHello World\n4394351472\n```\n:::\n:::\n\n\n### Aside: Object Creation Quirk\n\n>  Each time you generate a new value in your script by running an expression, Python creates a new object (i.e., a chunk of memory) to represent that value.\n>    \n> -- Learning Python 2013\n\nNot quite! CPython does not guarantee this, and in fact sometimes caches & reuses immutable objects for efficiency.\n\n::: {#3c2d65fe .cell execution_count=12}\n``` {.python .cell-code}\na = 100000000\nb = 100000000\n\n# Two different objects, two different ids.\nprint(a is b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#2ca64226 .cell execution_count=13}\n``` {.python .cell-code}\na = 100\nb = 100\n\n# However, for small integer objects, CPython caches them\n# this means that a and b point to the same object\nprint(a is b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#4b815faf .cell execution_count=14}\n``` {.python .cell-code}\n# CPython does the same for short strings\nstr1 = \"MPCS\"\nstr2 = \"MPCS\"\nprint(id(str1), id(str2))\nstr1 is str2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4393805760 4393805760\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nTrue\n```\n:::\n:::\n\n\nIn practice this is just a quirk of the CPython interpreter, since the objects are immutable it isn't important to know that they share memory in some cases.\n\n## copy & deepcopy\n\nIf `y = x` does not make a copy, how can we get one?\n\nWe've seen the `.copy()` method on a few of our types.  Which ones?\n\nWe can also use the `copy` module:\n\n::: {#b91d6e7a .cell execution_count=15}\n``` {.python .cell-code}\nx = [1, 2, 3]\ny = x.copy()\n\nprint(id(x))\nprint(id(y))\n\nx.append(4)\nprint(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4394171776\n4394172224\n[1, 2, 3, 4] [1, 2, 3]\n```\n:::\n:::\n\n\n::: {#f713bd32 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=16}\n``` {.python .cell-code}\n# shallow copy example (nested mutables are not copied)\n\nx = [[1, 2], [3, 4]]\ny = x.copy()  # or copy.copy(x)\n\nprint(\"x is y\", x is y)\nprint(\"x[0] is y[0]\", x[0] is y[0])\nprint(\"x[1] is y[1]\", x[1] is y[1])\n\n# print(x, y)\nx[0].append(5)\nprint(x, \"\\n\", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is y False\nx[0] is y[0] True\nx[1] is y[1] True\n[[1, 2, 5], [3, 4]] \n [[1, 2, 5], [3, 4]]\n```\n:::\n:::\n\n\n::: {#83587d99 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"fragment\"}}' execution_count=17}\n``` {.python .cell-code}\n# deep copy (nested mutables are copied)\nimport copy\n\n# copy.copy(obj) --> same as obj.copy()\nz = copy.deepcopy(x)\nprint(\"x[0] is z[0]\", x[0] is z[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx[0] is z[0] False\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}