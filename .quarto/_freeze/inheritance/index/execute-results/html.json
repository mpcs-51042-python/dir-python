{
  "hash": "952d9036d6ceab234792b17c7bf521a6",
  "result": {
    "engine": "jupyter",
    "markdown": "# Inheritance\n\n## Motivations\n\nLet's say we're building an application that tracks students.\n\n::: {#0af2ebc4 .cell execution_count=1}\n``` {.python .cell-code}\nclass Student:\n\n    # this is a class-level variable\n    # instead of each instance having its own copy\n    # the variable is shared among all `Student`\n    next_id_counter = 1\n    \n    def __init__(self, name):\n        # assign each student a unique id\n        # note use of Student. not self.\n        self.id = Student.next_id_counter\n        Student.next_id_counter += 1\n        \n        self.name = name\n        self.year = 1\n        self.major = \"Undeclared\"\n        self.course_grades = {}\n        self.extracurriculars = []\n        \n    def add_grade(self, course_name, grade):\n        self.course_grades[course_name] = grade\n    \n    @property\n    def gpa(self):\n        grade_pts = {\"A\":4.0, \"A-\":3.7, \"B+\":3.3, \"B\":3.0, \"B-\":2.7, \"C+\":2.3, \"C\":2.0, \"C-\":1.7, \"D+\":1.3, \"D\":1.0, \"F\":0.0} \n        if len(self.course_grades) == 0:\n            return 0\n        return sum(grade_pts[g] for g in self.course_grades.values()) / len(self.course_grades)\n    \n    def __repr__(self):\n        return f\"Student(name={self.name}, id={self.id}, gpa={self.gpa})\"\n```\n:::\n\n\n::: {#d9631b11 .cell tags='[]' execution_count=2}\n``` {.python .cell-code}\ns1 = Student(\"Adam\")\ns2 = Student(\"Beth\")\ns2.add_grade(\"Programming Python\", \"A\")\ns2.add_grade(\"Discrete Math\", \"B+\")\n```\n:::\n\n\n::: {#8daad37b .cell tags='[]' execution_count=3}\n``` {.python .cell-code}\nprint(s1)\nprint(s2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStudent(name=Adam, id=1, gpa=0)\nStudent(name=Beth, id=2, gpa=3.65)\n```\n:::\n:::\n\n\nPerhaps we want to add `Alumni` to our application.\n\nAn alum will have some things in common with students:\n\n- They still have a name.\n- We want to remember their major.\n- We'll still want to keep track of their grades/GPA.\n\nWe now also:\n\n- Want to record their year of graduation.\n- No longer want to allow grades to be recorded.\n- Want to be able to calculate how long ago they graduated.\n- When displaying them, we want to display their graduation year.\n\n**How to implement?**\n\nWe *could* copy `student.py` and rename to `alum.py` and rename the class as needed.\n\n**But copying & pasting is generally a bad idea!**\n\nWe'd need to fix bugs & add features in both classes separately.\n\nA new feature in `Student` would need to be copied over to `Alum`, this will quickly get messy.\n\n## Inheritance in Python\n\nInstead we will use **inheritance**, which allows us to create a new class from an existing one.  The new class inherits the attributes and methods from the parent.\n\n- **superclass**, **parent**, or **base** class: The pre-existing class.\n- **subclass**, **child**, or **derived** class: The new class that inherits the code (attributes & methods) of another class.\n\nSubclasses can extend/modify the functionality of superclasses.\n\nSyntax:\n\n```python\nclass Subclass(Superclass):\n    pass\n```\n\nFor example:\n\n```python\nclass Alum(Student):\n    pass\n```\n\nAt this point, `Alum` is a new class with the exact same implementation as `Student`.\n\nTypically we'll want to add new instance & class variables, methods, etc.\n\nNewly defined features will only apply to instances of `Alum`\n\nIt is possible to override parent class behavior, or rely on parent behavior, whichever is needed.\n\n### Adding & Overriding Behavior\n\n::: {#ab529be9 .cell tags='[]' execution_count=4}\n``` {.python .cell-code}\nclass Alum(Student):\n    def __init__(self, name, grad_year):\n        # call Student's constructor, which contains id logic\n        super().__init__(name)\n        self.graduation_year = grad_year\n        \n    # new behavior\n    def years_since_graduation(self, now):\n        return now - self.graduation_year\n    \n    # overrides parent's add_grade\n    def add_grade(self, course_name, grade):\n        raise NotImplementedError(\"cannot add grades to Alum\")\n        #print(\"Sorry, you cannot add grades to Alums\")\n        # we choose not call super().add_grade here\n    \n    # overrides parent's __repr__\n    def __repr__(self):\n        #return f\"Alum(name={self.name}, id={self.id}, gpa={self.gpa}, graduated={self.graduation_year})\"\n        string = super().__repr__()\n        string += \" is an alum\"\n        return string\n```\n:::\n\n\n::: {#eef1e0b0 .cell execution_count=5}\n``` {.python .cell-code}\nalum1 = Alum(\"Charlie\", 2016)\nprint(alum1)\nprint(alum1.years_since_graduation(2022), \"years since graduation\")\n#alum1.add_grade(\"Python\", \"B\")\nalum1.gpa\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStudent(name=Charlie, id=3, gpa=0) is an alum\n6 years since graduation\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n0\n```\n:::\n:::\n\n\n::: {#4d6c77f4 .cell execution_count=6}\n``` {.python .cell-code}\nalum2 = Alum(\"Charlie\", 2016)\n```\n:::\n\n\n### super()\n\nAllows direct access to parent class(es).\n\nMany different ways to be called, but for our purposes we will stick to `super().method_name()` to access parent implementation of `method_name()`\n\n### issubclass & isinstance\n\n- `isinstance(object, class_type)` - Check if an object is of an instance.\n- `issubclass(class_type, class_type2)` - Check if a type is a subclass of another type.\n\n::: {#ddff2316 .cell execution_count=7}\n``` {.python .cell-code}\nisinstance(7, int)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#367388d9 .cell execution_count=8}\n``` {.python .cell-code}\n# same as?\ntype(7) == int\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#29e13813 .cell execution_count=9}\n``` {.python .cell-code}\ntype(7) == object\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#4685517a .cell execution_count=10}\n``` {.python .cell-code}\nisinstance(7,  object)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#9c215901 .cell execution_count=11}\n``` {.python .cell-code}\n# isinstance checks the inheritance hierarchy \nisinstance(alum2, object)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#490b3180 .cell execution_count=12}\n``` {.python .cell-code}\ntype(alum2) == Student\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#e50d47e1 .cell execution_count=13}\n``` {.python .cell-code}\nisinstance([1, 2, 3], list)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#f61a7f1a .cell execution_count=14}\n``` {.python .cell-code}\ns1 = Student(\"Sarah\")\nisinstance(s1, Student)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#480fd3cb .cell execution_count=15}\n``` {.python .cell-code}\n# child classes are instances of parent types\nalum1 = Alum(\"Charlie\", 2016)\nisinstance(alum1, Student)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#4dfe580e .cell execution_count=16}\n``` {.python .cell-code}\n# but not vice-versa\nisinstance(s1, Alum)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nFalse\n```\n:::\n:::\n\n\n```python\n# INCORRECT: issubclass takes class names, not instances\nissubclass(alum1, Student)\n\n# Instead\nissubclass(Alum, Student)\n```\n\n### `object`\n\nEvery object derives from a base class named `object`.\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = y\n\n# Same as: \n\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = y\n        self.y = y\n```\n\n### MRO\n\nWhen we call a function, Python walks up the chain of parent classes to determine the first one that has the method defined.\n\nThis is called the **method resolution order**.\n\n::: {#589c2b4b .cell execution_count=17}\n``` {.python .cell-code}\nhelp(Alum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on class Alum in module __main__:\n\nclass Alum(Student)\n |  Alum(name, grad_year)\n |\n |  Method resolution order:\n |      Alum\n |      Student\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, name, grad_year)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  add_grade(self, course_name, grade)\n |      # overrides parent's add_grade\n |\n |  years_since_graduation(self, now)\n |      # new behavior\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from Student:\n |\n |  gpa\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Student:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Student:\n |\n |  next_id_counter = 7\n\n```\n:::\n:::\n\n\n::: {#69bd4338 .cell execution_count=18}\n``` {.python .cell-code}\nAlum.__mro__\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n(__main__.Alum, __main__.Student, object)\n```\n:::\n:::\n\n\n::: {#1545b8bb .cell execution_count=19}\n``` {.python .cell-code}\nhelp(super)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on class super in module builtins:\n\nclass super(object)\n |  super() -> same as super(__class__, <first argument>)\n |  super(type) -> unbound super object\n |  super(type, obj) -> bound super object; requires isinstance(obj, type)\n |  super(type, type2) -> bound super object; requires issubclass(type2, type)\n |  Typical use to call a cooperative superclass method:\n |  class C(B):\n |      def meth(self, arg):\n |          super().meth(arg)\n |  This works for class methods too:\n |  class C(B):\n |      @classmethod\n |      def cmeth(cls, arg):\n |          super().cmeth(arg)\n |\n |  Methods defined here:\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __self__\n |      the instance invoking super(); may be None\n |\n |  __self_class__\n |      the type of the instance invoking super(); may be None\n |\n |  __thisclass__\n |      the class invoking super()\n\n```\n:::\n:::\n\n\n## Abstract Base Classes\n\nSometimes we want to define a class that can't be instantiated directly, but is intended to be inherited from.\n\nThese are known as **abstract classes**.  This helps us define an interface, which contains a collection of methods that the **concrete class** must implement.\n\n::: {#927a1c2e .cell execution_count=20}\n``` {.python .cell-code}\ndef print_dot_prod(v1, v2):\n    \"\"\" prints dot product between two vectors \"\"\"\n    print(v1.dot_product(v2))\n```\n:::\n\n\nIf we want this  method to be polymorphic for vectors of multiple dimensions, such as:\n\n::: {#5fdb7c7c .cell execution_count=21}\n``` {.python .cell-code}\nclass Vec2:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y  \n\n    def dot_product(self, other):\n        ...\n        \nclass Vec3:\n    def __init__(self,x,y,z):\n        self.x = x\n        self.y = y  \n        self.z = z \n\n    def dot(self, other):\n        ...\n```\n:::\n\n\nWe can force that these types implement an interface (i.e., an abstract base class) such that we can guarantee that objects we pass to ``print_dot_prod`` will always work by forcing them to implement a ``dot_product`` method. \n\nWe will define an abstract class called ``Vector`` that has only the required method: \n\n`` def dot_product(self, other) `` \n\n::: {#5e58ae0f .cell tags='[]' execution_count=22}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\n\nclass Vector(ABC):\n    # an unimplemented method\n    @abstractmethod\n    def dot_product(self, other):\n        pass\n\n    # demonstrate we can have a normal method\n    def print_x(self):\n        print(self.x)\n\n```\n:::\n\n\n::: {#369229cb .cell execution_count=23}\n``` {.python .cell-code}\n# we can't instantiate abstract classes\ntry:\n    v = Vector()\nexcept Exception as e:\n    print(repr(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTypeError(\"Can't instantiate abstract class Vector without an implementation for abstract method 'dot_product'\")\n```\n:::\n:::\n\n\n::: {#5f63e377 .cell execution_count=24}\n``` {.python .cell-code}\nclass Vec2(Vector):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y  \n        \n    def dot_product(self, other): \n        return self.x * other.x + self.y * other.y\n        \nclass Vec3(Vector):\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y  \n        self.z = z \n        \n    def dot_product(self, other): \n        return self.x * other.x + self.y * other.y + self.z * other.z\n```\n:::\n\n\nNow `print_dot_prod` works:\n\n::: {#f35a7a26 .cell execution_count=25}\n``` {.python .cell-code}\n# Vec2 and Vec3 objects are instances of Vector since their classes \n# inherit from the Vector ABC.\nv2a = Vec2(1,2)\nv2b = Vec2(3,4)\nv3a = Vec3(6,7,3)\nv3b = Vec3(1,2,3)\n\nprint(isinstance(v2a, Vec2)) \nprint(isinstance(v2a, Vector)) \nprint(\"----\")\nprint(isinstance(v3a, Vec3)) \nprint(isinstance(v3a, Vector))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\n----\nTrue\nTrue\n```\n:::\n:::\n\n\n::: {#1f769487 .cell execution_count=26}\n``` {.python .cell-code}\nv2a.print_x()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\n::: {#3eb82299 .cell execution_count=27}\n``` {.python .cell-code}\nprint_dot_prod(v2a, v2b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n11\n```\n:::\n:::\n\n\n::: {#fb7f52b6 .cell execution_count=28}\n``` {.python .cell-code}\nprint_dot_prod(v3a, v3b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n29\n```\n:::\n:::\n\n\n## Dataclasses\n\nPython 3.7 added `dataclasses` as a handy way to create classes that are mostly responsible for representing data.\nThese classes often have few or no methods defined.\n\n::: {#db398fbc .cell execution_count=29}\n``` {.python .cell-code}\nfrom dataclasses import dataclass\n\n@dataclass\nclass InventoryItem:\n    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n    name: str\n    unit_price: float\n    quantity_on_hand: int = 0\n\n    def total_cost(self) -> float:\n        return self.unit_price * self.quantity_on_hand\n\n# class decorator!\n# similar concept, much harder to write\n# \n# InventoryItem = dataclass(InventoryItem)\n```\n:::\n\n\n::: {#ba7a9506 .cell execution_count=30}\n``` {.python .cell-code}\nwrench = InventoryItem(\"Wrench\", 12.95, 10)\nhammer = InventoryItem(\"Hammer\", 16, 8)\nnails = InventoryItem(\"Nails\", 0.03, 1000)\nsaw = InventoryItem(\"Saw\", 99)\nsaw2 = InventoryItem(\"Saw\", 99)\n```\n:::\n\n\n::: {#426ff83d .cell execution_count=31}\n``` {.python .cell-code}\nsaw == saw2\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\nTrue\n```\n:::\n:::\n\n\nDataclasses get an automatic `__init__`, `__repr__`, `__eq__`, and several other helpful options.  (Even more is possible via the decorator: https://docs.python.org/3/library/dataclasses.html)\n\n::: {#d0bbc02c .cell tags='[]' execution_count=32}\n``` {.python .cell-code}\nnails.total_cost()\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n30.0\n```\n:::\n:::\n\n\nBeyond this, additional methods/staticmethods/etc. can be defined in the usual way.\n\nThis syntax uses Python's type-hinting, and if you're looking to use it you'll want to get familiar with the rules\naround complex types: <https://docs.python.org/3/library/typing.html>\n\n::: {#5cd2a89c .cell execution_count=33}\n``` {.python .cell-code}\n# instead of returning tuples and \n# remembering the positional order, can instead\n@dataclass\nclass RetType:\n    data: list[int]\n    counter: int\n\ndef fn():\n    return RetType([], counter)\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}