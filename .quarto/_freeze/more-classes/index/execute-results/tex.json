{
  "hash": "5c88d903a47adf0307c8ff96071fd267",
  "result": {
    "engine": "jupyter",
    "markdown": "# Class Methods & Properties\n\n## Encapsulation\n\nWe've discussed how a fundamental principle of class-based OOP is that a class should be usable *without needing to understand, or even know how data is stored within*.\n\nWe call this **encapsulation**, the bundling of data with all behaviors that can act on or modify that data.\nThis separation of concerns is what allows you to use a Python dictionary without worrying about hashtable semantics, or a list without thinking about memory allocation.\n\nAnother way to put this is that a class should be responsible for any modifications to its internal state.\n\nWhen you are working on a large team, proper use of encapsulation/OOP provides one mechanism to ensure that your changes won't break other people's code.\nEncapsulation allows the implementation of an object's interface to be changed without impacting the users of that object.\"\n\nTo understand this better, let's look at why it may be a bad idea to allow users to change attributes:\n\n```python\ncar2.mileage -= 100     # rewind the odometer\ncar2.hybrid = \"no\"      # should have been False & probably immutable\n```\n\nImagine that in our data `year` is sometimes an integer and sometimes a string, but we always want to be able to calculate a vehicles age, we could decide to force the type in the constructor:\n\n```python\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = int(year)   # coerce to int year\n        self.mileage = 0\n        self.hybrid = False\n        \n    def drive(self, miles):\n        if miles < 0:\n            raise ValueError('miles must be positive')\n        self.mileage += miles\n```\n\nWe also protect against trying to roll back the odometer by driving in reverse\nby ensuring that `drive` only accepts positive values.\n\nThis may not be sufficient however, a user might still see the `year` attribute\nand assume they can set it themselves, outside the constructor, or modify `mileage` directly.\n\nTo help *enforce* encapsulation, languages often provide features like private attributes, getters & setters, and properties.  We'll take a look at how Python approaches these.\n\n## There is no \"private\" in Python\n\nSome languages use access specifiers like \"private\", \"public\", \"protected\" to disallow modifications from outside of the class. With these keywords in Java for instance, modification of `private` attributes is restricted to methods of the class.\n\nPython does not have this kind of variable, and instead relies on convention, we signal to other programmers what we expect them to do.\nIf they choose to break those rules, they can expect to deal with unintended consequences or interface breakage.\n\nBy *convention* a name with a single underscore at the front is meant to be \"internal\" to the class, and should not be modified except from methods of that class. (`self._mileage`, `self._year`)\n\nGoing a step further, a name with a double underscore at the front is actually modified internally by Python to avoid people assigning to it accidentally.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass Car: \n    def __init__(self, make, model, year):\n        self._make = make \n        self._model = model \n        self._year = year\n        self.__mileage = 0\n                \n    def drive(self, miles):\n        if miles > 0:\n            self.__mileage += miles\n        else:\n            ...\n            \n    def print_report(self):\n        print(f\"{self._year} {self._make} {self._model} with {self.__mileage} miles\")\n    \ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\n\ncar2.drive(500)\ncar2.print_report()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022 Chevy Volt with 500 miles\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ncar2._year\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n2022\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndir(car2)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n['_Car__mileage',\n '__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getstate__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_make',\n '_model',\n '_year',\n 'drive',\n 'print_report']\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# soft protection, can still access but \"at your own risk\"\ncar2._make = \"???\"\nprint(car2._make) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n???\n```\n:::\n:::\n\n\n## Getters / Setters\n\nTo avoid issues with people depending on internal attributes, it is common in some languages (and tempting in Python) to force users to make all modifications through get & set methods, sometimes called getters and setters:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nclass Person:\n    def __init__(self, name, age):\n        self.__name = name  #  Assume it has getter/setters not shown here\n        self.set_age(age)\n\n    def get_age(self):\n        return self.__age\n\n    def set_age(self, age):\n        # can protect against invalid data\n        if age < 0:\n            raise ValueError(\"Person can't have a negative age!\")\n        self.__age = age\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\np = Person(\"C. Montgomery Burns\", 100)\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\np.get_age()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n100\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\np.set_age(101)\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\np.get_age()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n101\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ntry:\n    p.set_age(-1)\nexcept Exception as e:\n    print(repr(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValueError(\"Person can't have a negative age!\")\n```\n:::\n:::\n\n\nThis is a fine solution when there is work for the getters & setters to do, but\noften there isn't-- and they'll (at least initially) be very repetitive.\n\nWe still must provide them from the start, because if we didn't we couldn't make changes to the class (for example, storing birthdate instead of age) since there would be code in our program that directly accessed `Person.age`.\n\nHowever, in Python, **we tend not to use getters and setters**, instead we allow attributes that are meant to be changed to be set directly.\n\n## Properties\n\nThis difference is possible because of how Python allows us to define **properties**.\n\nSay we want the advantages of encapsulation (being able to avoid improper use, hiding our internal representation, etc.) but without the need to start with a bunch of getter/setter functions that aren't (yet) needed.\n\nThere is a built in function `property()` that creates and returns a property object.\n\n`property(fget=None, fset=None, fdel=None, doc=None)`\n\n- `fget` is a function to get value of the attribute\n- `fset` is a function to set value of the attribute\n- `fdel` is a function to delete the attribute\n- `doc` is a docstring for the attribute\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nclass Person:\n    \n    def __init__(self, name, age):\n        self.name = name  #  Assume it has getter/setters \n        self.age = age\n\n    def _get_age(self):\n        print(\"inside get age\")\n        return self.__age\n\n    def _set_age(self, age):\n        if age < 0:\n            raise ValueError(\"Person can't have a negative age!\")\n        self.__age = age\n        \n    def __repr__(self):\n        return f\"Person({self.__name!r}, {self.__age})\"\n        \n    age = property(_get_age, _set_age, doc=\"age of the person\")\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\np = Person(\"Wayne\", 30)\np.age # will call _get_age\n\ntry:\n    p.age = -1 # will call _set_age\nexcept Exception as e:\n    print(repr(e))\n\nprint(p.age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninside get age\nValueError(\"Person can't have a negative age!\")\ninside get age\n30\n```\n:::\n:::\n\n\n### @property\n\nWe can also use `property` as a decorator.\n\nThe usage looks a bit strange since we need to decorate multiple functions:\n\n- Place the `@property` directly above the function header of the getter function.\n- Place the code `@name_of_property.setter` above the function header of the setter function. You need to replace the name_of_property with the actual name of the property.\n- The function names for both the setter/getter need to match.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nclass Person:\n    def __init__(self, name, age):\n        self.__name = name  #  Assume it has getter/setters \n        # invokes setter\n        self.age = age #self.set_age(age)\n        self.birth_date = ...\n\n    @property\n    def age(self):\n        \"\"\" returns the age property \"\"\"\n        print('getter called')\n        return self.__age\n    # same as \n    #age = property(age)\n    \n    @age.setter\n    def age(self, age):\n        print('setter called')\n        if age < 0:\n            raise ValueError(\"Person can't have a negative age!\")\n        self.__age = age\n        \n    def __repr__(self):\n        return f\"Person({self.__name!r}, {self.__age})\"\n```\n:::\n\n\nThe existence of properties allows us to start all attributes out as public ones, and convert to properties as needed.\nThe user of the class does not need to know that a change was made, preserving encapsulation without forcing us into calling setter/getters.\n\n### Read-only/Calculated Properties\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nclass Rectangle: \n    \n    def __init__(self,width,height):\n        self.width = width \n        self.height = height\n        # this would only happen once and not update when width or height are changed\n        # self.area = width*height\n    \n    # read-only calculated property (no setter)\n    @property \n    def area(self):\n        return self.width * self.height \n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nr = Rectangle(3, 9)\n```\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nprint(r.area)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n27\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# area is dynamically calculated each call\nr.width = 6\nprint(r.area)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n54\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# but can't be set\ntry:\n    r.area = 4\nexcept Exception as e:\n    print(\"ERROR\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nERROR property 'area' of 'Rectangle' object has no setter\n```\n:::\n:::\n\n\n## Class Attributes\n\nSometimes we want to share data between all instances of a given class.\n\nAll cars have 4 wheels, so we could define a shared variable accessible to all instances of the `Car` class.\n\nTo do this, we create them within the `class` body, usually right above the `__init__`.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nimport datetime\n\nclass Car:\n    # class attribute\n    wheels = 4\n    registrations = []\n\n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n        # add this car to the global registry of all cars\n        Car.registrations.append(self)\n\n        # setting this attribute would shadow Car.wheels\n        # both would exist, but we'd need to be explicit\n        # about which we intended to use (avoid this!)\n        # self.wheels = 0\n    \n    def compute_age(self):\n        return datetime.date.today().year - self.year \n    \n    \ncar1 = Car(\"Honda\", \"Accord\", 2019)\ncar2 = Car(\"Toyota\", \"RAV4\", 2006)\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# class attribute can be accessed on instances, or the class itself\nprint(Car.wheels)\nprint(car1.wheels)\nprint(car2.wheels)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n4\n4\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# these are all the same variable\nCar.wheels is car1.wheels\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# this means changes to the class attribute affect all classes\n\nCar.wheels = 3\nprint(car1.wheels)\nprint(car2.wheels)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n3\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Careful: assigning to an instance attribute makes a new attribute\n\n# creates a new instance variable! not what we wanted!\ncar2.wheels = 2\nprint(car2.wheels is car1.wheels)\nprint(car1.wheels)\nprint(Car.wheels)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n3\n3\n```\n:::\n:::\n\n\n## Class Methods\n\nIt can also be useful to provide methods that are accessible to all instances of a class.\n\nClass methods are similar to instance methods with a few distinctions:\n\n1. They can not access instance methods or attributes.\n2. The first argument to the method is not `self`, but instead `cls` by convention.  `cls` is the class object itself (e.g. `Car`)\n3. Class methods are declared with the `@classmethod` decorator.\n\n::: {.cell tags='[]' execution_count=24}\n``` {.python .cell-code}\nfrom datetime import date\n\nclass Car: \n    \n    # wheels class attribute \n    wheels = 4\n    # tire pressure class attribute  \n    psi = 35 \n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n    \n    def compute_age(self):\n        print(self)\n        current_year = int(date.today().year)\n        return current_year - self.year \n    \n    @classmethod \n    def tire_description(cls):\n        print(cls)\n        return f'Car has {cls.wheels} wheels with a tire pressure of {Car.psi}' \n    \ncar1 = Car(\"Honda\", \"Accord\", 2019)\ncar2 = Car(\"Toyota\", \"RAV4\", 2006)\n```\n:::\n\n\n::: {.cell tags='[]' execution_count=25}\n``` {.python .cell-code}\nprint(Car.tire_description())\n#print(car1.tire_description())\nprint(car1.compute_age())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class '__main__.Car'>\nCar has 4 wheels with a tire pressure of 35\n<__main__.Car object at 0x1039bfdd0>\n7\n```\n:::\n:::\n\n\nNotice that we can use `Car.psi` or `cls.wheels` to access class attributes. `cls` is generally preferred, both to avoid repetition and for reasons we'll see when we get to inheritance.\n\nFinally, note that we can access class methods and instances from within instance methods. (but not vice-versa!)\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nfrom datetime import date\nclass Car: \n    \n    # wheels class attribute \n    wheels = 4\n    \n    # tire pressure amount \n    psi = 35 \n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n    \n    def compute_age(self):\n        current_year = int(date.today().year)\n        return current_year - self.year \n    \n    @classmethod \n    def tire_description(cls):\n        return f'Car has {cls.wheels} wheels, each with a tire pressure of {Car.psi}' \n\n    def __repr__(self): \n        instance_str = f'Car(make={self.make}, model={self.model}, year={self.year}, '\n        instance_str += f'wheels={Car.wheels}, {self.tire_description()})'\n        return instance_str\n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ncar1 = Car(\"Honda\", \"Civic\", 2019)\nprint(car1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCar(make=Honda, model=Civic, year=2019, wheels=4, Car has 4 wheels, each with a tire pressure of 35)\n```\n:::\n:::\n\n\n### Alternate Constructors\n\nA common use of class methods is to define alternate ways to initialize an isntance.  In Python there can only be one constructor (`__init__`), whereas some other languages allow multiple.\n\nPerhaps we have Car data coming from a file, meaning we'd have strings like:\n\n::: {.cell tags='[]' execution_count=28}\n``` {.python .cell-code}\ncar1str = \"Pontiac|Grand Am|1997|4892\"\ncar2str = \"Ford|Mustang|1970|800\"\ncar3str = \"Hyundai|Sonata|2007|0\"\n\n\ndef make_car_from_string(s: str) -> Car:\n    ...\n```\n:::\n\n\n::: {.cell tags='[]' execution_count=29}\n``` {.python .cell-code}\nfrom datetime import date\n\nclass Car: \n    wheels = 4\n    psi = 35\n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n        self.mileage = 0\n        \n    @classmethod\n    def from_string(cls, string):\n        make, model, year, mileage = string.split(\"|\")\n        # invoke Car's constructor\n        new_instance = cls(make, model, year)\n        new_instance.mileage = mileage\n        return new_instance\n    \n    def compute_age(self):\n        current_year = int(date.today().year)\n        return current_year - self.year \n    \n    @classmethod \n    def tire_description(cls):\n        return f'Car has {cls.wheels} wheels, each with a tire pressure of {Car.psi}' \n\n    def __repr__(self): \n        instance_str = f'Car(make={self.make}, model={self.model}, year={self.year}, '\n        instance_str += f'wheels={Car.wheels})'\n        return instance_str\n```\n:::\n\n\n::: {.cell tags='[]' execution_count=30}\n``` {.python .cell-code}\ncar1 = Car.from_string(car1str)\ncar2 = Car.from_string(car2str)\ncar3 = Car.from_string(car3str)\n```\n:::\n\n\n::: {.cell tags='[]' execution_count=31}\n``` {.python .cell-code}\nprint(car1)\nprint(car2)\nprint(car3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCar(make=Pontiac, model=Grand Am, year=1997, wheels=4)\nCar(make=Ford, model=Mustang, year=1970, wheels=4)\nCar(make=Hyundai, model=Sonata, year=2007, wheels=4)\n```\n:::\n:::\n\n\nThis is a common pattern, seen throughout Python:\n\n - ``int.from_bytes()``\n - ``float.fromhex()`` \n - ``datetime.date.fromtimestamp()``\n - ``itertools.chain.from_iterable()``\n\n```python\nx = list(map(...))\ny = dict(...)\n```\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nimport datetime\ndatetime.date(2024, 11, 11)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\ndatetime.date(2024, 11, 11)\n```\n:::\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\ndatetime.date.fromtimestamp(1234567890)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\ndatetime.date(2009, 2, 13)\n```\n:::\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nimport itertools\nfor x in itertools.chain.from_iterable([(1,2,3), (4,5,6)]):\n    print(x)\n#for x in (1,2,3):\n#    print(x)\n#for x in (4,5,6):\n#    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n6\n```\n:::\n:::\n\n\n### staticmethod\n\nSometimes it makes sense to just attach a method to a class for the purpose of namespacing.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ndef which_is_newer(a, b):\n    if a.year > b.year:\n        return a\n    else:\n        return b\n\nwhich_is_newer(car1, car2)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\nCar(make=Pontiac, model=Grand Am, year=1997, wheels=4)\n```\n:::\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# it might make sense to attach this to the class, \n# but neither a classmethod nor an instance method\n\nfrom datetime import date\nclass Car: \n    wheels = 4\n    psi = 35\n    \n    # does not take self or cls\n    @staticmethod\n    def which_is_newer(a, b):\n        if a.year > b.year:\n            return a\n        else:\n            return b\n        \n    @staticmethod\n    def something():\n        return []\n    \n\n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n        \n    @classmethod\n    def from_string(cls, string):\n        make, model, year = string.split(\"|\")\n        # invoke Car's constructor\n        return cls(make, model, year)\n\n    def __repr__(self): \n        instance_str = f'Car(make={self.make}, model={self.model}, year={self.year}, '\n        instance_str += f'wheels={Car.wheels})'\n        return instance_str\n```\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# now would be called this way\nCar.which_is_newer(car1, car2)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\nCar(make=Pontiac, model=Grand Am, year=1997, wheels=4)\n```\n:::\n:::\n\n\nThere is nothing special about a `staticmethod`, it can always be replaced by a method outside of the class. It is a matter of preference.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": []
  }
}