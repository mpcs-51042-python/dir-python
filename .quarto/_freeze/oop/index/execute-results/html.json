{
  "hash": "ea202a2f1cf53c2c76835ff18e2c1645",
  "result": {
    "engine": "jupyter",
    "markdown": "# Object-Oriented Programming\n\n## Motivations\n\nWe often find ourselves working with many functions that use the same data structure(s).\n\nLet's look at a hypothetical program that only uses the types we've learned so far in Python:\n\n::: {#61124624 .cell tags='[]' execution_count=1}\n``` {.python .cell-code}\nperson_a = {\"name\": \"Andy\", \"costume\": \"Cowboy\", \"candy\": []}\nperson_b = {\"name\": \"Gil\", \"costume\": \"Robot\", \"candy\": []}\nperson_c = {\"name\": \"Lisa\", \"costume\": \"Ghost\", \"candy\": []}\n\ncandy_bag = [\"Kit Kat\", \"Kit Kat\", \"Lollipop\", \"M&Ms\"]\n\ndef costume_is_scary(person : dict) -> bool:\n    return person[\"costume\"] in (\"Ghost\", \"Wolfman\", \"Mummy\")\n\ndef do_trick(person):\n    print(f\"{person['name']} did a trick\")\n\ndef trick_or_treat(person):\n    success = give_candy(candy_bag, person)\n    # extra candy for scary costumes!\n    if costume_is_scary(person):\n        give_candy(candy_bag, person)\n    if not success:\n        do_trick(person)\n\ndef give_candy(candy_bag, person):\n    if candy_bag:\n        candy = random.choice(candy_bag)\n        candy_bag.remove(candy)\n        person[\"candy\"].append(candy)\n        return True\n    else:\n        return False\n```\n:::\n\n\nThis is, in effect, **object-oriented code**.\n\nAn \"object\" is a grouping of data with behavior.\n\nPurely *procedural programming* focused on using control flow & procedures (impure functions) to structure our application.\n\nWe saw that *functional programming* focused on composition of smaller functions to achieve larger goals.\n\n**Object-oriented** programming focuses on groupings of data and associated behaviors.\n\nA common misconception is that a language needs classes to be object-oriented.\nWhile classes are the most common feature provided in OO-focused languages, one can write code without them as we saw above.\n\n## Classes & Methods\n\nThe code above might be rewritten as:\n\n::: {#38bf6645 .cell tags='[]' execution_count=2}\n``` {.python .cell-code}\nclass Person:\n    def __init__(self, name, costume):\n        self.name = name\n        self.costume = costume\n        self.candy = []\n\n    def is_scary(self):\n        return self.costume in (\"Ghost\", \"Wolfman\", \"Mummy\")\n    \n    def do_trick(self):\n        self.tricks = True\n        print(f\"{self.name} did a trick\")\n        \n    def accept_candy(self, candy):\n        self.candy.append(candy)\n        \nclass NoCandy(Exception):\n    pass\n\nclass House:\n    def __init__(self, initial_candy):\n        self.candy = initial_candy\n    \n    def get_candy(self):\n        if not self.candy:\n            raise NoCandy(\"no more candy!\")\n        candy = random.choice(self.candy)\n        self.candy.remove(candy)\n        return candy\n```\n:::\n\n\nThis code provides blueprints for what data & actions a \"person\" has.\n\n- **Class** - A blueprint for an object, providing methods that will act on instances of the data.\n- **Method** - A function that is tied to a specific class.\n- **Attribute** - Data that is tied to a specific instance.\n- **Constructor** - A special method that creates & populates an instance of a class.\n\nWhen we use the object, we create **instances** of our class, and use those as we would any other type.\n\n::: {#47bde0a2 .cell execution_count=3}\n``` {.python .cell-code}\ndef trick_or_treat(person, house):\n    try:\n        candy = house.get_candy()\n        person.accept_candy(candy)\n        if person.is_scary():\n            person.accept_candy(house.get_candy())\n    except NoCandy:\n        do_trick(person, house)\n```\n:::\n\n\n::: {#cbb6466c .cell execution_count=4}\n``` {.python .cell-code}\np = Person(\"James\", \"Wolfman\")\np2 = Person(\"Fred\", \"Mummy\")\nl1 = list()\nl2 = list()\np.is_scary()\np.accept_candy(\"Chocolate\")\np.candy\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n['Chocolate']\n```\n:::\n:::\n\n\n## Everything in Python is an Object\n\nWe've been doing this all along! `list`, `dict`, and all the rest down to `int` and `None` are objects with their own data and methods.\n\n`isinstance` is the preferred way to check if an item is of a particular type.\n\nIt can return true for multiple types, we'll see why this is the case shortly.\n\n::: {#ee090ed3 .cell tags='[]' execution_count=5}\n``` {.python .cell-code}\nisinstance([1, 2, 3], list)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#67ed317a .cell execution_count=6}\n``` {.python .cell-code}\nisinstance([1, 2, 3], tuple)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#896f0436 .cell execution_count=7}\n``` {.python .cell-code}\nisinstance([1, 2, 3], object)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#a71bb218 .cell tags='[]' execution_count=8}\n``` {.python .cell-code}\ns = set([1,2,3])\n\n# using constructors here for demo purposes, generally would use a literal (e.g. [], 0, \"\") for these\nll = list()  \nll.append(str())\nll.append(int())\nll.append(float())\nll.append(s)\nll.append(print)\n\nprint(ll)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['', 0, 0.0, {1, 2, 3}, <built-in function print>]\n```\n:::\n:::\n\n\n::: {#d9982571 .cell tags='[]' execution_count=9}\n``` {.python .cell-code}\n[isinstance(item, object) for item in ll]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n[True, True, True, True, True]\n```\n:::\n:::\n\n\nKeeping this in mind can help keep things straight when we delve deeper into making our own objects.\n\nLet's revisit a few things that we already know:\n\n- each `list` is independent of all others, when you create a new via `list()` (or `[]`) that is an **instance**\n- calling things like `.append` operate on the instance they are called from. \n- Some methods modify the underlying object (`.append`) while others just provide a return value like any other function.  (What are some non-modifying methods?)\n\n## Classes in Python\n\n### Instances, Classes, and Instantiation\n\nWe often use the blueprint analogy for a class, a class tells us *how an object will act*, but on its own doesn't do anything until instantiated.\n\nThe blueprint can specify features that vary from car to car (color, transmission type, etc.) and behavior that is common among all cars.\n\nWe can create multiple car **instances** with different values for a given attribute.\n\n::: {#bc754c52 .cell execution_count=10}\n``` {.python .cell-code}\nclass Car:\n    # __init__ is a special method\n    # known as a double-underscore or dunder method\n    #  in Python it represents our constructor\n\n    def __init__(self, make, model, year=2000):\n        #print(type(self))\n        self.make = make\n        self.model = model\n        self.year = year\n        self.mileage = 0\n        self.hybrid = False\n        \n# to actually create Cars, we need to call this constructor\ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\nprint(car1.make, car1.model, car1.year)\nprint(car2.make, car2.model, car2.year)\ncar3 = car2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHonda Civic 2019\nChevy Volt 2022\n```\n:::\n:::\n\n\n::: {#af333aa8 .cell execution_count=11}\n``` {.python .cell-code}\ncar3 is car2\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#45d85cff .cell execution_count=12}\n``` {.python .cell-code}\ncar2.year += 1\n```\n:::\n\n\n::: {#65a676ec .cell execution_count=13}\n``` {.python .cell-code}\nprint(car3.year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023\n```\n:::\n:::\n\n\nThis is known as *instantiation*, making an instance of the class.\n\n### `self` & methods\n\nThe first parameter of methods is always `self`.  \n\nThis parameter is never passed directly, but is a local reference to the object the instance is being called upon.\n\n::: {#1aad22f8 .cell tags='[]' execution_count=14}\n``` {.python .cell-code}\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.mileage = 0\n        self.hybrid = False\n        self.driver = None\n        \n    def print_report(self):\n        print(f\"{self.year} {self.make} {self.model} with {self.mileage} miles\")\n        \n    def drive(self, miles):\n        self.mileage += miles\n        \ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\ncar2.mileage\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n0\n```\n:::\n:::\n\n\n::: {#3a73a23b .cell tags='[]' execution_count=15}\n``` {.python .cell-code}\ncar1.print_report()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2019 Honda Civic with 0 miles\n```\n:::\n:::\n\n\n::: {#578db907 .cell tags='[]' execution_count=16}\n``` {.python .cell-code}\ncar2.drive(500)\nprint(car2.mileage)\ncar2.print_report()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n500\n2022 Chevy Volt with 500 miles\n```\n:::\n:::\n\n\n::: {#ffb1f87d .cell tags='[]' execution_count=17}\n``` {.python .cell-code}\ncar1.print_report()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2019 Honda Civic with 0 miles\n```\n:::\n:::\n\n\n::: {#79767dcb .cell tags='[]' execution_count=18}\n``` {.python .cell-code}\nprint(car1.mileage)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n```\n:::\n:::\n\n\nBecause of `self`, methods can know which instance they are operating upon.\n\n#### How does this work?\n\nThis is confusing at first glance, where does `self` come from? \n\nIt is actually the \"parameter before the dot\".\n\n::: {#e67fadc3 .cell execution_count=19}\n``` {.python .cell-code}\n# explicitly call Car.print_report and pass self\nCar.print_report(car2)\n\n# this works, but is not how we call class methods!\n# instead write as car2.print_report()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022 Chevy Volt with 500 miles\n```\n:::\n:::\n\n\n::: {#04e946c4 .cell execution_count=20}\n``` {.python .cell-code}\n# this is true of all types\nll = []\nll.append(3)\nlist.append(ll, 4) # list is class, ll is self here\nll\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n[3, 4]\n```\n:::\n:::\n\n\n### What happens if `self` is omitted?\n\n::: {#bd7aa372 .cell execution_count=21}\n``` {.python .cell-code}\nclass Mistake:\n    def __init__(self):\n        print(\"constructor!\")\n    \n    def method_no_self():\n        print(\"method!\")\n\ntry:\n    m = Mistake()\n    m.method_no_self()\n    # rewritten as Mistake.method_no_self(m)\nexcept Exception as e:\n    print(repr(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nconstructor!\nTypeError('Mistake.method_no_self() takes 0 positional arguments but 1 was given')\n```\n:::\n:::\n\n\n### Attributes\n\nAttributes in Python are created on assignment, like other variables.\n\n`self.name = value`\n\nTypically they will be assigned in the *constructor*, but not explicitly required.\n\n**Why is it a good idea to always do this?**\n\n\nBy default, all attributes are accessible from inside the class and outside:\n\n  - `self.name` from inside.\n  - `instance_name.name` from outside.\n  \n**Best practice: create all attributes inside constructor!**\n\nWhy?\n\n::: {#c05f7e2a .cell tags='[]' execution_count=22}\n``` {.python .cell-code}\nmy_car = Car(\"DMC\", \"DeLorean\", 1982)\nmy_car.driver_name = \"Marty\" # allowed, but to be avoided\nmy_car.whatever_i_want = [1, 2, 3]\n```\n:::\n\n\n::: {#76c39790 .cell execution_count=23}\n``` {.python .cell-code}\nprint(my_car.driver)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\n### Exception to the rule: function objects\n\nFunctions are objects, and can have attributes assigned to them as well.\n\nWe sometimes do this since there's no opportunity to assign them before. (Because functions do not have constructors we can modify.)\n\n::: {#690596a8 .cell tags='[]' execution_count=24}\n``` {.python .cell-code}\ndef f():\n    print(f\"called f()\")\n    #f.call_count = 0 # NO\nf.call_count = 0\n```\n:::\n\n\n::: {#be7f7cbd .cell tags='[]' execution_count=25}\n``` {.python .cell-code}\nf.call_count += 1\nf()\nprint(f.call_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncalled f()\n1\n```\n:::\n:::\n\n\n::: {#498c571c .cell tags='[]' execution_count=26}\n``` {.python .cell-code}\n# using a decorator to add call_count to any function\ndef counter(func):\n    #inner.call_count\n    def inner(*args, **kwargs):\n        inner.call_count += 1\n        print(f\"call count {inner.call_count}\")\n        return func(*args, **kwargs)\n    inner.call_count = 0\n    return inner\n```\n:::\n\n\n::: {#a0ee6ca7 .cell tags='[]' execution_count=27}\n``` {.python .cell-code}\n@counter\ndef f():\n    print(\"called f()\")\n```\n:::\n\n\n::: {#8a3fbfac .cell tags='[]' execution_count=28}\n``` {.python .cell-code}\n@counter\ndef g():\n    print(f\"called g()\")\n```\n:::\n\n\n::: {#da718aea .cell tags='[]' execution_count=29}\n``` {.python .cell-code}\nf()\nf()\nf()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncall count 1\ncalled f()\ncall count 2\ncalled f()\ncall count 3\ncalled f()\n```\n:::\n:::\n\n\n::: {#82907553 .cell tags='[]' execution_count=30}\n``` {.python .cell-code}\ng()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncall count 1\ncalled g()\n```\n:::\n:::\n\n\n## Protocols, Duck-Typing, and Polymorphism\n\nIn some languages, functions can be created with one name but different argument lists.\n\n```c++\n// C++\nvoid foo(int x)\nvoid foo(double x)\nvoid foo(int x, double y)\n```\n\nThe compiler can decide which function to call at compile time based on the types given.\n\nThis is called polymorphism, **the specific implementation of an operation depends on the objects being operated on**.\n\nThe `+` operator exhibits polymorphism in Python:\n\n```python\n1 + 5  # addition\n\"1\" + \"5\" # string concatenation\n[1,2,3] + [4,5] # list concatenation\n```\n\nRemember, we mentioned that everything in Python is an `object` and `object`s have operations associated with them. \n\n\n```python\ndef times(x, y):\n     return x * y\n```\n\nAs long as our objects `x` and `y` support the `*` protocol, it is safe to call `times(x, y)`.\n\nIn Python, instead of forcing our arguments to be specific types, we use something known as **duck typing**.\n\n>   \"If it looks like a duck, and it quacks like a duck, it might as well be a duck.\"\n\nIf we had a function:\n\n```python\ndef do_something(a, b):\n    a.append(b[0])\n```\n\nWe can pass any type for `a` that has an `append`, and any type for `b` that has a way to call it with `[0]`.\n\n### Protocols & Dunder Methods\n\nAnother way of thinking about this is that objects of a given type follow a certain protocol.\n\n- iterable\n- callable\n- addable\n- comparable\n\nIn the above example, while we could add the `.append` method, if we want to make our own types that are *comparable*, *iterable*, etc. we need to use **dunder methods**.\n\n**dunder** or **double-underscore** methods are specially-named methods that are called when specific syntax is used.\n\nFor example, to be \"addable\" an object needs a `__add__` method, to be comparable it needs `__eq__` and `__lt__` or `__gt__` at least. (We'll see more of these later.)\n\nFor now, let's look at a few of these:\n\n* `__repr__`\n* `__str__`\n* `__eq__`\n\n::: {#6a84580e .cell execution_count=31}\n``` {.python .cell-code}\nclass Car: \n    def __init__(self, make, model, year):\n        self._make = make \n        self._model = model \n        self._year = year\n        self.__mileage = 0\n\n    def drive(self, miles):\n        if miles > 0:\n            self.__mileage += miles\n        else:\n            ...\n       \n    def __eq__(self, other):\n        # we can decide equality does/doesn't include mileage\n        return (self._make == other._make \n                and self._model == other._model \n                and self._year == other._year)\n    \n    def __repr__(self):\n        return f\"repr Car({self._make}, {self._model}, {self._year}, mileage={self.__mileage})\"\n\n    def __str__(self):\n        return f\"str {self._year} {self._make} {self._model} with {self.__mileage} miles\"\n\n    # common to only define __repr__, then add \n    # __str__ = __repr__\n```\n:::\n\n\n::: {#e9dfbf25 .cell execution_count=32}\n``` {.python .cell-code}\ntruck = Car(\"Ford\", \"F-150\", 1985)\ntruck2 = Car(\"Ford\", \"F-150\", 1985)\n```\n:::\n\n\n::: {#05cffb45 .cell execution_count=33}\n``` {.python .cell-code}\n# stating a variable name in the REPL will show the `repr`\ntruck\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\nrepr Car(Ford, F-150, 1985, mileage=0)\n```\n:::\n:::\n\n\n::: {#c5e40fe7 .cell execution_count=34}\n``` {.python .cell-code}\n# printing a variable will call the `str`\nprint(truck)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstr 1985 Ford F-150 with 0 miles\n```\n:::\n:::\n\n\n::: {#b781b87e .cell execution_count=35}\n``` {.python .cell-code}\n# we can also cast using `str()`\nvar = str(truck)\nvar\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n'str 1985 Ford F-150 with 0 miles'\n```\n:::\n:::\n\n\n::: {#39859e5c .cell execution_count=36}\n``` {.python .cell-code}\n# calls __eq__\ntruck == truck2 \n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#0efc16d8 .cell execution_count=37}\n``` {.python .cell-code}\n# truck == truck2, rewritten as \ntruck.__eq__(truck2)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\nTrue\n```\n:::\n:::\n\n\n### `str` vs `repr`\n\n`repr` is supposed to be a programmatic interpretation, used in debugging output. In jupyter/ipython if a function returns a value we see the repr by default.\n\n`str` is used when print is called, or an explicit conversion to string as shown above.\n\nIf only `__repr__` is defined, then `str(obj)` will use `__repr__`, so if you don't have a need for them to differ, then define `__repr__` and add `__str__ = __repr__`.\n\n\n## Discussion\n\n- What else is iterable?\n- What are other protocols we've seen?\n- Do all iterables eventually raise `StopIteration`?\n- What dunder methods are being called by:\n\n```python\nf(x[0] + y[\"test\"])\n```\n\n<!--\nf.__call__(x.__getitem__(0).__add__(y.__getitem__(\"test\")))\n-->\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}