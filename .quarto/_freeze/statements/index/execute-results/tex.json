{
  "hash": "e3519e46b50e3d03a4460cdd674df39b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Statements\n\nPython programs are made up of statements. **Expressions** are special types of statements that represent values.\n\nNow we'll look at statements related to **control flow**, deciding which lines of code will be executed next.\nWithout them our programs would just execute one line after the next with no exception.\n\n## Indentation\n\nPerhaps the most jarring change for C/Java/JavaScript programmers: Python does not use braces.\n\nInstead, indentation signifies code block boundaries.\n\n```python\nfrom __future__ import braces\nSyntaxError: not a chance\n```\n\n## `if, elif, else` Statements\n\n```python\nif condition:\n    statement1\n    statement2\nelif condition:    # else if\n    statement3\nelse:\n    statement4\n    statement5\n```\n\n- Note the colon after each condition.\n- `elif` and `else` are optional\n- parenthesis around the expression are optional\n- each line should be indented four spaces\n\nThis is a statement because you don't write\n\n```\nx = if ...:\n        ...\n    else:\n        ...\n    else:\n        ...\n```\n\nInstead, these lines of code are evaluated conditionally.\n\n::: {.cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[]' execution_count=1}\n``` {.python .cell-code}\n# if example\n\nx = 100\n\nif x < 0:\n    print(\"negative\")\n    print(\"second line\")\nelif x == 0:\n    print(\"zero\")\nelif x == 4:\n    print(\"four\")\nelse:\n    print(\"positive\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npositive\n```\n:::\n:::\n\n\n## `while` statement\n\n```python\nwhile condition:\n    statement1\n    statement2\n```\n\n::: {.cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[]' execution_count=2}\n``` {.python .cell-code}\ntime_left = 10\n\nwhile time_left != 0:\n    print(f\"{time_left}...\")\n    time_left -= 1\n\nprint(\"blast off!\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10...\n9...\n8...\n7...\n6...\n5...\n4...\n3...\n2...\n1...\nblast off!\n```\n:::\n:::\n\n\n## `for` statement\n\n```python\nfor var in iterable:\n    statement1\n    statement2\n```\n\nThis looks a bit different from C/Java.\n\nAlso, what is an iterable?\n\nFor now, just know that sequences are iterables, we'll cover iterables soon.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ncities = [\n    \"Tokyo\",\n    \"Delhi\",\n    \"Shanghai\",\n    \"S達o Paulo\",\n    \"Mexico City\",\n    \"Cairo\",\n    \"Mumbai\",\n    \"Beijing\",\n    \"Dhaka\",\n    \"Osaka\",\n]\n\nfor city in cities:\n    if city == \"Cairo\":\n        # we don't need to print Cairo out\n        break\n    print(city)\n\nseconds_left = 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTokyo\nDelhi\nShanghai\nS達o Paulo\nMexico City\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfor city in cities:\n    need_to_break = False\n    for letter in city:\n        if letter == \"y\":\n            need_to_break = True\n            break\n        print(letter)\n    if need_to_break:\n        break\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nT\no\nk\n```\n:::\n:::\n\n\n### `break & continue`\n\nYou may have seen `break` and `continue` in other languages.\n\nIf so, they work the same way in Python.\n\n`break` - exit a loop immediately\n\n`continue` - immediately begin next iteration of loop\n\n`else` statement after `for` or `while` - executes only if no break was called\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# break/else demo\n\ntime_left = 10\nabort_at = 4\n\nwhile time_left > 0:\n    print(f\"{time_left}...\")\n    time_left -= 1\n    if time_left == abort_at:\n        print(\"Launch Aborted\")\n        break\nelse:\n    # this only runs if we don't break\n    print(\"blast off!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10...\n9...\n8...\n7...\n6...\n5...\nLaunch Aborted\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ns = \"Hello class, my name is James\"\n\nfor ch in s:\n    if ch == \",\":\n        print(\"found a comma!\")\n        break\nelse:\n    print(\"no comma found!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfound a comma!\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# continue demo\n\nprint(cities)\nvisited = [\"Chicago\", \"Mexico City\", \"Shanghai\"]\n\nfor city in cities:\n    # this is not a great use, what would you do instead?\n    if city in visited:\n        continue\n    print(f\"I would like to visit {city}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Tokyo', 'Delhi', 'Shanghai', 'S達o Paulo', 'Mexico City', 'Cairo', 'Mumbai', 'Beijing', 'Dhaka', 'Osaka']\nI would like to visit Tokyo\nI would like to visit Delhi\nI would like to visit S達o Paulo\nI would like to visit Cairo\nI would like to visit Mumbai\nI would like to visit Beijing\nI would like to visit Dhaka\nI would like to visit Osaka\n```\n:::\n:::\n\n\n`continue` is not used as often as `break` in practice, but can be useful if you want to skip part of a loop.\n\nGiven the somewhat less straightforward nature of a `continue`, a comment explaining your intent is a good idea.\n\n#### idiom: double-break with an inner boolean\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nitems = [\"hello\", \"world\"]\nfound = False\n\n# we want to exit as soon as an e is found in *either* loop\nfor item in items:\n    for letter in item:\n        if letter == \"e\":\n            found = True\n            break\n        print(letter)\n    if found:\n        break\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh\n```\n:::\n:::\n\n\n#### idiom: \"infinite\" loops\n\n```python\nwhile True:\n    do_something()\n    if condition:\n        break\n```\n\nSimilar to a `do while` loop in C/C++, where condition is checked after one iteration.\n\n### range\n\nAnother iterable!\n\n`range(stop)` # goes from 0 to (stop-1)\n\n`range(start, stop)` # goes from start to (stop-1)\n\nSame rules as slice, always **inclusive** of start, **exclusive** of stop.\n\n*or as you'd write mathematically:* ```[start, stop)```\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfor x in range(5, 25):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Note: we'll see a better way to do what this loop does below.\ns = \"hello\"\nfor i in range(len(s)):\n    print(i, s[i])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 h\n1 e\n2 l\n3 l\n4 o\n```\n:::\n:::\n\n\n### `enumerate`\n\nAnother iterable, for when we need the index along with the object.\n\nGives us back two element tuples:\n\n`(index, element)`\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nfor i, letter in enumerate(s):\n    if letter == \"w\":\n        print(i)\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# same as above -- but less idiomatic & clear\nfor tup in enumerate(s):\n    if tup[1] == \"w\":\n        print(tup[0])\n```\n:::\n\n\n## Iteration\n\nA for loop can be described as iterating over an iterable:\n\n```\nfor var_name in iterable:\n    statement1\n    statement2\n    ...\n```\n\nAn **iterable** is any object that can be iterated over. All sequences are iterable, what else is?\n\n### range\n\nAnother iterable!\n\n`range(stop)` # goes from 0 to (stop-1)\n\n`range(start, stop)` # goes from start to (stop-1)\n\nSame rules as slice, always **inclusive** of start, **exclusive** of stop.\n\nor as you might write: ```[start, stop)``` -- we've seen this before with slicing\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nfor x in range(12):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfor x in range(8, 12):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8\n9\n10\n11\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nr = range(12)  # hmm?\nprint(type(r))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'range'>\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# a common pattern, but we'll see a better way with enumerate\ni = 0\nfor x in [\"A\", \"B\", \"C\"]:\n    print(i, x)\n    i += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 A\n1 B\n2 C\n```\n:::\n:::\n\n\n### `enumerate`\n\nAnother function that returns an iterable, for when we need the index along with the object.\n\n`enumerate(original_iterable)` yields two element tuples: `(index, element)` for every item in the original.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# \"incorrect\" example\n# find using range/len - as you might think to write it based on past experience\ndef find_r(s, letter_to_find):\n    for i in range(len(s)):\n        if s[i] == letter_to_find:\n            return i\n    return -1\n```\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nfind_r(\"Hello World\", \"W\")\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n6\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# find using enumerate - Pythonic, more efficient\ndef find_e(s, letter_to_find):\n    for i, letter in enumerate(s):  # tuple unpacking\n        if letter == letter_to_find:\n            return i\n    return -1\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nfind_e(\"Hello world\", \"w\")\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n6\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nfind_r(\"Hello world\", \"?\")\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n-1\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# note: a built-in exists and should be used in practice\ns = \"Hello world\"\ns.find(\"w\")\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n6\n```\n:::\n:::\n\n\n### iterable unpacking\n\nWhen you know exactly how many elements are in an iterable, you can use this syntax to \"unpack\" them into variables:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ntup = (1, 2, 3)\nll = [\"a\", \"b\", \"c\"]\n\nx, y, z = tup\nprint(x, y, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# idomatic swap using unpacking\nx = 7\ny = 8\nx, y = y, x\nprint(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8 7\n```\n:::\n:::\n\n\n## Functions\n\nA function is a set of statements that can be called more than once.\n\nBenefits of functions:\n\n- Encapsulation: package logic for use in multiple places\n- Allows programmer to avoid copy/paste to repeat same task, which helps maximize code reuse and minimize redundancy\n- Procedural decomposition: split our program into subtasks (i.e., functions) with separate roles.\n- Make life easier for debugging, testing, doing maintenance on code\n\n```python\ndef function_name(arg1: int, arg2: float, arg3: tuple) -> None:\n    \"\"\"\n    Description of function task \n\n    Parameters: \n        arg1: description of arg1 \n        arg2: description of arg2\n        arg3: description of arg2\n\n    Returns:\n         Description of what this function returns, if anything.\n    \"\"\"\n    statement1\n    statement2\n    statement3\n    return value  # optional\n```\n\n### return\n\n- `return` may appear anywhere in a function body, including multiple times.\n\n- The first `return` encountered exits the function immediately.\n\n- Every function in python returns a value, `None` if not stated/reached.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ndef is_even(num):\n    return num % 2 == 0\n\nprint(is_even(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# what happens if return is missing?\ndef bad_return(num):\n    if num > 10000: \n        return False\n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nprint(bad_return(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\n###  `pass` statement\n\nCan be used whenever you need to leave a block empty.  Usually temporarily.\n\n```python\nif x < 0:\n    pass # TODO: figure this out later\nelse:\n    return y / 2 - x\n\ndef implement_me():\n    pass\n```\n\n### Type Annotations\n\nType annotations are a newer Python feature.\nThey exist to provide hints as to what types a function takes.\n\nPython **does not enforce these**, think of them as documentation.\n\nYou will start seeing them in assignments and documentation, and we'll discuss them more later in the quarter.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# I've broken this function into multiple lines, which is allowed\n# due to the parentheses.\n\ndef find_value(\n    a_list: list[list[str]],  # this parameter is a list of integers\n    num: int,                 # this parameter is a single integer\n) -> (\n    int | None\n):  # this annotation \"-> int | None\" indicates return type can be int or None\n    pass\n\ndef find_value(a_list: list[str], num: int) -> int | None:  \n    pass\n```\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nx = find_value(3.0, \"hello\")\n```\n:::\n\n\n### docstrings\n\nFunction comments should be done in the form of a docstring, i.e., a multi-line string (delimited by triple quotes) after the function header.\n\nThis comment must contain information specific to what a function does. It should also include a description of the purpose and expected input arguments, the expected output values, and how error conditions are handled.\n\nExample:\n```python\ndef hypotenuse(a: float, b: float) -> float:\n    \"\"\"\n    This function solves Pythagorean theorem a^2 + b^2 = c^2\n    for the value of c.\n\n    Parameters:\n      a, b: the lengths of sides of a right triangle.\n\n    Returns:\n      The length of the hypotenuse.\n    \"\"\"\n\n    return math.sqrt(a**2 + b**2)\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": []
  }
}