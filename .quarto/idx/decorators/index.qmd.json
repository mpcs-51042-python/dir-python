{"title":"Decorators","markdown":{"yaml":{"title":"Decorators","jupyter":"python3"},"headingText":"Decorators","containsRefs":false,"markdown":"\n\n\nA common pattern in functional programs, are functions that are built to \"wrap\" other functions.\n\nThis pattern allows one to attach behavior before or after a function call, making it possible to:\n\n- log function calls\n- validate or modify arguments (before)\n- validate or modify return value (after)\n- check performance or other characteristics of the function (e.g. time elapsed)\n- replace the inner function wholesale, for any purpose\n\n```{python}\n# a simple example\ndef print_before_and_after(func):\n    def newfunc(*args, **kwargs):\n        print(\"BEFORE\", func)\n        func(*args, **kwargs)\n        print(\"AFTER\", func)\n    return newfunc\n```\n\nThis function `print_before_and_after` is called a decorator, it takes a function, and returns a new function.\n\nTypically this new function will call the original function, but that is not required!\n\n\n```{python}\ndef inner(a, b, c):\n    print(\"inner function\", a, b, c)\n```\n\n```{python}\nwrapped_inner = print_before_and_after(inner)\n\nwrapped_inner(1, 2, 3)\n```\n\n```{python}\n# often we want to replace the function altogether\ninner = print_before_and_after(inner)\ninner(1, 2, 3)\n```\n\n## Decorator Syntax\n\nWanting to replace a function with its decorated form is so common, we have a special syntax:\n\n```{python}\n@print_before_and_after\ndef add_nums(a, b, c):\n    print(f\"{a} + {b} + {c} =\", a + b + c)\n\nadd_nums(1, 2, 3)\n# same as add_nums = print_before_and_after(add_nums)\n```\n\nWe can apply multiple decorators, here we'll apply the same one twice:\n\n```{python}\n@print_before_and_after\n@print_before_and_after\ndef mult_nums(a, b, c):\n    print(f\"{a} * {b} * {c} =\", a * b * c)\n\nmult_nums(1, 2, 3)\n# same as mult_nums = print_before_and_after(print_before_and_after(add_nums))\n```\n\n### Creating a Cache\n\nWe saw that we can use enclosing scope to create a cache, now we can do that in a generic way that will work for any function:\n\n```{python}\ndef cache(func):\n    inner_cache = {}\n    \n    def newfunc(*args):\n        if args not in inner_cache:\n            inner_cache[args] = func(*args)\n        return inner_cache[args]\n    \n    return newfunc\n```\n\n```{python}\n@cache\ndef expensive_calculation(a, b, *, c=0):\n    print(f\"doing expensive calculation on {a} {b}...\")\n    return a ** b\n\n@cache\ndef cheap_calculation(a, b):\n    print(f\"doing cheap calculation on {a} {b}...\")\n    return a + b\n```\n\n```{python}\nexpensive_calculation(4, 10)\n```\n\n```{python}\nexpensive_calculation(4, 10)\n```\n\n```{python}\n# independent cache\ncheap_calculation(4, 10)\n```\n\n```{python}\nexpensive_calculation(5, 6)\n```\n\n```{python}\nexpensive_calculation(5, 6)\n```\n\n### Decorators with Arguments\n\nPython has a built in `functools.lru_cache` function, which gives us a cache of a defined size:\n\n```python\n@lru_cache(100)\ndef some_calc(a, b, c):\n    pass\n```\n\nTo write a decorator that takes additional arguments, you must write one more function.\n\nWe already had:\n\n- decorator function: takes function, returns function\n- inner function: takes *args, **kwargs typically, since outer function isn't known, returns same type as wrapped func\n\nNow we add one more outside that decorator function, a **factory function** that returns a decorator!\n\n```{python}\ndef repeat(n):  # factory: takes integer, returns decorator\n    def repeat_decorator(func):                  # decorator: takes function, returns function\n        def newfunc(*args, **kwargs):            # inner function: takes ?, returns ?\n            for i in range(n):\n                func(*args, **kwargs)\n        return newfunc\n    return repeat_decorator\n\n@repeat(10)\ndef print_backwards(s):\n    print(s[::-1])\n\nprint_backwards(\"backwards\")\n```\n\n```{python}\n# we can see the layers if we call one step at a time:\n# first, obtain the decorator from the factory\nrepeat_10 = repeat(10) \nprint(repeat_10)\n# apply the decorator to the wrapped function\nprint_backwards = repeat_10(print_backwards)\n```\n\n## Function Properties\n\nLet's look at `functools.partial` again:\n\n<https://docs.python.org/3/library/functools.html#functools.partial>\n\n```{python}\nimport functools\nprint_hello_names = functools.partial(print, \"Hello\", sep=\", \")\n```\n\n```{python}\nprint_hello_names(\"Scott\", \"Paul\", \"Lauren\")\n# \"hello\" already bound, as is sep, so this is the same as:\n# print(\"Hello\", \"Scott\", \"Paul\", \"Lauren\", sep=\", \")\n```\n\nPartial stores attributes on the function, **functions are mutable!**\n\n```{python}\n# bound args\nprint_hello_names.args\n```\n\n```{python}\n# bound keywords\nprint_hello_names.keywords\n```\n\n```{python}\n# original func\nprint_hello_names.func\n```\n\n```{python}\n# since functions are objects, we can attach arbitrary values to them\ndef wrapper(func):\n    def newfunc(*args, **kwargs):\n        return func(*args, **kwargs)\n    # we can do whatever we like after defining newfunc, but before returning it\n    newfunc.xyz = \"hello\"*2\n    return newfunc\n```\n\n```{python}\n# property is assigned to all wrapped functions\n@wrapper\ndef our_function():\n    print(\"inside our function\")\n\nour_function.xyz\n```\n\n### Writing our own `partial`\n\n```{python}\ndef our_partial(func, /, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = {**keywords, **fkeywords}\n        return func(*args, *fargs, **newkeywords)\n    # assign these properties from within the closure\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\n```\n\n```{python}\nprint_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\")\n```\n\n```{python}\n#print_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\", sep=\"?\")\n```\n\n```{python}\nprint_hello_names2.args\n```\n\n```{python}\nprint_hello_names2.keywords\n```\n\n```{python}\nprint_hello_names2.func\n```\n\n\n## More Decorator Examples\n\n### Not Calling the Wrapped Function\n\n```{python}\ndef disable(f):\n    def newfunc(*args, **kwargs):\n        print(\"would have called \", f.__name__)\n    return newfunc\n\n@disable\ndef expensive_func(a, b):\n    print(\"expensive!\")\n\nexpensive_func(1, 2)\n```\n\n\n### Modifying Arguments within newfunc\n\n```{python}\ndef reverse_args(func):\n    def newfunc(*args):\n        # within newfunc we are able to write whatever we'd like\n        # we could decide that we want to reverse the arguments\n        reversed_args = reversed(args)\n        return func(*reversed_args)\n    return newfunc\n\n\n@reverse_args\ndef print_args(*args):\n    for arg in args:\n        print(arg)\n```\n\n```{python}\nprint_args(1, 2, 3)\n```\n\n```{python}\n@reverse_args\ndef divide(a, b):\n    return a / b\n\ndivide(10, 2)\n```\n\n### Example: Authorization\n\n```{python}\n# perhaps we want a function that checks if a user can perform an action\ndef auth_required(func):\n    \n    # list of allowed users. in practice, we'd look this up in a database\n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, **kwargs):\n        # here, we're actually using an argument within newfunc\n        # by checking if it is in the kwargs dictionary\n        if kwargs.get(\"auth_user\") in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# these functions must also accept auth_user so that the above call to func(*args, **kwargs)\n# doesn't send an invalid parameter through\n@auth_required\ndef withdraw_funds(account, amount, auth_user):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account, auth_user):\n    print(\"deleted\", account)\n```\n\n```{python}\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n```\n\n```{python}\ndelete_account(\"kevin\", auth_user=\"jim\")\n```\n\n### Modifying Keyword Parameters\n\n```{python}\n# if we didn't want auth_user to be passed through, we'd make a small modification to newfunc\n\ndef auth_required(func):    \n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, auth_user, **kwargs):\n        # newfunc now requires auth_user, and passes through all *other* parameters\n        if auth_user in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# auth_user is no longer seen in the definition of these functions \n# but it can be passed in since the newfunc returned from auth_required accepts it\n@auth_required\ndef withdraw_funds(account, amount):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account):\n    print(\"deleted\", account)\n```\n\n```{python}\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n```\n\n```{python}\ndelete_account(\"kevin\", auth_user=\"jim\")\n```\n","srcMarkdownNoYaml":"\n\n## Decorators\n\nA common pattern in functional programs, are functions that are built to \"wrap\" other functions.\n\nThis pattern allows one to attach behavior before or after a function call, making it possible to:\n\n- log function calls\n- validate or modify arguments (before)\n- validate or modify return value (after)\n- check performance or other characteristics of the function (e.g. time elapsed)\n- replace the inner function wholesale, for any purpose\n\n```{python}\n# a simple example\ndef print_before_and_after(func):\n    def newfunc(*args, **kwargs):\n        print(\"BEFORE\", func)\n        func(*args, **kwargs)\n        print(\"AFTER\", func)\n    return newfunc\n```\n\nThis function `print_before_and_after` is called a decorator, it takes a function, and returns a new function.\n\nTypically this new function will call the original function, but that is not required!\n\n\n```{python}\ndef inner(a, b, c):\n    print(\"inner function\", a, b, c)\n```\n\n```{python}\nwrapped_inner = print_before_and_after(inner)\n\nwrapped_inner(1, 2, 3)\n```\n\n```{python}\n# often we want to replace the function altogether\ninner = print_before_and_after(inner)\ninner(1, 2, 3)\n```\n\n## Decorator Syntax\n\nWanting to replace a function with its decorated form is so common, we have a special syntax:\n\n```{python}\n@print_before_and_after\ndef add_nums(a, b, c):\n    print(f\"{a} + {b} + {c} =\", a + b + c)\n\nadd_nums(1, 2, 3)\n# same as add_nums = print_before_and_after(add_nums)\n```\n\nWe can apply multiple decorators, here we'll apply the same one twice:\n\n```{python}\n@print_before_and_after\n@print_before_and_after\ndef mult_nums(a, b, c):\n    print(f\"{a} * {b} * {c} =\", a * b * c)\n\nmult_nums(1, 2, 3)\n# same as mult_nums = print_before_and_after(print_before_and_after(add_nums))\n```\n\n### Creating a Cache\n\nWe saw that we can use enclosing scope to create a cache, now we can do that in a generic way that will work for any function:\n\n```{python}\ndef cache(func):\n    inner_cache = {}\n    \n    def newfunc(*args):\n        if args not in inner_cache:\n            inner_cache[args] = func(*args)\n        return inner_cache[args]\n    \n    return newfunc\n```\n\n```{python}\n@cache\ndef expensive_calculation(a, b, *, c=0):\n    print(f\"doing expensive calculation on {a} {b}...\")\n    return a ** b\n\n@cache\ndef cheap_calculation(a, b):\n    print(f\"doing cheap calculation on {a} {b}...\")\n    return a + b\n```\n\n```{python}\nexpensive_calculation(4, 10)\n```\n\n```{python}\nexpensive_calculation(4, 10)\n```\n\n```{python}\n# independent cache\ncheap_calculation(4, 10)\n```\n\n```{python}\nexpensive_calculation(5, 6)\n```\n\n```{python}\nexpensive_calculation(5, 6)\n```\n\n### Decorators with Arguments\n\nPython has a built in `functools.lru_cache` function, which gives us a cache of a defined size:\n\n```python\n@lru_cache(100)\ndef some_calc(a, b, c):\n    pass\n```\n\nTo write a decorator that takes additional arguments, you must write one more function.\n\nWe already had:\n\n- decorator function: takes function, returns function\n- inner function: takes *args, **kwargs typically, since outer function isn't known, returns same type as wrapped func\n\nNow we add one more outside that decorator function, a **factory function** that returns a decorator!\n\n```{python}\ndef repeat(n):  # factory: takes integer, returns decorator\n    def repeat_decorator(func):                  # decorator: takes function, returns function\n        def newfunc(*args, **kwargs):            # inner function: takes ?, returns ?\n            for i in range(n):\n                func(*args, **kwargs)\n        return newfunc\n    return repeat_decorator\n\n@repeat(10)\ndef print_backwards(s):\n    print(s[::-1])\n\nprint_backwards(\"backwards\")\n```\n\n```{python}\n# we can see the layers if we call one step at a time:\n# first, obtain the decorator from the factory\nrepeat_10 = repeat(10) \nprint(repeat_10)\n# apply the decorator to the wrapped function\nprint_backwards = repeat_10(print_backwards)\n```\n\n## Function Properties\n\nLet's look at `functools.partial` again:\n\n<https://docs.python.org/3/library/functools.html#functools.partial>\n\n```{python}\nimport functools\nprint_hello_names = functools.partial(print, \"Hello\", sep=\", \")\n```\n\n```{python}\nprint_hello_names(\"Scott\", \"Paul\", \"Lauren\")\n# \"hello\" already bound, as is sep, so this is the same as:\n# print(\"Hello\", \"Scott\", \"Paul\", \"Lauren\", sep=\", \")\n```\n\nPartial stores attributes on the function, **functions are mutable!**\n\n```{python}\n# bound args\nprint_hello_names.args\n```\n\n```{python}\n# bound keywords\nprint_hello_names.keywords\n```\n\n```{python}\n# original func\nprint_hello_names.func\n```\n\n```{python}\n# since functions are objects, we can attach arbitrary values to them\ndef wrapper(func):\n    def newfunc(*args, **kwargs):\n        return func(*args, **kwargs)\n    # we can do whatever we like after defining newfunc, but before returning it\n    newfunc.xyz = \"hello\"*2\n    return newfunc\n```\n\n```{python}\n# property is assigned to all wrapped functions\n@wrapper\ndef our_function():\n    print(\"inside our function\")\n\nour_function.xyz\n```\n\n### Writing our own `partial`\n\n```{python}\ndef our_partial(func, /, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = {**keywords, **fkeywords}\n        return func(*args, *fargs, **newkeywords)\n    # assign these properties from within the closure\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\n```\n\n```{python}\nprint_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\")\n```\n\n```{python}\n#print_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\", sep=\"?\")\n```\n\n```{python}\nprint_hello_names2.args\n```\n\n```{python}\nprint_hello_names2.keywords\n```\n\n```{python}\nprint_hello_names2.func\n```\n\n\n## More Decorator Examples\n\n### Not Calling the Wrapped Function\n\n```{python}\ndef disable(f):\n    def newfunc(*args, **kwargs):\n        print(\"would have called \", f.__name__)\n    return newfunc\n\n@disable\ndef expensive_func(a, b):\n    print(\"expensive!\")\n\nexpensive_func(1, 2)\n```\n\n\n### Modifying Arguments within newfunc\n\n```{python}\ndef reverse_args(func):\n    def newfunc(*args):\n        # within newfunc we are able to write whatever we'd like\n        # we could decide that we want to reverse the arguments\n        reversed_args = reversed(args)\n        return func(*reversed_args)\n    return newfunc\n\n\n@reverse_args\ndef print_args(*args):\n    for arg in args:\n        print(arg)\n```\n\n```{python}\nprint_args(1, 2, 3)\n```\n\n```{python}\n@reverse_args\ndef divide(a, b):\n    return a / b\n\ndivide(10, 2)\n```\n\n### Example: Authorization\n\n```{python}\n# perhaps we want a function that checks if a user can perform an action\ndef auth_required(func):\n    \n    # list of allowed users. in practice, we'd look this up in a database\n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, **kwargs):\n        # here, we're actually using an argument within newfunc\n        # by checking if it is in the kwargs dictionary\n        if kwargs.get(\"auth_user\") in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# these functions must also accept auth_user so that the above call to func(*args, **kwargs)\n# doesn't send an invalid parameter through\n@auth_required\ndef withdraw_funds(account, amount, auth_user):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account, auth_user):\n    print(\"deleted\", account)\n```\n\n```{python}\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n```\n\n```{python}\ndelete_account(\"kevin\", auth_user=\"jim\")\n```\n\n### Modifying Keyword Parameters\n\n```{python}\n# if we didn't want auth_user to be passed through, we'd make a small modification to newfunc\n\ndef auth_required(func):    \n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, auth_user, **kwargs):\n        # newfunc now requires auth_user, and passes through all *other* parameters\n        if auth_user in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# auth_user is no longer seen in the definition of these functions \n# but it can be passed in since the newfunc returned from auth_required accepts it\n@auth_required\ndef withdraw_funds(account, amount):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account):\n    print(\"deleted\", account)\n```\n\n```{python}\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n```\n\n```{python}\ndelete_account(\"kevin\", auth_user=\"jim\")\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["include-code-files"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","number-depth":1,"theme":"yeti","title":"Decorators","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}