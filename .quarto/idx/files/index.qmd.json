{"title":"Files & Paths","markdown":{"headingText":"Files & Paths","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\nAs you've likely already realized, variables only exist while a program is running.\n\nIf we want to persist data between runs of the program, we need to read & write files.\n\nThis is a good time to look at an important concept in programming, looking at the same thing through levels of abstraction.\n\n## File I/O\n\nYour hard drive is a piece of physical media: it stores electrical charges representing the 0s and 1s that make up our data.\nOver the years, this format has changed: magnetic tape, hard drive platters, optical drives, flash storage. Each of these stores the 0s and 1s differently,\n but when we are writing programs we rarely want to worry about the distinct medium.\n\nOne of the jobs of the operating system is to provide a layer of *abstraction* for accessing hardware, including the hard drive.\nThis takes the form of a **filesystem**, a way of mapping a hierarchy of names to physical locations on the hard drive.\n\nWhen we refer to `/home/user/code/proj/example.py` -- our operating system maps this to a location on the hard drive.\nIn order to write to, or read from that location, it provides an interface that has remained relatively unchanged since 1970.\n\nWhile the OS-level file API is typically a C API, most languages provide a low-level API that is very similar to the C API.\n\nIn Python, that is present in the form of the `open` function and related types.\n\n\nFirst, we create a \"file handle\", a special type that allows us to interact\nwith an opened file. The built-in `open()` method returns this kind of handle.\n\n```{python}\nfh = open(\"file.txt\")\n```\n\nOnce opened, you will use *methods* to read/modify the file:\n\n```{python}\n# read entire file as a string\ntext = fh.read()\nprint(text)\n```\n\n### File Modes\n\nThere is a second parameter to `open()`, which control what our intention is with the file.\n\n| mode | behavior |\n|-|-|\n| `\"r\"` | read-only, default behavior |\n| `\"w\"` | write mode, **will erase entire file upon opening** |\n| `\"a\"` | append mode, will place \"cursor\" at end of file |\n| `\"rb\"` | read-only binary mode |\n| `\"wb\"` | write binary mode |\n\nSee more: <https://docs.python.org/3/library/functions.html#open>\n\nNote that write mode erases the file upon opening, this may seem unintuitive but it is quite common to want to replace the entire contents of a file with an edited copy in memory.\nTake care if using this mode that that is what you want.\n\n### file methods\n\nAs we've seen, file objects have methods. The methods available depend on what mode was specified upon opening.\nAttempting to use a method that is invalid (e.g. `write` on a read-only file) will result in an error.\n\n| method | purpose |\n|-|-|\n| `read` | read entire file as a single `str` (or `bytes` depending on mode) |\n| `readline` | read a single line of text |\n| `write` | write string (or `bytes)` to file, can be called multiple times |\n| `seek` | move the \"cursor\" to a different position |\n| `tell` | return the current cursor position |\n| `close` | close a file, syncing the contents back to disk* |\n\nSee more: <https://docs.python.org/3/tutorial/inputoutput.html#tut-files>\n\nForgetting to call `close` on a file could potentially lead to lost data.\nUntil it is called, data is not guaranteed to be saved to disk, instead existing in a temporary buffer Python maintains for you.\n\nBecause of this, the recommended way to use `open()` has become:\n\n```python\n# read from a text file that already exists\nwith open(\"filename.txt\") as f:\n    text = f.read()\n\n# open a new file for writing (erases existing contents)\nwith open(\"newfile.txt\", \"w\") as f:\n    f.write(\"hello filesystem!\\n\")\n```\n\nThe `with` statement is something we will come back to later, it creats a temporary variable (`f` in the examples above)\nthat is only usable within the indented block. When the block is exited `close()` is automatically called.\n\nThis is particularly useful when you are concerned about an exception being raised within the block, exiting the block *in any way*, error or not, will still call `close()`.\n\n### In Practice: `json`, `csv`, etc.\n\nWhile it is possible to have multiple read/write statements within the block, writing data out one line at a time\nit is more common to use libraries that handle common file formats.\n\nThese built-in libraries take a file handle, then take care of properly formatting the output for you:\n\n```python\n# writing a CSV file\nwith open('some.csv', 'w') as f:\n    writer = csv.writer(f)\n    # data is an iterable of tuples\n    writer.writerows(data)\n```\n\n\n```python\n# reading a CSV file\nwith open('some.csv', 'r') as f:\n    reader = csv.reader(f)\n    # reader is an iterable that yields tuples\n    for row in reader:\n        print(row)\n```\n\n```python\n# writing to JSON\nwith open(\"newfile.json\", \"w\") as f:\n    # data is list or dict\n    json.dump(data, f)\n```\n\n```python\n# writing to JSON\nwith open(\"newfile.json\", \"w\") as f:\n    # reads dict or list from JSON file\n    data = json.load(f)\n```\n\n## Manipulating Paths\n\nIn practice, with most of the actual complexities of output abstracted away, many will find the hardest part of working with files understanding *paths*.\n\n`pathlib` is a relatively new addition to Python, which accounts for the fact that you'll still see examples using less effective methods, particularly those from the `os` and `os.path` modules.\n\n`pathlib` makes working with file paths much easier, and should be preferred to the `os` methods.\n\nThe primary thing the module contains is a type called `Path` [^1]\n\n[^1]: If you look at the documentation, you'll see a few related classes like `PurePath` and `PosixPath`.\nYou can ignore those differences for the most part and use `Path`.\n\nThe `Path` class represents a single file path, the path to the file I'm writing these words in for instance might be\n\n```python\nPath(\"/home/james/sites/map-python-data/pathlib/index.qmd\")`\n```\n\nWhile paths may resemble strings, and can be instantiated from them, the `Path` class offers additional behaviors that are specific to file paths.\n\n### `.parent`\n\n`Path` objects have a `.parent` property that is equivalent to going up a directory:\n\n```{python}\nfrom pathlib import Path\n\npath = Path(\"/home/user/projects/proj-1\")\nprint(path.parent)\nprint(path.parent.parent)\n```\n\n### Concatenation\n\n`Path` objects use `/` to concatenate parts of a path. (Instead of the `+` used by strings.)\n\nWe can use this to build paths out of components:\n\n```{python}\nBASE_DIR = Path(\"/home/james/sites/map-python-data\")\n\nfor name in [\"pathlib\", \"web-scraping\", \"debugging\"]:\n    # Path overrides the \"/\" operator to work as concatenation\n    # this works with strings and Paths\n    file_path = BASE_DIR / name / \"index.qmd\"\n    print(file_path)\n```\n\n::: {.callout-note}\nThis works on Windows as well as Unix-based systems.\nThe path separators will be converted by the library so you can use `/` and Windows will see `\\` where appropriate.\n:::\n\n## Getting the Right Path\n\nIf you've written a file that works with paths you may have run into issues where it doesn't always read the correct file.\n\nPerhaps you had code like:\n\n```python\nwith open(\"filename.txt\") as f:\n    f.read()\n```\n\nAnd found that sometimes it couldn't find the file in question.\nOr if writing files, perhaps sometimes it wrote the file to a different directory than the one you expected.\n\nThe reason for this is that if a file path does not start with the root `/` (or `C:/` on Windows) it is **relative**.\n\nThese paths will be interpreted as if they begin with the **current working directory**.\n\nThis is an opaque concept, and a perfect example of why we tell you to avoid global variables.\n\nEvery running program has a global variable representing the \"current working directory\", often the directory it was run from.\nWhen you are in your terminal you can see your terminal's current working directory by typing `pwd`.\nSimilarly Python has functions  to let you examine (`os.getcwd`) and change (`os.chdir`) the current working directory.\n\nAs you may recall, global variables can make it hard to reason about programs, since any function might modify them in unexpected ways.\n\n```python\n# global variables create hard-to-follow code\nsome_variable = 100\nf()\ng()\nh()\nprint(some_variable)\n```\n\n*What will print? That depends on what `f`, `g`, and `h` do to the global state!*\n\n**As we'll see, the key to robust file-handling that works equally well on your system as it does on your peers' is to generally avoid using this global state altogether.**\n\n### Absolute Paths\n\nOne solution to this problem is to use absolute paths, you may find that instead of `open(\"data/target.json\")` you can get your code to work when you use `open(\"/home/user/projects/proj-2/data/target.json\")`.\n\nBut this path is unique to your computer. On my machine I may need `\"/home/james/dev/proj2/data/target.json\"`.\n\nHow can we do this without constantly dueling edits in our Git repository?\n\n### `__file__`\n\nIf we're concerned about portability we want to have a way to say \"the directory next to this one\" or \"the directory that is a parent of this one\".\n\nOften we're trying to create a layout like this:\n\n```\nproj-dir/\n├── data\n│   └── target.json\n└── src\n    └── script.py\n```\n\n`script.py` would like to be able to write to `data/target.json` in a reliable way\nregardless of what the current working directory is.\n\nWe'd like to do this without knowing exactly where `proj-dir` is as well, since it may be in `/Users/james/projects` on one machine and `/home/stephen/my-homework` on another.\n\nTo do this, we can define our paths using the relationship between the two files.\n\nThe algorithm for doing this is:\n\n1. Have the Python file get the path *to itself*.\n2. Determine the relative path from the Python file in question to the data file.\n3. Use pathlib to combine these.\n\nPython has a special variable `__file__` that'll help with step 1, and the rest of the steps we can do with standard path operators:\n\n```python\n# assume we're in /home/james/projects/proj-dir/src/script.py\nfrom pathlib import Path\n\n# this creates a Path object that is the full path to script.py\n# and then uses .parent to go up one level, to\n# \"/home/james/projects/proj-dir/src/\"\nBASE_DIR = Path(__file__).parent\n\n# Combine that path with a relative path from 'src'\n# to the file in question.\n#  - up one directory, then into the data directory\ndata_path = BASE_DIR / \"../data/target.json\"\n```\n\nForming paths using `__file__` makes them consistent as long as the\n`.py` files do not move relative to the data.\n\n## Using `Path` objects\n\n`Path` objects can typically be passed in anywhere a filename is expected, so `open(\"filename.txt\", \"w\")` can become `open(path_obj, \"w\")`.\nYou can also write this as `path.open(\"w\")`. (See [pathlib.Path.open](https://docs.python.org/3/library/pathlib.html#pathlib.Path.open).)\n\n`Path` objects also have quite a few helper methods that can make your life easier:\n\n### `Path.exists`\n\nIf you want to check if a given file exists, you can construct a path to it and then call `.exists`:\n\n```\npath = BASE_DIR / \"data.csv\"\nif path.exists():\n    read_and_process(path)\nelse:\n    create_initial_data(path)\n```\n\n### `Path.mkdir`\n\nA common pattern is to want to create a directory if it doesn't exist:\n\n```\nlog_directory = BASE_DIR / \"logs\"\nlog_directory.mkdir(exist_ok=True, parents=True)\n```\n\nThis also demonstrates two useful parameters:\n\n- `exist_ok=True` makes it so that the function will not raise an error if the directory already exists.\n- `parents=True` will also create parent directories if needed.\n\n### Quick Reading/Writing\n\nIf you are reading/writing the entire file in one go, instead of using the `IO` object returned by `open`, you can call `read_text` and `write_text` directly on the `Path` as a shortcut.\n\n```{python}\np = Path(\"file.txt\")\np.write_text('Text file contents')\np.read_text()\n```\n\n---\n\n## Further Exploration\n\nSee the official [pathlib documentation](https://docs.python.org/3/library/pathlib.html) for more methods and examples.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["include-code-files"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","number-depth":1,"theme":"yeti"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}