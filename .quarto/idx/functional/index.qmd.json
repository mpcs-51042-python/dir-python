{"title":"Functional Programming","markdown":{"yaml":{"title":"Functional Programming","jupyter":"python3"},"headingText":"Procedural vs. Functional","containsRefs":false,"markdown":"\n\n\nThe style of programming we've been doing is called **imperative** or **procedural**.  Statements run in sequence and change a program's state.\n\nFrom the \"procedural\" point of view, a function (procedure) is a set of statements that can be called more than once, we use parameters to make our procedures more reusable.\n\nThis is the \"recipe\" model of programming, \na procedure is a recipe: a series of steps to follow to achieve a result.\n\nOur first paradigm, **procedural programming** leans heavily on the constructs we've seen: loops, conditionals, and the use of functions to break large procedures into smaller ones.\n\nSome languages make a distinction between procedures and functions. In Python we don't make this distinction, but we will soon see another style of programming where we'll think differently about how we use functions.\n\nBenefits of procedures (functions):\n\n- Encapsulation: package logic so \"user\" does not need to understand *implementation*, only *interface*.\n- Avoid copy/paste to repeat same task: maximize code reuse and minimize redundancy.\n- Procedural decomposition: split our program into subtasks (i.e., functions) with separate roles.\n    - Small functions are easier to test, easier to write, and easier to refactor.\n    - Makes life easier for debugging, testing, doing maintenance on code.\n\n## Functional Programming\n\nLanguages like LISP, Haskell, and Racket are purely functional & differ significantly from procedural & object-oriented languages.\n\nFunctional programming uses a definition of functions more compatible with the mathematical definition. Instead of the recipe model of procedural programming, mathematical functions take input(s) and return an output. \n\nThese functions do not have the concept of \"state\": the same call with the same parameters always results in the same result.\nthat is, calling a function in math creates a mapping from inputs to outputs.\n\nWhen we call `sin(x)` we do not speak of it modifying its inputs, just returning a value.\n\nSimilarly, when we workin a functional style we'll often write smaller functions that we chain together, instead of long procedures that rely on internal state.\n\nPython has many features that stem from pure functional languages & support functional programming:\n\n- Functions as first class objects\n- Lambda expressions\n- map/filter\n- `functools`\n- comprehensions\n\n## Functions as \"first-class objects\"\n\nA key feature of Python that makes it possible to write code in the functional style is the fact that functions are objects. (Everything in Python is an object.)\n\nThis means functions don't have special rules about how they can be used compared to other types, any variable can reference a function. (Remember, a variable is an association between a name & object.)\n\n\n```{python}\n#| tags: []\ndef echo(message):\n    print(message, message)\n    \nprint(f\"echo = {echo}\")\nprint(f\"type(echo) = {type(echo)}\")\n```\n\n```{python}\n# we can assign names to objects, including functions\nx = echo\nx(\"hello\")\n```\n\n```{python}\nid(x), id(echo)\n```\n\n```{python}\n# we can also store functions in other types, like list\nfunc_list = [print, echo, print, echo]\nfor i, func in enumerate(func_list):\n    func(i)\n```\n\n```{python}\n# dictionaries too\nfunc_mapping = {False: print, True: echo}\n\nprint_twice = True\nfunc_mapping[True](\"twice\")\n\nprint_twice = False\nfunc_mapping[print_twice](\"once\")\n```\n\n\n```{python}\n# we can pass functions into other functions\ndef add(a, b):\n    return a + b\n\ndef sub(a, b):\n    return a - b\n\ndef perform_op(op_func, a, b):\n    return op_func(a, b)\n\nprint(\"add, 3, 4 = \", perform_op(add, 3, 4))\nprint(\"sub, 3, 4 = \", perform_op(sub, 3, 4))\n```\n\n```{python}\n# and we can return functions from other functions\ndef get_op(name):\n    if name == \"div\":\n        def f(a, b):\n            return a / b\n    elif name == \"mod\":\n        def f(a, b):\n            return a % b\n    return f\n```\n\n```{python}\n#| tags: []\nfn = get_op(\"mod\")\nfn(100, 5)\n#perform_op(fn, 10, 3)\n```\n\n### `sorted` example\n\nIt isn't uncommon in Python for functions to take other functions, let's look at `sorted`\n\n```{python}\nhelp(sorted)\n```\n\n```{python}\n#| tags: []\nd = [(\"Nick\", 1), (\"Nick\", -100), (\"Yusong\", 9000), (\"Emma\", 100)]\n\ndef second_key(item):\n    return item[1]\n\ndef negate(item):\n    return -item[1]\n\n```\n\n```{python}\n# default sort\nsorted(d)    \n```\n\n```{python}\nsorted(d, key=negate)\n```\n\n```{python}\nsorted(d, key=second_key)\n```\n\n## lambda functions\n\nPython also provides another way to generate function objects.\n\nThese are called lambda functions (aka anonymous functions), which:\n\n- Are expressions that return a function object that can be called later without providing a name (hence ``anonymous\")\n- Can be used in places where def statement is not syntactically legal (inside a literal list, inlined as a function argument, etc.)\n\nThe body of an lambda function is a single expression, not a block of statements.  The body is similar to a return statement in a def statement.\n\n```python\n\nlambda arg1, arg2: expression\n\n# essentially the same as\n\ndef __(arg1, arg2):\n    return expression\n```\n\n(0 or more arguments, but *must* have an expression)\n\n### Reminder: expressions vs. statements\n\nRemember that expressions evaluate to a value, and can be assigned to a variable.\n\nExpresssions are valid in assignment, function calls, sequence values, etc.  (Anywhere a value is needed.)\n\nWhen it comes to `lambda`:\n* a `lambda` defines a function that maps input to a single expression, `def` can be used if statements are needed\n* a `lambda` is itself an expression, it can be used anywhere other expresssions are needed\n\nAs an expression, `lambda` can be used as a parameter:\n\n```{python}\nperform_op(lambda a, b: a * b, 5, 6)\n```\n\n```{python}\nwords = [\"abc\", \"Abb\", \"aaa\", \"ABC\", \"AAB\"]\nsorted(words)\n```\n\n```{python}\nsorted(words, key=lambda s: s.upper())\n```\n\n```{python}\n# can be assigned to a variable\nmul = lambda a, b: a * b\nmul(5, 6)\n\n# same as\ndef mul2(a, b):\n    return a * b\n```\n\n```{python}\n#| tags: []\ntype(mul), type(mul2)\n```\n\n**General rule: If you're giving a lambda a name, use a function.**\n\n\n## Functional Methods\n\nPython has several built in methods that are useful when writing programs with a functional mindset.\n\n`map`, `filter`, `functools`\n\n### map\n\n`map(function, iterable1, [...iterableN])`\n\nReturns a new iterable that calls `function` with parameters from `iterable1 ... iterableN`.\n\n```{python}\n#| tags: []\ndef add_two(x):\n    print(\"called add_two\", x)\n    return x + 2\n\nfor x in map(add_two, [1, 2, 3]):\n    print(x)\n```\n\n```{python}\n#| tags: []\nhelp(map)\n```\n\n```{python}\n#| tags: []\nx = list(map(add_two, [1, 2, 3]))\nprint(x)\n```\n\n```{python}\n#| tags: []\n# commonly used with lambdas\nfor x in map(lambda x, y: x+y, (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"]):\n    print(x)\n```\n\n```{python}\n# number of parameters must match number of iterables\nfor x in map(lambda x, y, z: x+(y*z), (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"], [2, 3, 4]):\n    print(x)\n```\n\n```{python}\n#| tags: []\n# operator module contains all of the common operators in function form\nimport operator\noperator.sub(20, 5)\n```\n\n`map` returns a special kind of *iterable*, can be wrapped in things other than list.\n\n```{python}\nset(map(operator.sub, [20, 19], [10, 9]))\n```\n\n```{python}\n# can use anywhere you can use an iterable\ntuple(map(lambda x: x * 3, (\"A\", \"B\", \"C\")))\n```\n\n### filter\n\n`filter(function, iterable)` \n\nreturns an iterable that contains all items from iterable for which `function(item)` returns True\n\nWe call this kind of function a *predicate*.\n\n```{python}\nlist(filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\", \"\"]))\n```\n\n```{python}\n#| tags: []\nlist(map(lambda s: s*2, filter(str.isupper, [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n```{python}\n#| tags: []\nlist(filter(str.isupper, map(lambda s: s.title(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n```{python}\n#| tags: []\nlist(map(lambda s: s.lower(), filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n### functools\n\n<https://docs.python.org/3/library/functools.html>\n\n```{python}\nimport functools\n[name for name in dir(functools) if name[0].islower()]\n```\n\n``functools.reduce(function, iterable[, initializer])``\n\nApply ``function`` to pairs of items successively and return a single value as the result. You can optionally specify the initial value.\n\n```{python}\nimport functools \nimport operator \n\n# accumulator = 0\n# for item in my_list:\n#     accumulator += item\n\n# 1st iteration: Call operator.add(1,2) -> 3 \n# 2nd iteration: Call operator.add(3,3) -> 6 \n# 3rd iteration: Call operator.add(6,4) -> 10 \n# final result = 10 \nfunctools.reduce(operator.add, [1,2,3,4])\n```\n\n```{python}\nnames = [\"Ben\", \"Martha\", \"Susan\"]\n# 1st iteration: call f(0, \"Ben\") -> 0 + len(\"Ben\") -> 3\n# 2nd iteration: call f(3, \"Martha\") -> 3 + len(\"Martha\") -> 9\n# 3rd iteration: call f(9, \"Susan\") -> 9 + len(\"Susan\") -> 14\nfunctools.reduce(lambda accumulator, new_val: accumulator + len(new_val), \n                 names, \n                 0)\n```\n\n```{python}\n# What happens if you pass in an initial value \n# 1st iteration: Call operator.mul(2,1) -> 2 \n# 2nd iteration: Call operator.mul(2,2) -> 4 \n# 3rd iteration: Call operator.mul(4,3) -> 12 \n# 4th iteration: Call operator.mul(12,4) -> 48 \n# Final result = 48 \nfunctools.reduce(operator.mul, [1,2,3,4], 2)\n```\n\n```{python}\n#| tags: []\nfunctools.reduce(lambda a,b: a+b, [1, 2, 3])\n```\n\n```functools.partial(func, *args, **kwargs)```\n\n`functools.partial` returns a new function that \"binds\" any passed args & kwargs, and leaves other parameters unbound.\n\n```{python}\nimport operator\noperator.mul(2, 10)\n```\n\n```{python}\nimport functools\nnegate = functools.partial(operator.mul, -1)\nnegate(5)\n```\n\n```{python}\nlist(map(negate, [1, 2, 3, 4]))\n```\n\n```{python}\ndef calls_twice(f):\n    print(f())\n    print(f())\n    \n\ng = functools.partial(operator.mul, 4, 4)\n#print(g())\ncalls_twice(g)\n\n```\n\n```{python}\nprint_ex = functools.partial(print, sep=\"!\")\nprint_ex(\"a\", \"b\", \"c\")\n```\n\n```python\n# ERROR: parameters must be valid\nprint_foo = functools.partial(print, foo=\"x\")\n```\n\n```{python}\n# another way to deal with functions we're calling with the same args repeatedly\ndef request_page(url, verify, cache=True, send_cookies=False, https_only=True):\n    pass\n\nsecure_request = functools.partial(request_page, verify=True, https_only=True)\n```\n\n```{python}\n#| tags: []\nsecure_request(\"\", verify=False)\n```\n\n","srcMarkdownNoYaml":"\n\n## Procedural vs. Functional\n\nThe style of programming we've been doing is called **imperative** or **procedural**.  Statements run in sequence and change a program's state.\n\nFrom the \"procedural\" point of view, a function (procedure) is a set of statements that can be called more than once, we use parameters to make our procedures more reusable.\n\nThis is the \"recipe\" model of programming, \na procedure is a recipe: a series of steps to follow to achieve a result.\n\nOur first paradigm, **procedural programming** leans heavily on the constructs we've seen: loops, conditionals, and the use of functions to break large procedures into smaller ones.\n\nSome languages make a distinction between procedures and functions. In Python we don't make this distinction, but we will soon see another style of programming where we'll think differently about how we use functions.\n\nBenefits of procedures (functions):\n\n- Encapsulation: package logic so \"user\" does not need to understand *implementation*, only *interface*.\n- Avoid copy/paste to repeat same task: maximize code reuse and minimize redundancy.\n- Procedural decomposition: split our program into subtasks (i.e., functions) with separate roles.\n    - Small functions are easier to test, easier to write, and easier to refactor.\n    - Makes life easier for debugging, testing, doing maintenance on code.\n\n## Functional Programming\n\nLanguages like LISP, Haskell, and Racket are purely functional & differ significantly from procedural & object-oriented languages.\n\nFunctional programming uses a definition of functions more compatible with the mathematical definition. Instead of the recipe model of procedural programming, mathematical functions take input(s) and return an output. \n\nThese functions do not have the concept of \"state\": the same call with the same parameters always results in the same result.\nthat is, calling a function in math creates a mapping from inputs to outputs.\n\nWhen we call `sin(x)` we do not speak of it modifying its inputs, just returning a value.\n\nSimilarly, when we workin a functional style we'll often write smaller functions that we chain together, instead of long procedures that rely on internal state.\n\nPython has many features that stem from pure functional languages & support functional programming:\n\n- Functions as first class objects\n- Lambda expressions\n- map/filter\n- `functools`\n- comprehensions\n\n## Functions as \"first-class objects\"\n\nA key feature of Python that makes it possible to write code in the functional style is the fact that functions are objects. (Everything in Python is an object.)\n\nThis means functions don't have special rules about how they can be used compared to other types, any variable can reference a function. (Remember, a variable is an association between a name & object.)\n\n\n```{python}\n#| tags: []\ndef echo(message):\n    print(message, message)\n    \nprint(f\"echo = {echo}\")\nprint(f\"type(echo) = {type(echo)}\")\n```\n\n```{python}\n# we can assign names to objects, including functions\nx = echo\nx(\"hello\")\n```\n\n```{python}\nid(x), id(echo)\n```\n\n```{python}\n# we can also store functions in other types, like list\nfunc_list = [print, echo, print, echo]\nfor i, func in enumerate(func_list):\n    func(i)\n```\n\n```{python}\n# dictionaries too\nfunc_mapping = {False: print, True: echo}\n\nprint_twice = True\nfunc_mapping[True](\"twice\")\n\nprint_twice = False\nfunc_mapping[print_twice](\"once\")\n```\n\n\n```{python}\n# we can pass functions into other functions\ndef add(a, b):\n    return a + b\n\ndef sub(a, b):\n    return a - b\n\ndef perform_op(op_func, a, b):\n    return op_func(a, b)\n\nprint(\"add, 3, 4 = \", perform_op(add, 3, 4))\nprint(\"sub, 3, 4 = \", perform_op(sub, 3, 4))\n```\n\n```{python}\n# and we can return functions from other functions\ndef get_op(name):\n    if name == \"div\":\n        def f(a, b):\n            return a / b\n    elif name == \"mod\":\n        def f(a, b):\n            return a % b\n    return f\n```\n\n```{python}\n#| tags: []\nfn = get_op(\"mod\")\nfn(100, 5)\n#perform_op(fn, 10, 3)\n```\n\n### `sorted` example\n\nIt isn't uncommon in Python for functions to take other functions, let's look at `sorted`\n\n```{python}\nhelp(sorted)\n```\n\n```{python}\n#| tags: []\nd = [(\"Nick\", 1), (\"Nick\", -100), (\"Yusong\", 9000), (\"Emma\", 100)]\n\ndef second_key(item):\n    return item[1]\n\ndef negate(item):\n    return -item[1]\n\n```\n\n```{python}\n# default sort\nsorted(d)    \n```\n\n```{python}\nsorted(d, key=negate)\n```\n\n```{python}\nsorted(d, key=second_key)\n```\n\n## lambda functions\n\nPython also provides another way to generate function objects.\n\nThese are called lambda functions (aka anonymous functions), which:\n\n- Are expressions that return a function object that can be called later without providing a name (hence ``anonymous\")\n- Can be used in places where def statement is not syntactically legal (inside a literal list, inlined as a function argument, etc.)\n\nThe body of an lambda function is a single expression, not a block of statements.  The body is similar to a return statement in a def statement.\n\n```python\n\nlambda arg1, arg2: expression\n\n# essentially the same as\n\ndef __(arg1, arg2):\n    return expression\n```\n\n(0 or more arguments, but *must* have an expression)\n\n### Reminder: expressions vs. statements\n\nRemember that expressions evaluate to a value, and can be assigned to a variable.\n\nExpresssions are valid in assignment, function calls, sequence values, etc.  (Anywhere a value is needed.)\n\nWhen it comes to `lambda`:\n* a `lambda` defines a function that maps input to a single expression, `def` can be used if statements are needed\n* a `lambda` is itself an expression, it can be used anywhere other expresssions are needed\n\nAs an expression, `lambda` can be used as a parameter:\n\n```{python}\nperform_op(lambda a, b: a * b, 5, 6)\n```\n\n```{python}\nwords = [\"abc\", \"Abb\", \"aaa\", \"ABC\", \"AAB\"]\nsorted(words)\n```\n\n```{python}\nsorted(words, key=lambda s: s.upper())\n```\n\n```{python}\n# can be assigned to a variable\nmul = lambda a, b: a * b\nmul(5, 6)\n\n# same as\ndef mul2(a, b):\n    return a * b\n```\n\n```{python}\n#| tags: []\ntype(mul), type(mul2)\n```\n\n**General rule: If you're giving a lambda a name, use a function.**\n\n\n## Functional Methods\n\nPython has several built in methods that are useful when writing programs with a functional mindset.\n\n`map`, `filter`, `functools`\n\n### map\n\n`map(function, iterable1, [...iterableN])`\n\nReturns a new iterable that calls `function` with parameters from `iterable1 ... iterableN`.\n\n```{python}\n#| tags: []\ndef add_two(x):\n    print(\"called add_two\", x)\n    return x + 2\n\nfor x in map(add_two, [1, 2, 3]):\n    print(x)\n```\n\n```{python}\n#| tags: []\nhelp(map)\n```\n\n```{python}\n#| tags: []\nx = list(map(add_two, [1, 2, 3]))\nprint(x)\n```\n\n```{python}\n#| tags: []\n# commonly used with lambdas\nfor x in map(lambda x, y: x+y, (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"]):\n    print(x)\n```\n\n```{python}\n# number of parameters must match number of iterables\nfor x in map(lambda x, y, z: x+(y*z), (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"], [2, 3, 4]):\n    print(x)\n```\n\n```{python}\n#| tags: []\n# operator module contains all of the common operators in function form\nimport operator\noperator.sub(20, 5)\n```\n\n`map` returns a special kind of *iterable*, can be wrapped in things other than list.\n\n```{python}\nset(map(operator.sub, [20, 19], [10, 9]))\n```\n\n```{python}\n# can use anywhere you can use an iterable\ntuple(map(lambda x: x * 3, (\"A\", \"B\", \"C\")))\n```\n\n### filter\n\n`filter(function, iterable)` \n\nreturns an iterable that contains all items from iterable for which `function(item)` returns True\n\nWe call this kind of function a *predicate*.\n\n```{python}\nlist(filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\", \"\"]))\n```\n\n```{python}\n#| tags: []\nlist(map(lambda s: s*2, filter(str.isupper, [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n```{python}\n#| tags: []\nlist(filter(str.isupper, map(lambda s: s.title(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n```{python}\n#| tags: []\nlist(map(lambda s: s.lower(), filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n```\n\n### functools\n\n<https://docs.python.org/3/library/functools.html>\n\n```{python}\nimport functools\n[name for name in dir(functools) if name[0].islower()]\n```\n\n``functools.reduce(function, iterable[, initializer])``\n\nApply ``function`` to pairs of items successively and return a single value as the result. You can optionally specify the initial value.\n\n```{python}\nimport functools \nimport operator \n\n# accumulator = 0\n# for item in my_list:\n#     accumulator += item\n\n# 1st iteration: Call operator.add(1,2) -> 3 \n# 2nd iteration: Call operator.add(3,3) -> 6 \n# 3rd iteration: Call operator.add(6,4) -> 10 \n# final result = 10 \nfunctools.reduce(operator.add, [1,2,3,4])\n```\n\n```{python}\nnames = [\"Ben\", \"Martha\", \"Susan\"]\n# 1st iteration: call f(0, \"Ben\") -> 0 + len(\"Ben\") -> 3\n# 2nd iteration: call f(3, \"Martha\") -> 3 + len(\"Martha\") -> 9\n# 3rd iteration: call f(9, \"Susan\") -> 9 + len(\"Susan\") -> 14\nfunctools.reduce(lambda accumulator, new_val: accumulator + len(new_val), \n                 names, \n                 0)\n```\n\n```{python}\n# What happens if you pass in an initial value \n# 1st iteration: Call operator.mul(2,1) -> 2 \n# 2nd iteration: Call operator.mul(2,2) -> 4 \n# 3rd iteration: Call operator.mul(4,3) -> 12 \n# 4th iteration: Call operator.mul(12,4) -> 48 \n# Final result = 48 \nfunctools.reduce(operator.mul, [1,2,3,4], 2)\n```\n\n```{python}\n#| tags: []\nfunctools.reduce(lambda a,b: a+b, [1, 2, 3])\n```\n\n```functools.partial(func, *args, **kwargs)```\n\n`functools.partial` returns a new function that \"binds\" any passed args & kwargs, and leaves other parameters unbound.\n\n```{python}\nimport operator\noperator.mul(2, 10)\n```\n\n```{python}\nimport functools\nnegate = functools.partial(operator.mul, -1)\nnegate(5)\n```\n\n```{python}\nlist(map(negate, [1, 2, 3, 4]))\n```\n\n```{python}\ndef calls_twice(f):\n    print(f())\n    print(f())\n    \n\ng = functools.partial(operator.mul, 4, 4)\n#print(g())\ncalls_twice(g)\n\n```\n\n```{python}\nprint_ex = functools.partial(print, sep=\"!\")\nprint_ex(\"a\", \"b\", \"c\")\n```\n\n```python\n# ERROR: parameters must be valid\nprint_foo = functools.partial(print, foo=\"x\")\n```\n\n```{python}\n# another way to deal with functions we're calling with the same args repeatedly\ndef request_page(url, verify, cache=True, send_cookies=False, https_only=True):\n    pass\n\nsecure_request = functools.partial(request_page, verify=True, https_only=True)\n```\n\n```{python}\n#| tags: []\nsecure_request(\"\", verify=False)\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["include-code-files"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","number-depth":1,"theme":"yeti","title":"Functional Programming","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}