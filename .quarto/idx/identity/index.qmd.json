{"title":"Identity & References","markdown":{"yaml":{"title":"Identity & References","jupyter":"python3"},"headingText":"Names & Mutability Revisited","containsRefs":false,"markdown":"\n\nNow that we've seen all of the built-in types we can take a second look\nat mutability and explore what Python is doing under the hood, so that we are less likely to be surprised by the behavior.\n\n\nRemember that when we do an assignment, we are associating a **name** with an **object**, a value in memory.\n\nIt is the object that has a **type**, not the name.\n\n```python\n# a name is bound to the result of the expression\nx = 1 + 1\n# the name is re-assigned, we aren't changing data\nx = x + 1\n# this is why we can re-assign to a different type\nx = \"hello\"\n```\n\n#### Immutable Types\n\n - `str`\n - `tuple`\n - `frozenset`\n - scalars: `int`, `float`, `complex`, `bool`, `None`\n\nFor immutable types, this is the only option, any changes require *reassignment*.\n\n#### Mutable Types\n\n- `list`\n- `dict`\n- `set`\n\nOn the other hand, mutable values can be changed **in place**.\n\n```python\nx = [1, 2, 3]\nx.append(4)  # no re-assignment needed!\nprint(x)\n```\n\n### Object\n\nAll types in Python share an internal representation as an **object** (`PyObject` in C).\n\n```python\nll = [1, 2, 3, 4]\nyy = ll           # increase ref count\n```\n\n**object**\n\n| Field | Example | Purpose |\n|-|-|-|\n| id | 393239323 | uniquely identify object within Python interpreter |\n| refcount | 2 | count how many names currently point to this object |\n| type | `list` | type of object |\n| data | 0x80000000 | memory address where the *actual* data is stored |\n| length | 4 | Only present on collection types, stores pre-computed length. |\n\nNotice that name is not stored on the **object**! Why not?\n\n## Shared references\n\nMultiple names can refer to the same object in memory, this is noticable when the objects in question are mutable.\n\n```{python}\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(f\"{y=}\")\n# spooky action at a distance\nprint(f\"{x=}\")\n```\n\nFor immutables, any change causes reassignment:\n\n```{python}\na = 3\nb = a\na *= 2         # reassignment!\nprint(f\"{a=} {b=}\")\n```\n\n## Garbage Collection\n\nPython is a garbage collected language.  \n\nWe don't free our own memory, Python does instead.\n\nBehind the scenes, Python stores a reference counter on each `object`.  How many names/objects reference the object.\n\nWhen reference count drops to zero, Python can reclaim the memory.\n\n## Identity\n\nThe built-in `id(...)` function returns the identity of an object, which is an integer value guaranteed to be unique and constant for lifetime of object\n\nIn the official (\"CPython\") Interpreter we are using in this class, it is the address of the memory location storing the object.\n\n```{python}\nx = \"Orange\" \nprint(id(x))  # Unique integer-value for the object pointed by x\n```\n\n```{python}\ny = \"Apple\" \nprint(id(y)) \n```\n\n```{python}\nfruit1 = (\"Apples\", 4)\nfruit2 = (\"Apples\", 4)\nfruit3 = fruit2\nprint(f\"Fruit1 id = {id(fruit1)} \\n Fruit2 id = {id(fruit2)}\")\nprint(f\"Fruit3 id= {id(fruit3)}\")\n```\n\n```{python}\nfruit1 is fruit2\n```\n\n#### Equality vs. Identity\n\nTwo different ways of testing if objects are the \"same\":\n\n- Equality operator (`==`): Returns true if two objects are equal (i.e., have the same value)\n- Identity operator (`is`): Returns true if two objects identities are the same.\n\n`a is b` means `id(a) == id(b)`\n\n```{python}\n#| slideshow: {slide_type: subslide}\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(\"a == b\", a == b)\n\nprint(id(a))\nprint(id(b))\nprint(\"a is b\", a is b)  # The id values are different\n```\n\n```{python}\nprint(id(None))\n```\n\n```{python}\ndef f():\n    pass\nid(f())\n```\n\n#### `is None`\n\nIf you ever need to check if a value is `None`, you'd use `is None` or `is not None`\n\n### list / string mutability revisited\n\n```{python}\n# list d\nd = [1, 2, 3]\nprint(id(d))\nd.append(4)\nprint(d)\nprint(id(d))\n```\n\n```{python}\n# str D\ns = \"Hello\"\nprint(id(s))\ns += \" World\"\nprint(s)\n\n# did s change?\nprint(id(s))\n```\n\n### Aside: Object Creation Quirk\n\n>  Each time you generate a new value in your script by running an expression, Python creates a new object (i.e., a chunk of memory) to represent that value.\n>    \n> -- Learning Python 2013\n\nNot quite! CPython does not guarantee this, and in fact sometimes caches & reuses immutable objects for efficiency.\n\n\n```{python}\na = 100000000\nb = 100000000\n\n# Two different objects, two different ids.\nprint(a is b)\n```\n\n```{python}\na = 100\nb = 100\n\n# However, for small integer objects, CPython caches them\n# this means that a and b point to the same object\nprint(a is b)\n```\n\n```{python}\n# CPython does the same for short strings\nstr1 = \"MPCS\"\nstr2 = \"MPCS\"\nprint(id(str1), id(str2))\nstr1 is str2\n```\n\nIn practice this is just a quirk of the CPython interpreter, since the objects are immutable it isn't important to know that they share memory in some cases.\n\n## copy & deepcopy\n\nIf `y = x` does not make a copy, how can we get one?\n\nWe've seen the `.copy()` method on a few of our types.  Which ones?\n\nWe can also use the `copy` module:\n\n```{python}\nx = [1, 2, 3]\ny = x.copy()\n\nprint(id(x))\nprint(id(y))\n\nx.append(4)\nprint(x, y)\n```\n\n```{python}\n#| slideshow: {slide_type: subslide}\n# shallow copy example (nested mutables are not copied)\n\nx = [[1, 2], [3, 4]]\ny = x.copy()  # or copy.copy(x)\n\nprint(\"x is y\", x is y)\nprint(\"x[0] is y[0]\", x[0] is y[0])\nprint(\"x[1] is y[1]\", x[1] is y[1])\n\n# print(x, y)\nx[0].append(5)\nprint(x, \"\\n\", y)\n```\n\n```{python}\n#| slideshow: {slide_type: fragment}\n# deep copy (nested mutables are copied)\nimport copy\n\n# copy.copy(obj) --> same as obj.copy()\nz = copy.deepcopy(x)\nprint(\"x[0] is z[0]\", x[0] is z[0])\n```\n\n","srcMarkdownNoYaml":"\n\nNow that we've seen all of the built-in types we can take a second look\nat mutability and explore what Python is doing under the hood, so that we are less likely to be surprised by the behavior.\n\n## Names & Mutability Revisited\n\nRemember that when we do an assignment, we are associating a **name** with an **object**, a value in memory.\n\nIt is the object that has a **type**, not the name.\n\n```python\n# a name is bound to the result of the expression\nx = 1 + 1\n# the name is re-assigned, we aren't changing data\nx = x + 1\n# this is why we can re-assign to a different type\nx = \"hello\"\n```\n\n#### Immutable Types\n\n - `str`\n - `tuple`\n - `frozenset`\n - scalars: `int`, `float`, `complex`, `bool`, `None`\n\nFor immutable types, this is the only option, any changes require *reassignment*.\n\n#### Mutable Types\n\n- `list`\n- `dict`\n- `set`\n\nOn the other hand, mutable values can be changed **in place**.\n\n```python\nx = [1, 2, 3]\nx.append(4)  # no re-assignment needed!\nprint(x)\n```\n\n### Object\n\nAll types in Python share an internal representation as an **object** (`PyObject` in C).\n\n```python\nll = [1, 2, 3, 4]\nyy = ll           # increase ref count\n```\n\n**object**\n\n| Field | Example | Purpose |\n|-|-|-|\n| id | 393239323 | uniquely identify object within Python interpreter |\n| refcount | 2 | count how many names currently point to this object |\n| type | `list` | type of object |\n| data | 0x80000000 | memory address where the *actual* data is stored |\n| length | 4 | Only present on collection types, stores pre-computed length. |\n\nNotice that name is not stored on the **object**! Why not?\n\n## Shared references\n\nMultiple names can refer to the same object in memory, this is noticable when the objects in question are mutable.\n\n```{python}\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(f\"{y=}\")\n# spooky action at a distance\nprint(f\"{x=}\")\n```\n\nFor immutables, any change causes reassignment:\n\n```{python}\na = 3\nb = a\na *= 2         # reassignment!\nprint(f\"{a=} {b=}\")\n```\n\n## Garbage Collection\n\nPython is a garbage collected language.  \n\nWe don't free our own memory, Python does instead.\n\nBehind the scenes, Python stores a reference counter on each `object`.  How many names/objects reference the object.\n\nWhen reference count drops to zero, Python can reclaim the memory.\n\n## Identity\n\nThe built-in `id(...)` function returns the identity of an object, which is an integer value guaranteed to be unique and constant for lifetime of object\n\nIn the official (\"CPython\") Interpreter we are using in this class, it is the address of the memory location storing the object.\n\n```{python}\nx = \"Orange\" \nprint(id(x))  # Unique integer-value for the object pointed by x\n```\n\n```{python}\ny = \"Apple\" \nprint(id(y)) \n```\n\n```{python}\nfruit1 = (\"Apples\", 4)\nfruit2 = (\"Apples\", 4)\nfruit3 = fruit2\nprint(f\"Fruit1 id = {id(fruit1)} \\n Fruit2 id = {id(fruit2)}\")\nprint(f\"Fruit3 id= {id(fruit3)}\")\n```\n\n```{python}\nfruit1 is fruit2\n```\n\n#### Equality vs. Identity\n\nTwo different ways of testing if objects are the \"same\":\n\n- Equality operator (`==`): Returns true if two objects are equal (i.e., have the same value)\n- Identity operator (`is`): Returns true if two objects identities are the same.\n\n`a is b` means `id(a) == id(b)`\n\n```{python}\n#| slideshow: {slide_type: subslide}\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(\"a == b\", a == b)\n\nprint(id(a))\nprint(id(b))\nprint(\"a is b\", a is b)  # The id values are different\n```\n\n```{python}\nprint(id(None))\n```\n\n```{python}\ndef f():\n    pass\nid(f())\n```\n\n#### `is None`\n\nIf you ever need to check if a value is `None`, you'd use `is None` or `is not None`\n\n### list / string mutability revisited\n\n```{python}\n# list d\nd = [1, 2, 3]\nprint(id(d))\nd.append(4)\nprint(d)\nprint(id(d))\n```\n\n```{python}\n# str D\ns = \"Hello\"\nprint(id(s))\ns += \" World\"\nprint(s)\n\n# did s change?\nprint(id(s))\n```\n\n### Aside: Object Creation Quirk\n\n>  Each time you generate a new value in your script by running an expression, Python creates a new object (i.e., a chunk of memory) to represent that value.\n>    \n> -- Learning Python 2013\n\nNot quite! CPython does not guarantee this, and in fact sometimes caches & reuses immutable objects for efficiency.\n\n\n```{python}\na = 100000000\nb = 100000000\n\n# Two different objects, two different ids.\nprint(a is b)\n```\n\n```{python}\na = 100\nb = 100\n\n# However, for small integer objects, CPython caches them\n# this means that a and b point to the same object\nprint(a is b)\n```\n\n```{python}\n# CPython does the same for short strings\nstr1 = \"MPCS\"\nstr2 = \"MPCS\"\nprint(id(str1), id(str2))\nstr1 is str2\n```\n\nIn practice this is just a quirk of the CPython interpreter, since the objects are immutable it isn't important to know that they share memory in some cases.\n\n## copy & deepcopy\n\nIf `y = x` does not make a copy, how can we get one?\n\nWe've seen the `.copy()` method on a few of our types.  Which ones?\n\nWe can also use the `copy` module:\n\n```{python}\nx = [1, 2, 3]\ny = x.copy()\n\nprint(id(x))\nprint(id(y))\n\nx.append(4)\nprint(x, y)\n```\n\n```{python}\n#| slideshow: {slide_type: subslide}\n# shallow copy example (nested mutables are not copied)\n\nx = [[1, 2], [3, 4]]\ny = x.copy()  # or copy.copy(x)\n\nprint(\"x is y\", x is y)\nprint(\"x[0] is y[0]\", x[0] is y[0])\nprint(\"x[1] is y[1]\", x[1] is y[1])\n\n# print(x, y)\nx[0].append(5)\nprint(x, \"\\n\", y)\n```\n\n```{python}\n#| slideshow: {slide_type: fragment}\n# deep copy (nested mutables are copied)\nimport copy\n\n# copy.copy(obj) --> same as obj.copy()\nz = copy.deepcopy(x)\nprint(\"x[0] is z[0]\", x[0] is z[0])\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["include-code-files"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","number-depth":1,"theme":"yeti","title":"Identity & References","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}