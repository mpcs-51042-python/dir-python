{"title":"Object-Oriented Programming","markdown":{"headingText":"Object-Oriented Programming","containsRefs":false,"markdown":"\n## Motivations\n\nWe often find ourselves working with many functions that use the same data structure(s).\n\nLet's look at a hypothetical program that only uses the types we've learned so far in Python:\n\n```{python}\n#| tags: []\nperson_a = {\"name\": \"Andy\", \"costume\": \"Cowboy\", \"candy\": []}\nperson_b = {\"name\": \"Gil\", \"costume\": \"Robot\", \"candy\": []}\nperson_c = {\"name\": \"Lisa\", \"costume\": \"Ghost\", \"candy\": []}\n\ncandy_bag = [\"Kit Kat\", \"Kit Kat\", \"Lollipop\", \"M&Ms\"]\n\ndef costume_is_scary(person : dict) -> bool:\n    return person[\"costume\"] in (\"Ghost\", \"Wolfman\", \"Mummy\")\n\ndef do_trick(person):\n    print(f\"{person['name']} did a trick\")\n\ndef trick_or_treat(person):\n    success = give_candy(candy_bag, person)\n    # extra candy for scary costumes!\n    if costume_is_scary(person):\n        give_candy(candy_bag, person)\n    if not success:\n        do_trick(person)\n\ndef give_candy(candy_bag, person):\n    if candy_bag:\n        candy = random.choice(candy_bag)\n        candy_bag.remove(candy)\n        person[\"candy\"].append(candy)\n        return True\n    else:\n        return False\n```\n\nThis is, in effect, **object-oriented code**.\n\nAn \"object\" is a grouping of data with behavior.\n\nPurely *procedural programming* focused on using control flow & procedures (impure functions) to structure our application.\n\nWe saw that *functional programming* focused on composition of smaller functions to achieve larger goals.\n\n**Object-oriented** programming focuses on groupings of data and associated behaviors.\n\nA common misconception is that a language needs classes to be object-oriented.\nWhile classes are the most common feature provided in OO-focused languages, one can write code without them as we saw above.\n\n## Classes & Methods\n\nThe code above might be rewritten as:\n\n```{python}\n#| tags: []\nclass Person:\n    def __init__(self, name, costume):\n        self.name = name\n        self.costume = costume\n        self.candy = []\n\n    def is_scary(self):\n        return self.costume in (\"Ghost\", \"Wolfman\", \"Mummy\")\n    \n    def do_trick(self):\n        self.tricks = True\n        print(f\"{self.name} did a trick\")\n        \n    def accept_candy(self, candy):\n        self.candy.append(candy)\n        \nclass NoCandy(Exception):\n    pass\n\nclass House:\n    def __init__(self, initial_candy):\n        self.candy = initial_candy\n    \n    def get_candy(self):\n        if not self.candy:\n            raise NoCandy(\"no more candy!\")\n        candy = random.choice(self.candy)\n        self.candy.remove(candy)\n        return candy\n```\n    \nThis code provides blueprints for what data & actions a \"person\" has.\n\n- **Class** - A blueprint for an object, providing methods that will act on instances of the data.\n- **Method** - A function that is tied to a specific class.\n- **Attribute** - Data that is tied to a specific instance.\n- **Constructor** - A special method that creates & populates an instance of a class.\n\nWhen we use the object, we create **instances** of our class, and use those as we would any other type.\n\n```{python}\ndef trick_or_treat(person, house):\n    try:\n        candy = house.get_candy()\n        person.accept_candy(candy)\n        if person.is_scary():\n            person.accept_candy(house.get_candy())\n    except NoCandy:\n        do_trick(person, house)\n```\n\n```{python}\np = Person(\"James\", \"Wolfman\")\np2 = Person(\"Fred\", \"Mummy\")\nl1 = list()\nl2 = list()\np.is_scary()\np.accept_candy(\"Chocolate\")\np.candy\n```\n\n## Everything in Python is an Object\n\nWe've been doing this all along! `list`, `dict`, and all the rest down to `int` and `None` are objects with their own data and methods.\n\n`isinstance` is the preferred way to check if an item is of a particular type.\n\nIt can return true for multiple types, we'll see why this is the case shortly.\n\n```{python}\n#| tags: []\nisinstance([1, 2, 3], list)\n```\n\n```{python}\nisinstance([1, 2, 3], tuple)\n```\n\n```{python}\nisinstance([1, 2, 3], object)\n```\n\n```{python}\n#| tags: []\ns = set([1,2,3])\n\n# using constructors here for demo purposes, generally would use a literal (e.g. [], 0, \"\") for these\nll = list()  \nll.append(str())\nll.append(int())\nll.append(float())\nll.append(s)\nll.append(print)\n\nprint(ll)\n```\n\n```{python}\n#| tags: []\n[isinstance(item, object) for item in ll]\n```\n\nKeeping this in mind can help keep things straight when we delve deeper into making our own objects.\n\nLet's revisit a few things that we already know:\n\n- each `list` is independent of all others, when you create a new via `list()` (or `[]`) that is an **instance**\n- calling things like `.append` operate on the instance they are called from. \n- Some methods modify the underlying object (`.append`) while others just provide a return value like any other function.  (What are some non-modifying methods?)\n\n## Classes in Python\n\n### Instances, Classes, and Instantiation\n\nWe often use the blueprint analogy for a class, a class tells us *how an object will act*, but on its own doesn't do anything until instantiated.\n\nThe blueprint can specify features that vary from car to car (color, transmission type, etc.) and behavior that is common among all cars.\n\nWe can create multiple car **instances** with different values for a given attribute.\n\n```{python}\nclass Car:\n    # __init__ is a special method\n    # known as a double-underscore or dunder method\n    #  in Python it represents our constructor\n\n    def __init__(self, make, model, year=2000):\n        #print(type(self))\n        self.make = make\n        self.model = model\n        self.year = year\n        self.mileage = 0\n        self.hybrid = False\n        \n# to actually create Cars, we need to call this constructor\ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\nprint(car1.make, car1.model, car1.year)\nprint(car2.make, car2.model, car2.year)\ncar3 = car2\n```\n\n```{python}\ncar3 is car2\n```\n\n```{python}\ncar2.year += 1\n```\n\n```{python}\nprint(car3.year)\n```\n\nThis is known as *instantiation*, making an instance of the class.\n\n### `self` & methods\n\nThe first parameter of methods is always `self`.  \n\nThis parameter is never passed directly, but is a local reference to the object the instance is being called upon.\n\n```{python}\n#| tags: []\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.mileage = 0\n        self.hybrid = False\n        self.driver = None\n        \n    def print_report(self):\n        print(f\"{self.year} {self.make} {self.model} with {self.mileage} miles\")\n        \n    def drive(self, miles):\n        self.mileage += miles\n        \ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\ncar2.mileage\n```\n\n```{python}\n#| tags: []\ncar1.print_report()\n```\n\n```{python}\n#| tags: []\ncar2.drive(500)\nprint(car2.mileage)\ncar2.print_report()\n```\n\n```{python}\n#| tags: []\ncar1.print_report()\n```\n\n```{python}\n#| tags: []\nprint(car1.mileage)\n```\n\nBecause of `self`, methods can know which instance they are operating upon.\n\n#### How does this work?\n\nThis is confusing at first glance, where does `self` come from? \n\nIt is actually the \"parameter before the dot\".\n\n```{python}\n# explicitly call Car.print_report and pass self\nCar.print_report(car2)\n\n# this works, but is not how we call class methods!\n# instead write as car2.print_report()\n```\n\n```{python}\n# this is true of all types\nll = []\nll.append(3)\nlist.append(ll, 4) # list is class, ll is self here\nll\n```\n\n### What happens if `self` is omitted?\n\n```{python}\n\nclass Mistake:\n    def __init__(self):\n        print(\"constructor!\")\n    \n    def method_no_self():\n        print(\"method!\")\n\ntry:\n    m = Mistake()\n    m.method_no_self()\n    # rewritten as Mistake.method_no_self(m)\nexcept Exception as e:\n    print(repr(e))\n```\n\n### Attributes\n\nAttributes in Python are created on assignment, like other variables.\n\n`self.name = value`\n\nTypically they will be assigned in the *constructor*, but not explicitly required.\n\n**Why is it a good idea to always do this?**\n\n\nBy default, all attributes are accessible from inside the class and outside:\n\n  - `self.name` from inside.\n  - `instance_name.name` from outside.\n  \n**Best practice: create all attributes inside constructor!**\n\nWhy?\n\n```{python}\n#| tags: []\nmy_car = Car(\"DMC\", \"DeLorean\", 1982)\nmy_car.driver_name = \"Marty\" # allowed, but to be avoided\nmy_car.whatever_i_want = [1, 2, 3]\n```\n\n```{python}\nprint(my_car.driver)\n```\n\n### Exception to the rule: function objects\n\nFunctions are objects, and can have attributes assigned to them as well.\n\nWe sometimes do this since there's no opportunity to assign them before. (Because functions do not have constructors we can modify.)\n\n```{python}\n#| tags: []\ndef f():\n    print(f\"called f()\")\n    #f.call_count = 0 # NO\nf.call_count = 0\n```\n\n```{python}\n#| tags: []\nf.call_count += 1\nf()\nprint(f.call_count)\n```\n\n```{python}\n#| tags: []\n# using a decorator to add call_count to any function\ndef counter(func):\n    #inner.call_count\n    def inner(*args, **kwargs):\n        inner.call_count += 1\n        print(f\"call count {inner.call_count}\")\n        return func(*args, **kwargs)\n    inner.call_count = 0\n    return inner\n```\n\n```{python}\n#| tags: []\n@counter\ndef f():\n    print(\"called f()\")\n```\n\n```{python}\n#| tags: []\n@counter\ndef g():\n    print(f\"called g()\")\n```\n\n```{python}\n#| tags: []\nf()\nf()\nf()\n```\n\n```{python}\n#| tags: []\ng()\n```\n\n## Protocols, Duck-Typing, and Polymorphism\n\nIn some languages, functions can be created with one name but different argument lists.\n\n```c++\n// C++\nvoid foo(int x)\nvoid foo(double x)\nvoid foo(int x, double y)\n```\n\nThe compiler can decide which function to call at compile time based on the types given.\n\nThis is called polymorphism, **the specific implementation of an operation depends on the objects being operated on**.\n\nThe `+` operator exhibits polymorphism in Python:\n\n```python\n1 + 5  # addition\n\"1\" + \"5\" # string concatenation\n[1,2,3] + [4,5] # list concatenation\n```\n\nRemember, we mentioned that everything in Python is an `object` and `object`s have operations associated with them. \n\n\n```python\ndef times(x, y):\n     return x * y\n```\n\nAs long as our objects `x` and `y` support the `*` protocol, it is safe to call `times(x, y)`.\n\nIn Python, instead of forcing our arguments to be specific types, we use something known as **duck typing**.\n\n>   \"If it looks like a duck, and it quacks like a duck, it might as well be a duck.\"\n\nIf we had a function:\n\n```python\ndef do_something(a, b):\n    a.append(b[0])\n```\n\nWe can pass any type for `a` that has an `append`, and any type for `b` that has a way to call it with `[0]`.\n\n### Protocols & Dunder Methods\n\nAnother way of thinking about this is that objects of a given type follow a certain protocol.\n\n- iterable\n- callable\n- addable\n- comparable\n\nIn the above example, while we could add the `.append` method, if we want to make our own types that are *comparable*, *iterable*, etc. we need to use **dunder methods**.\n\n**dunder** or **double-underscore** methods are specially-named methods that are called when specific syntax is used.\n\nFor example, to be \"addable\" an object needs a `__add__` method, to be comparable it needs `__eq__` and `__lt__` or `__gt__` at least. (We'll see more of these later.)\n\nFor now, let's look at a few of these:\n\n* `__repr__`\n* `__str__`\n* `__eq__`\n\n```{python}\nclass Car: \n    def __init__(self, make, model, year):\n        self._make = make \n        self._model = model \n        self._year = year\n        self.__mileage = 0\n\n    def drive(self, miles):\n        if miles > 0:\n            self.__mileage += miles\n        else:\n            ...\n       \n    def __eq__(self, other):\n        # we can decide equality does/doesn't include mileage\n        return (self._make == other._make \n                and self._model == other._model \n                and self._year == other._year)\n    \n    def __repr__(self):\n        return f\"repr Car({self._make}, {self._model}, {self._year}, mileage={self.__mileage})\"\n\n    def __str__(self):\n        return f\"str {self._year} {self._make} {self._model} with {self.__mileage} miles\"\n\n    # common to only define __repr__, then add \n    # __str__ = __repr__\n```\n\n```{python}\ntruck = Car(\"Ford\", \"F-150\", 1985)\ntruck2 = Car(\"Ford\", \"F-150\", 1985)\n```\n\n```{python}\n# stating a variable name in the REPL will show the `repr`\ntruck\n```\n\n```{python}\n# printing a variable will call the `str`\nprint(truck)\n```\n\n```{python}\n# we can also cast using `str()`\nvar = str(truck)\nvar\n```\n\n```{python}\n# calls __eq__\ntruck == truck2 \n```\n\n```{python}\n# truck == truck2, rewritten as \ntruck.__eq__(truck2)\n```\n\n### `str` vs `repr`\n\n`repr` is supposed to be a programmatic interpretation, used in debugging output. In jupyter/ipython if a function returns a value we see the repr by default.\n\n`str` is used when print is called, or an explicit conversion to string as shown above.\n\nIf only `__repr__` is defined, then `str(obj)` will use `__repr__`, so if you don't have a need for them to differ, then define `__repr__` and add `__str__ = __repr__`.\n\n\n## Discussion\n\n- What else is iterable?\n- What are other protocols we've seen?\n- Do all iterables eventually raise `StopIteration`?\n- What dunder methods are being called by:\n\n```python\nf(x[0] + y[\"test\"])\n```\n\n<!--\nf.__call__(x.__getitem__(0).__add__(y.__getitem__(\"test\")))\n-->\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["include-code-files"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","number-depth":1,"theme":"yeti"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}