[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dir(python)",
    "section": "",
    "text": "Introduction\nThis site contains course notes for MPCS 50142: Python Programming.\nThis course assumes that you have basic familiarity with Python and programming, but are interested in having a much better understanding of both.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#sec-intro",
    "href": "index.html#sec-intro",
    "title": "dir(python)",
    "section": "",
    "text": "Goals\n\nBuild general-purpose programming skills: decomposing problems into parts, making thoughtful data structures and algorithm choices, and understanding what your code is doing and how to debug it.\nUsing Python’s strengths as a multi-paradigm language, explore differences between procedural, functional, and object-oriented programming.\nIntroduce the powerful ecosystem of Python libraries, and encourage continued growth as a Python programmer beyond this course.\n\n\n\nCourse Resources\n\nCourse Website\nUChicago CS Student Resource Guide\n\n\n\nAbout\nThese notes were originally written by James Turk for MPCS 51042 at the University of Chicago.\nEdited by Tyler J. Skluzacek\nThey are not meant to be a complete resource on Python, but to guide my lectures.\nIf you find them useful, or notice any issues, let me know.\n\n\n\n\n\n\nNoteLicensing\n\n\n\n\n dir(python)  by  James Turk  is licensed  Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International \n\nThis adaptation by Tyler J. Skluzacek is also licensed under CC BY-NC-SA 4.0.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "what-is-python/index.html",
    "href": "what-is-python/index.html",
    "title": "1  What is Python?",
    "section": "",
    "text": "Where did Python come from?\nBefore we begin, it is important to get some context about what we’re about to learn. We’ll begin by answering some questions that you may not have ever considered, even if you’ve written Python before.\nPython is just over 30 years old, and came from humble beginnings as an educational language.\nAs of 2025 Python is by many measures, the most popular programming language in the world.\nSome popular measures:\nAs you can see, the language has grown in an unrivaled manner. First a big surge in 2004, and then exponential growth since the mid-2010s.\nPython 1.0 was released in 1994. Guido von Rossum was working on the Computer Programming 4 Everyone (CP4E) initiative at Corporation for National Research Initiatives in Reston, VA. The language remained fairly obscure for about a decade.\nPython 2.0 was released in the year 2000, moving the language closer to what it is today. It was Python 2.4, around 2004 when the language really started to find its first major niche as a language for general-purpose scripting and web programming.\nPython 3.0, released in 2008, was a major backwards-incompatible change. It improved many long-standing issues with the language, but developers had to update their existing code from Python 2 to Python 3. There were plenty of articles at the time about this “blunder” and how Python would likely fail as a result. For those of us writing Python back then, the transition was a rocky one, but such a transition today would be unthinkable given the remarkable growth of the past decade.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Python?</span>"
    ]
  },
  {
    "objectID": "what-is-python/index.html#why-python",
    "href": "what-is-python/index.html#why-python",
    "title": "1  What is Python?",
    "section": "Why Python?",
    "text": "Why Python?\nHow did Python grow from an obscure teaching language to one of the number one languages in the world?\nPython’s early adopters (like yours truly) largely favored Python for its:\n\nrelatively simple & readable syntax, and culture of writing clean, maintainable code\npowerful “standard library”, code that comes pre-installed with the language to perform a wide variety of tasks\npragmatic, multi-paradigm approach to programming (object-oriented vs functional; interactive vs script)\nextensibility due to a powerful internal data model and C API\n\nPython’s growth in the last few years can be attributed to many factors:\n\nits role in data science and machine learning pipelines, which have become ubiquitous in the past decade.\na network effect, more Python developers means it is easier to hire Python developers, and so there are more Python jobs, so in turn, more Python developers.\nrelatedly, the number of open source Python libraries has skyrocketed. As we’ll see in this course it is now possible to find Python libraries for just about anything from audio to games, data science to web programming, or any obscure interest or hobby you may have.\nas a result of the huge number of users, lots of attention has been put into improving the development experience and performance of Python.\n\nLearning Python today is a good career choice, but it also provides a great foundation to explore different programming paradigms & specializations.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Python?</span>"
    ]
  },
  {
    "objectID": "what-is-python/index.html#what-kind-of-language-is-python",
    "href": "what-is-python/index.html#what-kind-of-language-is-python",
    "title": "1  What is Python?",
    "section": "What kind of language is Python?",
    "text": "What kind of language is Python?\nIn a typical Python introduction you’ll see it described as an interpreted & dynamically typed language.\nYou’ll also sometimes hear languages defined in terms of being object-oriented, functional, or procedural. While languages like C, C++, and Java all have strong foundations in a single paradigm, Python is somewhat agnostic on this front. This course will take advantage of that fact to introduce you to these three styles (paradigms) of programming.\nPython is also written with a focus on readability. You’ll see people talk about code being Pythonic. These ideas shape the culture of Python.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Python?</span>"
    ]
  },
  {
    "objectID": "what-is-python/index.html#is-python-complete",
    "href": "what-is-python/index.html#is-python-complete",
    "title": "1  What is Python?",
    "section": "Is Python complete?",
    "text": "Is Python complete?\nAfter seeing the history above, you may wonder, is Python “complete”?\nPython has reached a level of maturity and stability where breaking changes to the core language are rare. Still, every October a new version of Python is released (for example, 3.13, 3.14, and so on). As a mature language, each Python release is supported for about five years.\nThis does not mean that code you write today will stop working in five years, but that you’d need to update the version you use for security updates. Python you wrote targeting Python 3.10 will probably work just fine on 3.14 without changes, as the language is backwards-compatible.\nNew versions focus on performance, developer experience (e.g. nicer error messages and REPLs), and occasionally will add new features. They may also deprecate or prune old lesser-used libraries from the standard library.\nWhile we’ll use 3.13 in this class, most of the features we are learning were present as of 3.9 if not far longer.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Python?</span>"
    ]
  },
  {
    "objectID": "what-is-python/index.html#is-python-slow",
    "href": "what-is-python/index.html#is-python-slow",
    "title": "1  What is Python?",
    "section": "Is Python slow?",
    "text": "Is Python slow?\nYou may come across articles claiming Python is slow, or not suited to production.\nThis was a common refrain circa 2010. Today however, enormous web properties like YouTube and Instagram are powered by Python. The open source community, as well as companies like Microsoft and Google have poured resources into improving Python’s performance.\nNew releases add features, recent version of Python have introduced type-checking, improved concurrency, and major performance enhancements.\nIf you are curious, take a look at https://docs.python.org/3.14/whatsnew/3.14.html to see what was added in Python 3.14.\n\nAn Open Source, Community Language\nPython is an open source language and is developed in a public Git repository with public forums and email lists. Anyone can learn to contribute to Python, as long as they follow the community’s procedures and guidelines.\nMost programming languages have cultures with values that guide the development of the language.\nSome of the key values of Python’s culture:\n\nPython’s community started as beginner-friendly and kept that tone. The community takes being welcoming and inclusive seriously.\nThe community embraces openness, proposals to improve the language come from all over, and there’s a focus on encouraging users to contribute back to the project.\nPython is a language that values readability, code is written for people as much as it is for computers to understand, Python takes this extremely seriously.\n\nimport this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>What is Python?</span>"
    ]
  },
  {
    "objectID": "running-python/index.html",
    "href": "running-python/index.html",
    "title": "2  Running Python",
    "section": "",
    "text": "Installing uv\nOne of the defining characteristics of Python is that it is an interpreted language. If you’ve used a language like Java or C you’re used to having to compile your code. Python is instead typically translated to an intermediate representation (bytecode) and immediately executed without a separate compilation step.\nTo do this, we need a Python interpreter, a program called python (sometimes python3).\nThere are a lot of ways to install Python, but for this class we’ll use a tool called uv to manage Python and various dependencies.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Running Python</span>"
    ]
  },
  {
    "objectID": "running-python/index.html#installing-uv",
    "href": "running-python/index.html#installing-uv",
    "title": "2  Running Python",
    "section": "",
    "text": "Go to this page, and follow the instructions for your environment: installing uv.\nOnce uv is installed, type uv python install 3.13 in your terminal.\nAfter Python is installed, verify the version with uv run python -V. You should see a version that starts with 3.13.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Running Python</span>"
    ]
  },
  {
    "objectID": "running-python/index.html#the-python-repl",
    "href": "running-python/index.html#the-python-repl",
    "title": "2  Running Python",
    "section": "The Python REPL",
    "text": "The Python REPL\nOne of the benefits of an interpreted language is that it is possible to run it one line at a time, in an interactive session.\nuv run python\nThis feature of most interpreted languages is called a REPL (pronounced rep-el).\nREPL stands for:\n\nRead - takes user input, typically one line at a time\nEvaluate - evaluate user input, running the code in the current context\nPrint - print the output of the evaluation automatically (without the need for a print())\nLoop - repeat, until the user quits\n\nThis is incredibly useful, many Python programmers keep a REPL open at all times, to try out ideas / test things / look up documentation.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Running Python</span>"
    ]
  },
  {
    "objectID": "running-python/index.html#exercise-python-demos-directory",
    "href": "running-python/index.html#exercise-python-demos-directory",
    "title": "2  Running Python",
    "section": "Exercise: python-demos directory",
    "text": "Exercise: python-demos directory\nLet’s set up a small local Python project using uv so that we can try a different REPL and run some code together.\n\nOpen a terminal and navigate (using cd) to a location where you’d like to create our demo repository.\nMake a new directory (mkdir python-demos) and then enter it (cd python-demos).\nInitialize the directory as a uv project with uv init.\n\nThis will create a pyproject.toml and some other files that aren’t needed for our purposes.\npyproject.toml exists at the root of a Python project and configures what other packages are needed.\n\nLet’s install a package with uv, run uv add ipython\n\nThis will update your pyproject.toml and uv.lock files and install the package for use from within this directory.\n\nTo use this new package you can type uv run ipython from within the python-demos directory, and you will see ipython.\n\nWe’ll talk more about package management and what this tool is doing later in the course.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Running Python</span>"
    ]
  },
  {
    "objectID": "running-python/index.html#ipython-vs-python",
    "href": "running-python/index.html#ipython-vs-python",
    "title": "2  Running Python",
    "section": "ipython vs python",
    "text": "ipython vs python\nipython is an enhanced REPL for Python. It is using the same version of Python you already installed, but providing a different interface.\nIt provides command history, syntax highlighting, and a handful of other useful features that make it many people’s preferred REPL. It is up to you which you prefer, both provide access to the same core language.\nYou will often see interactive Python prompts shown as:\n&gt;&gt;&gt; x = 4 * 3\n&gt;&gt;&gt; print(x)\n12  \nThe lines that begin with &gt;&gt;&gt; are the Python prompt, and lines without &gt;&gt;&gt; indicating output.\nIn ipython input/output lines are marked with In[0] and Out[0] prefixes, but when showing interactive output I will stick to convention and use &gt;&gt;&gt;.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Running Python</span>"
    ]
  },
  {
    "objectID": "running-python/index.html#tip-dont-use-pip-or-conda",
    "href": "running-python/index.html#tip-dont-use-pip-or-conda",
    "title": "2  Running Python",
    "section": "Tip: Don’t use pip (or conda)",
    "text": "Tip: Don’t use pip (or conda)\nYou will see instructions using tools other than uv, but it is best to stick to a single tool.\nWhen you are looking at Python libraries, which we’ll discuss later, you will often see instructions which state you should run pip install foo.\nWhen you see pip install foo you should use uv add foo instead.\nconda install instructions can usually be translated to uv add as well.\nThese tools are older than uv and can easily leave your system in a broken state, where uv restricts installs to the directory you are working in.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Running Python</span>"
    ]
  },
  {
    "objectID": "variables/index.html",
    "href": "variables/index.html",
    "title": "3  Variables & Expressions",
    "section": "",
    "text": "Expressions\nPython code can be thought of as a series of statements. As we review the syntax, we’ll see the familiar import, if, and for – all examples of statements.\nFirst we’ll focus on the expression, a special type of statement, as well as names, what Python calls variables.\nAn expression is anything which evaluates to some value.\nSome Expressions\nAll of these can be said to represent a value, some directly, which we call literals: 4, \"hello\", [1, 2, 3].\nOthers require further evaluation (e.g. 3 + 4 or func(y)) to be resolved to a specific value, but ultimately can be reduced to a value as well.\nThough a bit circular, it may be helpful to think of the rule if it can be assigned to a variable, it is an expression.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variables & Expressions</span>"
    ]
  },
  {
    "objectID": "variables/index.html#expressions",
    "href": "variables/index.html#expressions",
    "title": "3  Variables & Expressions",
    "section": "",
    "text": "3.14\n\"hello\"\n3 + 4\nfunc(y)\nperson.age * 4",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variables & Expressions</span>"
    ]
  },
  {
    "objectID": "variables/index.html#assignment-statements",
    "href": "variables/index.html#assignment-statements",
    "title": "3  Variables & Expressions",
    "section": "Assignment Statements",
    "text": "Assignment Statements\nAssignment statements give a name to a value resulting from an expression.\n\nradius = 5\narea = 3.14 * radius ** 2\nname = \"Tyler\"\nin_class = True\n\nAssignment statements:\n\nHave a name on the left-hand side, an expression on the right-hand side.\nDo not require any additional declaration or type.\nNames must consist of letters, numbers, and/or underscore _. Must begin with a letter or underscore.\nConventionally written in snake_case, with words separated by underscores. (as opposed to camelCase)\n\nVariables in Python work a bit differently than you might expect coming from another language.\nIn many languages, variables are typed, meaning that when you declare a variable it is a “box” that can store a certain sized item.\n// this is C code, the type is part of the variable declaration\nint num_fish = 3;\nchar* name = \"William\";;\n\n// we cannot do this!\nnum_fish = name;\nIn Python, we just assign an expression to a name.\nnum_fish = 3\nname = \"William\"\nnum_fish = name   # this is allowed! (though bad practice)\nDoes this mean variables are untyped?\nLet’s use Python’s type() function to see that Python does indeed have types:\n\nprint(type(radius))\nprint(type(area))\nprint(type(name))\nprint(type(print))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'builtin_function_or_method'&gt;\n\n\nIn Python, types are inferred, not explicitly stated.\nAs we’ll see, the type is associated with the variable, not the name, a subtle distinction but one of the most important concepts to understand Python’s behavior.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variables & Expressions</span>"
    ]
  },
  {
    "objectID": "variables/index.html#scalar-types",
    "href": "variables/index.html#scalar-types",
    "title": "3  Variables & Expressions",
    "section": "Scalar Types",
    "text": "Scalar Types\nPython has several built in scalar types. (Scalar types can have one value at a time.)\nNumeric: int, float, complex\nBool: bool\nNone: None\nTypes are in part defined by what can be done with them, let’s look at some operators:\n\nNumeric Operators & Functions\n\n\n\nOperation\nResult\n\n\n\n\nx + y\nsum\n\n\nx - y\ndifference\n\n\nx * y\nproduct\n\n\nx / y\nquotient\n\n\nx // y\nfloored quotient\n\n\nx % y\nremainder of x / y (modulo)\n\n\nx ** y\nx to the power of y\n\n\n-x\nnegation of x\n\n\nabs(x)\nabsolute value / magnitude of x\n\n\nint(x)\nx converted to integer (floor)\n\n\ndivmod(x, y)\nthe pair (x // y, x % y)\n\n\n\n\n3 / 5\n\n0.6\n\n\n\n3 % 5\n\n3\n\n\n\ndivmod(3, 5)\n\n(0, 3)\n\n\n\nx = 2.999\nprint(int(2.999))\n\n2\n\n\n\nprint(100 // 2)\n\n50\n\n\n\nm = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2\nn = 3628800  # 10!\nprint(n % 11)\n\n10\n\n\n\n\n\n\n\n\nWarningFloating Point Precision\n\n\n\nFloating point numbers have limited precision, as demonstrated below.\nThis is true in all languages, and is a function of how modern computers work.\n\n(0.1 + 0.2) == 0.3\n\nFalse\n\n\nwhat?!\n\n0.1 + 0.2\n\n0.30000000000000004\n\n\nFor this reason, instead of strict equality checking, it is correct to compare that the error is less than some very small epsilon value.\nQuestion What problems could this cause? What can be done about it?\n\n# instead\nepisilon = 0.000000001\nprint(abs((0.1 + 0.2) - 0.3) &lt; episilon)\n\nTrue\n\n\n\n\n\n\nShorthand Operators\n\n\n\nOperation\nResult\n\n\n\n\na += b\na = a + b\n\n\na -= b\na = a - b\n\n\na /= b\na = a / b\n\n\na *= b\na = a * b\n\n\na //= b\na = a // b\n\n\n\n\nx = 64\nx *= 2\nprint(x)\n\n\ns = \"Hello\"\ns += \" Class\"\nprint(s)\n\n128\nHello Class\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nWhat would happen if we did s /= \"e\"? Try it and confirm your guess.\n\n\n\n\nType Conversion\nIf mixing numeric types in arithmetic, Python will automatically upconvert numeric types to the type that can represent more data:\n\nint, int -&gt; int\nint, float -&gt; float\nfloat, complex -&gt; complex\n\n\ny = 4.1\nx = int(3 + y)\n\nprint(x, type(x))\n\n7 &lt;class 'int'&gt;\n\n\nThis behavior is why we have two division operators:\n\nx = 2 // 1\nprint(x, type(x))\n\nx = 2 / 1\nprint(x, type(x))\n\n2 &lt;class 'int'&gt;\n2.0 &lt;class 'float'&gt;\n\n\n\n\nComparison Operators\n\n\n\n\n\n\n\nSyntax\nDefinition\n\n\n\n\nx &gt; y\nTrue if left operand is greater than the right\n\n\nx &lt; y\nTrue if left operand is less than the right\n\n\nx == y\nTrue if both operands are equal\n\n\nx != y\nTrue if both operands are not equal\n\n\nx &gt;= y\nTrue if left operand is greater than or equal to the right\n\n\nx &lt;= y\nTrue if left operand is less than or equal to the right\n\n\n\n\n\nBooleans\nResulting type of any of the relational operators.\nOnly two possible values: True, False\n\n\nLogical Operators\n\nOperators that perform logical AND, OR, and NOT\nThese operators short-circuit (i.e., when an expression is stopped being evaluated as soon as its outcome is determined.)\n\n\n\n\nSyntax\nDefinition\n\n\n\n\nx and y\nTrue if both the operands are true\n\n\nx or y\nTrue if either of the operands is true\n\n\nnot x\nTrue True if operand is false\n\n\n\nNote: these do not use & or | like in C/Java Those symbols have a different purpose in Python.\n\n\n\n\n\n\nNoteQuestion\n\n\n\na = True and print(\"a\")\nb = False and print(\"b\")\nc = False or print(\"c\")\nd = True or print(\"d\")\nWhat will this code print?\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nimport time\n\n# we'll discuss how to write functions/etc. soon\ndef short_func():\n    print(\"short_func\")\n    return False\n\ndef long_func():\n    print(\"long_func\")\n    time.sleep(3)\n    return False\nAre these equivalent?\nresult = long_func() and short_func()\nresult = short_func() and long_func()\n\n\n\n\nNone\nRepresents the absence of a value. It is the only value of NoneType. We’ll talk more about uses of None as the course progresses.\n\nx = None\nprint(x)\nprint(type(x))\n\nNone\n&lt;class 'NoneType'&gt;",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variables & Expressions</span>"
    ]
  },
  {
    "objectID": "variables/index.html#sequence-types",
    "href": "variables/index.html#sequence-types",
    "title": "3  Variables & Expressions",
    "section": "Sequence Types",
    "text": "Sequence Types\nWe’ve seen that scalar types take on a single value.\nSequences store multiple values in a defined order.\nWe’ll take a look at str, list, and tuple.\n\nStrings\nCan use 'single' or \"double\", or \"\"\"triple for multi-line strings\"\"\".\n\ns1 = \"Molly's Idea\"\n\ns2 = '\"I think, therefore I am\" - Descartes'\n\ns3 = \"\"\"From time to time\nThe clouds give rest\nTo the moon-beholders.\n\n- Matsuo Bashō\n\"\"\"\n\nEscape Characters\nLike many languages, Python supports special ‘escape characters’.\n\nprint(\"Another way to \\\"quote\\\" something.\")\n\nprint('An alternate apostrophe: \\' ')\n\nprint(\"Newline character: \\n starts a new line.\")\n\nprint(\"Sometimes you need a \\\\ backslash. \\\" \")\n\nAnother way to \"quote\" something.\nAn alternate apostrophe: ' \nNewline character: \n starts a new line.\nSometimes you need a \\ backslash. \" \n\n\n\n\n\nCharacter\nMeaning\n\n\n\n\n\\n\nNew Line\n\n\n\\t\nTab\n\n\n\\\\\n (backslash)\n\n\n\\'\n’ (apostrophe)\n\n\n\\\"\n” (quote)\n\n\n\n\n\nRaw Strings\n\nerror = \"C:\\new\\test.py\"\nprint(error)\n\nC:\new  est.py\n\n\nWhat happened?\nSometimes it is annoying to need to escape every backslash.\nTwo common examples are when dealing with file paths on Windows or Regular Expressions.\nIn this case we can use r”” to denote a raw string.\n\nfixed = r\"C:\\new\\test.py\"\nprint(fixed)\n\nC:\\new\\test.py\n\n\n\n# still a str\ntype(fixed)\n\nstr\n\n\n\n\nString Formatting\nYou’ll often need to create strings comprised of other values.\nThere are two common ways to do this, .format and f-strings:\n\n# format example 1: implicit\n\nfmt = \"{}@{}.{}\"\nemail = fmt.format(\"username\", \"example\", \"com\")\nprint(email)\n\nusername@example.com\n\n\n\n# format example 2: positional\n\ntemplate = \"Hi {0}, you are user {1}! \\n Bye {0}!\"\nmessage = template.format(\"Tina\", 2.5)\nprint(message)\n\n# note that integer was converted automatically\n# most useful if you want to use the same value multiple times\n\nHi Tina, you are user 2.5! \n Bye Tina!\n\n\n\n# format example 3: keyword\n\nmessage = \"Hi {user}, you are user {num}! \\n Bye {user}!\".format(user=\"Sam\", num=1390)\nprint(message)\n\nHi Sam, you are user 1390! \n Bye Sam!\n\n\n\n# f-strings example (Added in Python 3.6)\n\nuser = \"Ben\"\nnum = 1234\nmessage = f\"Hi {user}, you are user {num}! \\n Bye {user}!\"\nprint(message)\n\nHi Ben, you are user 1234! \n Bye Ben!\n\n\n\n# f-strings debug example (Added in Python 3.8)\nuser = \"James\"\nnum = 1234\n\nprint(f\"{user=} {num=}\")\n# same as f\"user={user} num={num}\" but less repetition\n\n# = is a format specifier, there are many others for aligning output, truncating decimals, etc.\n\nfor i in range(10):\n    print(f\"{i=}\")\n\nuser='James' num=1234\ni=0\ni=1\ni=2\ni=3\ni=4\ni=5\ni=6\ni=7\ni=8\ni=9\n\n\n\n\n\nLists\nOne of the most useful sequence types is list.\nLists are:\n\nOrdered by position, starting at 0.\nMutable, they can be modified in-place\nDynamically-sized, can grow and shrink as needed.\nHeterogeneous, can store mixed types. (Though we often avoid this!)\n\n\nthings = []\n\n# lists can contain items of different types\nthings = [123, \"abc\", 1.23j + 4.5]\n\n# lists can contain other lists\nmeals = [[\"egg\", \"toast\"], [\"sandwich\", \"chips\"], [\"fish\", \"salad\", \"cake\"]]\n\nprint(things)\nprint(meals)\n\n[123, 'abc', (4.5+1.23j)]\n[['egg', 'toast'], ['sandwich', 'chips'], ['fish', 'salad', 'cake']]\n\n\n\n\nTuples\nTuples work very similarly to lists but are immutable, they cannot be changed once created.\n\nmulti_item = (1, 2.0, \"three\")\n\nempty_tuple = ()\n\none_item_tuple = (1 + 2,)  # why is the comma necessary?\nprint(multi_item)\nprint(empty_tuple)\nprint(one_item_tuple)\n\n(1, 2.0, 'three')\n()\n(3,)\n\n\n\nbad_tuple = (1 + 492)\nprint(bad_tuple, type(bad_tuple))  \n\n493 &lt;class 'int'&gt;",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variables & Expressions</span>"
    ]
  },
  {
    "objectID": "variables/index.html#sequence-operations",
    "href": "variables/index.html#sequence-operations",
    "title": "3  Variables & Expressions",
    "section": "Sequence Operations",
    "text": "Sequence Operations\nAll three of these sequence types support some useful operations:\n\n\n\n\n\n\n\n\noperation\nname\ndescription\n\n\n\n\nlen(seq)\nLength\ngets number of items in sequence.\n\n\nseq1 + seq2\nConcatenation\nto concatenate together (make a new sequence).\n\n\nseq * N\nRepetition\ncreates a new sequence that repeats seq, N times.\n\n\nitem in seq\nContainment\ntests for whether or not a given value appears in a sequence.\n\n\nseq[N]\nIndexing\ngets Nth value from sequence.\n\n\nseq[N:M]\nSliced Indexing\nreturns a new sequence that is a “slice” of the original.\n\n\n\n\n# length demo\ns1 = \"Hello World\"\nl1 = [1, [\"a\", \"b\", \"c\"], 3, None, 4]\nt1 = ()\n\nprint(len(s1))\nprint(len(l1))\nprint(len(t1))\n\n11\n5\n0\n\n\n\n# concatenation & repetition demo\ns2 = \"*\" * 5\nt2 = (True, False) * 3\nl2 = [\"a\", \"b\", \"c\"] * 4\nprint(s2)\nprint(t2)\nprint(l2)\n\n*****\n(True, False, True, False, True, False)\n['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']\n\n\n\n# concatenation & repetition demo\ns2 = \"*\" * 5\nt2 = (True, False) * 3\nl2 = [\"a\", \"b\", \"c\"] * 4\nprint(s2, \"\\n\", t2, \"\\n\", l2)\n\n***** \n (True, False, True, False, True, False) \n ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']\n\n\n\ncities = [\n    \"Tokyo\",\n    \"Delhi\",\n    \"Shanghai\",\n    \"São Paulo\",\n    \"Mexico City\",\n    \"Cairo\",\n    \"Mumbai\",\n    \"Beijing\",\n    \"Dhaka\",\n    \"Osaka\",\n]\ntext = \"Four score and seven years ago our fathers brought forth, upon this continent, a new nation, conceived in liberty, and dedicated to the proposition that all men are created equal\"\nids = (123, 555, 81, 110, 44, 12, 16)\n\nprint(cities[3])\nprint(text[12])\nprint(ids[0])\n\nSão Paulo\nn\n123\n\n\n\n# containment\nprint(\"Shanghai\" in cities)\nprint(\"Delhi\" in cities)\nprint(\" seven \" in text)\nprint(\"7\" in text)\nprint(123 in ids)\n\nTrue\nTrue\nTrue\nFalse\nTrue\n\n\n\n# slicing\nprint(cities[2:-4])\nprint(\"hello world\"[2:5])\nprint(cities[8:])\n\n['Shanghai', 'São Paulo', 'Mexico City', 'Cairo']\nllo\n['Dhaka', 'Osaka']\n\n\n\nIndexing / Slicing Rules\ns = \"Hello!\"\n\n\n\nLetter\nIndex\n-Index\n\n\n\n\nH\n0\n-6\n\n\ne\n1\n-5\n\n\nl\n2\n-4\n\n\nl\n3\n-3\n\n\no\n4\n-2\n\n\n!\n5\n-1\n\n\n\nFirst element is 0.\nLast element is -1.\nSlice boundaries are inclusive of first, exclude last.\n\n\nmutable sequence methods\n(for now just list)\n\n\n\n\n\n\n\nOperation\nResult\n\n\n\n\ns[i] = x\nReplace element i in sequence with x.\n\n\ns.append(x)\nAdd item to end of sequence.\n\n\ns.clear()\nRemove all items from sequence.\n\n\ns.copy()\nCreate a (shallow) copy of sequence.\n\n\ns.insert(i, x)\nInsert an item x at position i.\n\n\ns.pop() or s.pop(i)\nRetrieve item at position i and remove it. (Defaults to -1 if not provided)\n\n\ns.reverse()\nReverse items of s in place.\n\n\n\n\n# list mutation\nletters = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\n\nletters.append(\"H\")\nprint(letters)\n\n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n\n\n\nletters.insert(0, \"*\") \nletters.pop()\nletters.pop(4)\nprint(letters)\n\n['*', 'A', 'B', 'C', 'E', 'F', 'G']\n\n\n\nletters.reverse()\nprint(letters)\n\n['G', 'F', 'E', 'C', 'B', 'A', '*']\n\n\n\n\ncommon string methods\nString has some special methods\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\ns.find(sub)\nFinds first occurrence of substring sub or -1 if not found\n\n\ns.lower()\nConverts the string to lowercase.\n\n\ns.upper()\nConverts the string to uppercase.\n\n\ns.replace(old, new)\nReplaces occurrences of old with new.\n\n\ns.strip()\nRemove leading & trailing whitespace.\n\n\ns.startswith(prefix)\nChecks if a string starts with prefix.\n\n\ns.endswith(suffix)\nChecks if a string ends with suffix.\n\n\ns.split(sep)\nSplit a string using sep as delimiter.\n\n\n\n(Credit: Python Distilled, Table 1.6)\nhttps://docs.python.org/3/library/stdtypes.html#string-methods\n\n# string method demo\ns = \"Hello world!\"\n\n# find\npos = s.find(\"world\")\nprint(pos)\n\n6\n\n\n\nprint(s[pos:])\n\nworld!\n\n\n\nnew_string = s.upper()\n\nprint(\"s=\", s)\nprint(\"new_string=\", new_string)\n\ns= Hello world!\nnew_string= HELLO WORLD!\n\n\n\ns.replace(\"world\", \"class\")\nprint(s)\n\nHello world!",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variables & Expressions</span>"
    ]
  },
  {
    "objectID": "statements/index.html",
    "href": "statements/index.html",
    "title": "4  Statements",
    "section": "",
    "text": "Indentation\nPython programs are made up of statements. Expressions are special types of statements that represent values.\nNow we’ll look at statements related to control flow, deciding which lines of code will be executed next. Without them our programs would just execute one line after the next with no exception.\nPerhaps the most jarring change for C/Java/JavaScript programmers: Python does not use braces.\nInstead, indentation signifies code block boundaries.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statements</span>"
    ]
  },
  {
    "objectID": "statements/index.html#indentation",
    "href": "statements/index.html#indentation",
    "title": "4  Statements",
    "section": "",
    "text": "from __future__ import braces\nSyntaxError: not a chance",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statements</span>"
    ]
  },
  {
    "objectID": "statements/index.html#if-elif-else-statements",
    "href": "statements/index.html#if-elif-else-statements",
    "title": "4  Statements",
    "section": "if, elif, else Statements",
    "text": "if, elif, else Statements\nif condition:\n    statement1\n    statement2\nelif condition:    # else if\n    statement3\nelse:\n    statement4\n    statement5\n\nNote the colon after each condition.\nelif and else are optional\nparenthesis around the expression are optional\neach line should be indented four spaces\n\nThis is a statement because you don’t write\nx = if ...:\n        ...\n    else:\n        ...\n    else:\n        ...\nInstead, these lines of code are evaluated conditionally.\n\n# if example\n\nx = 100\n\nif x &lt; 0:\n    print(\"negative\")\n    print(\"second line\")\nelif x == 0:\n    print(\"zero\")\nelif x == 4:\n    print(\"four\")\nelse:\n    print(\"positive\")\n\npositive",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statements</span>"
    ]
  },
  {
    "objectID": "statements/index.html#while-statement",
    "href": "statements/index.html#while-statement",
    "title": "4  Statements",
    "section": "while statement",
    "text": "while statement\nwhile condition:\n    statement1\n    statement2\n\ntime_left = 10\n\nwhile time_left != 0:\n    print(f\"{time_left}...\")\n    time_left -= 1\n\nprint(\"blast off!\") \n\n10...\n9...\n8...\n7...\n6...\n5...\n4...\n3...\n2...\n1...\nblast off!",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statements</span>"
    ]
  },
  {
    "objectID": "statements/index.html#for-statement",
    "href": "statements/index.html#for-statement",
    "title": "4  Statements",
    "section": "for statement",
    "text": "for statement\nfor var in iterable:\n    statement1\n    statement2\nThis looks a bit different from C/Java.\nAlso, what is an iterable?\nFor now, just know that sequences are iterables, we’ll cover iterables soon.\n\ncities = [\n    \"Tokyo\",\n    \"Delhi\",\n    \"Shanghai\",\n    \"São Paulo\",\n    \"Mexico City\",\n    \"Cairo\",\n    \"Mumbai\",\n    \"Beijing\",\n    \"Dhaka\",\n    \"Osaka\",\n]\n\nfor city in cities:\n    if city == \"Cairo\":\n        # we don't need to print Cairo out\n        break\n    print(city)\n\nseconds_left = 7\n\nTokyo\nDelhi\nShanghai\nSão Paulo\nMexico City\n\n\n\nfor city in cities:\n    need_to_break = False\n    for letter in city:\n        if letter == \"y\":\n            need_to_break = True\n            break\n        print(letter)\n    if need_to_break:\n        break\n\nT\no\nk\n\n\n\nbreak & continue\nYou may have seen break and continue in other languages.\nIf so, they work the same way in Python.\nbreak - exit a loop immediately\ncontinue - immediately begin next iteration of loop\nelse statement after for or while - executes only if no break was called\n\n# break/else demo\n\ntime_left = 10\nabort_at = 4\n\nwhile time_left &gt; 0:\n    print(f\"{time_left}...\")\n    time_left -= 1\n    if time_left == abort_at:\n        print(\"Launch Aborted\")\n        break\nelse:\n    # this only runs if we don't break\n    print(\"blast off!\")\n\n10...\n9...\n8...\n7...\n6...\n5...\nLaunch Aborted\n\n\n\ns = \"Hello class, my name is James\"\n\nfor ch in s:\n    if ch == \",\":\n        print(\"found a comma!\")\n        break\nelse:\n    print(\"no comma found!\")\n\nfound a comma!\n\n\n\n# continue demo\n\nprint(cities)\nvisited = [\"Chicago\", \"Mexico City\", \"Shanghai\"]\n\nfor city in cities:\n    # this is not a great use, what would you do instead?\n    if city in visited:\n        continue\n    print(f\"I would like to visit {city}\")\n\n['Tokyo', 'Delhi', 'Shanghai', 'São Paulo', 'Mexico City', 'Cairo', 'Mumbai', 'Beijing', 'Dhaka', 'Osaka']\nI would like to visit Tokyo\nI would like to visit Delhi\nI would like to visit São Paulo\nI would like to visit Cairo\nI would like to visit Mumbai\nI would like to visit Beijing\nI would like to visit Dhaka\nI would like to visit Osaka\n\n\ncontinue is not used as often as break in practice, but can be useful if you want to skip part of a loop.\nGiven the somewhat less straightforward nature of a continue, a comment explaining your intent is a good idea.\n\nidiom: double-break with an inner boolean\n\nitems = [\"hello\", \"world\"]\nfound = False\n\n# we want to exit as soon as an e is found in *either* loop\nfor item in items:\n    for letter in item:\n        if letter == \"e\":\n            found = True\n            break\n        print(letter)\n    if found:\n        break\n\nh\n\n\n\n\nidiom: “infinite” loops\nwhile True:\n    do_something()\n    if condition:\n        break\nSimilar to a do while loop in C/C++, where condition is checked after one iteration.\n\n\n\nrange\nAnother iterable!\nrange(stop) # goes from 0 to (stop-1)\nrange(start, stop) # goes from start to (stop-1)\nSame rules as slice, always inclusive of start, exclusive of stop.\nor as you’d write mathematically: [start, stop)\n\nfor x in range(5, 25):\n    print(x)\n\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Note: we'll see a better way to do what this loop does below.\ns = \"hello\"\nfor i in range(len(s)):\n    print(i, s[i])\n\n0 h\n1 e\n2 l\n3 l\n4 o\n\n\n\n\nenumerate\nAnother iterable, for when we need the index along with the object.\nGives us back two element tuples:\n(index, element)\n\nfor i, letter in enumerate(s):\n    if letter == \"w\":\n        print(i)\n\n\n# same as above -- but less idiomatic & clear\nfor tup in enumerate(s):\n    if tup[1] == \"w\":\n        print(tup[0])",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statements</span>"
    ]
  },
  {
    "objectID": "statements/index.html#iteration",
    "href": "statements/index.html#iteration",
    "title": "4  Statements",
    "section": "Iteration",
    "text": "Iteration\nA for loop can be described as iterating over an iterable:\nfor var_name in iterable:\n    statement1\n    statement2\n    ...\nAn iterable is any object that can be iterated over. All sequences are iterable, what else is?\n\nrange\nAnother iterable!\nrange(stop) # goes from 0 to (stop-1)\nrange(start, stop) # goes from start to (stop-1)\nSame rules as slice, always inclusive of start, exclusive of stop.\nor as you might write: [start, stop) – we’ve seen this before with slicing\n\nfor x in range(12):\n    print(x)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\nfor x in range(8, 12):\n    print(x)\n\n8\n9\n10\n11\n\n\n\nr = range(12)  # hmm?\nprint(type(r))\n\n&lt;class 'range'&gt;\n\n\n\n# a common pattern, but we'll see a better way with enumerate\ni = 0\nfor x in [\"A\", \"B\", \"C\"]:\n    print(i, x)\n    i += 1\n\n0 A\n1 B\n2 C\n\n\n\n\nenumerate\nAnother function that returns an iterable, for when we need the index along with the object.\nenumerate(original_iterable) yields two element tuples: (index, element) for every item in the original.\n\n# \"incorrect\" example\n# find using range/len - as you might think to write it based on past experience\ndef find_r(s, letter_to_find):\n    for i in range(len(s)):\n        if s[i] == letter_to_find:\n            return i\n    return -1\n\n\nfind_r(\"Hello World\", \"W\")\n\n6\n\n\n\n# find using enumerate - Pythonic, more efficient\ndef find_e(s, letter_to_find):\n    for i, letter in enumerate(s):  # tuple unpacking\n        if letter == letter_to_find:\n            return i\n    return -1\n\n\nfind_e(\"Hello world\", \"w\")\n\n6\n\n\n\nfind_r(\"Hello world\", \"?\")\n\n-1\n\n\n\n# note: a built-in exists and should be used in practice\ns = \"Hello world\"\ns.find(\"w\")\n\n6\n\n\n\n\niterable unpacking\nWhen you know exactly how many elements are in an iterable, you can use this syntax to “unpack” them into variables:\n\ntup = (1, 2, 3)\nll = [\"a\", \"b\", \"c\"]\n\nx, y, z = tup\nprint(x, y, z)\n\n1 2 3\n\n\n\n# idomatic swap using unpacking\nx = 7\ny = 8\nx, y = y, x\nprint(x, y)\n\n8 7",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statements</span>"
    ]
  },
  {
    "objectID": "statements/index.html#functions",
    "href": "statements/index.html#functions",
    "title": "4  Statements",
    "section": "Functions",
    "text": "Functions\nA function is a set of statements that can be called more than once.\nBenefits of functions:\n\nEncapsulation: package logic for use in multiple places\nAllows programmer to avoid copy/paste to repeat same task, which helps maximize code reuse and minimize redundancy\nProcedural decomposition: split our program into subtasks (i.e., functions) with separate roles.\nMake life easier for debugging, testing, doing maintenance on code\n\ndef function_name(arg1: int, arg2: float, arg3: tuple) -&gt; None:\n    \"\"\"\n    Description of function task \n\n    Parameters: \n        arg1: description of arg1 \n        arg2: description of arg2\n        arg3: description of arg2\n\n    Returns:\n         Description of what this function returns, if anything.\n    \"\"\"\n    statement1\n    statement2\n    statement3\n    return value  # optional\n\nreturn\n\nreturn may appear anywhere in a function body, including multiple times.\nThe first return encountered exits the function immediately.\nEvery function in python returns a value, None if not stated/reached.\n\n\ndef is_even(num):\n    return num % 2 == 0\n\nprint(is_even(3))\n\nFalse\n\n\n\n# what happens if return is missing?\ndef bad_return(num):\n    if num &gt; 10000: \n        return False\n\n\nprint(bad_return(1))\n\nNone\n\n\n\n\npass statement\nCan be used whenever you need to leave a block empty. Usually temporarily.\nif x &lt; 0:\n    pass # TODO: figure this out later\nelse:\n    return y / 2 - x\n\ndef implement_me():\n    pass\n\n\nType Annotations\nType annotations are a newer Python feature. They exist to provide hints as to what types a function takes.\nPython does not enforce these, think of them as documentation.\nYou will start seeing them in assignments and documentation, and we’ll discuss them more later in the quarter.\n\n# I've broken this function into multiple lines, which is allowed\n# due to the parentheses.\n\ndef find_value(\n    a_list: list[list[str]],  # this parameter is a list of integers\n    num: int,                 # this parameter is a single integer\n) -&gt; (\n    int | None\n):  # this annotation \"-&gt; int | None\" indicates return type can be int or None\n    pass\n\ndef find_value(a_list: list[str], num: int) -&gt; int | None:  \n    pass\n\n\nx = find_value(3.0, \"hello\")\n\n\n\ndocstrings\nFunction comments should be done in the form of a docstring, i.e., a multi-line string (delimited by triple quotes) after the function header.\nThis comment must contain information specific to what a function does. It should also include a description of the purpose and expected input arguments, the expected output values, and how error conditions are handled.\nExample:\ndef hypotenuse(a: float, b: float) -&gt; float:\n    \"\"\"\n    This function solves Pythagorean theorem a^2 + b^2 = c^2\n    for the value of c.\n\n    Parameters:\n      a, b: the lengths of sides of a right triangle.\n\n    Returns:\n      The length of the hypotenuse.\n    \"\"\"\n\n    return math.sqrt(a**2 + b**2)",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statements</span>"
    ]
  },
  {
    "objectID": "collections/index.html",
    "href": "collections/index.html",
    "title": "5  Collections",
    "section": "",
    "text": "sequences are collections\nWhen we last talked about types, we introduced scalars and sequences. Sequences are a subset of the collections.\nLet’s review the sequence types:\nAll of these are collections because they can contain many values, today we’ll see three more collection types. These types are not ordered.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "collections/index.html#sequences-are-collections",
    "href": "collections/index.html#sequences-are-collections",
    "title": "5  Collections",
    "section": "",
    "text": "NoteWhat three types were sequences?\n\n\n\n\n\n\nstr\nlist\ntuple\n\n\n\n\n\n\n\n\n\n\nNoteWhat did these have in common?\n\n\n\n\n\n\nordered\ncan be indexed\ncertain sequence methods\ncan be iterated over",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "collections/index.html#dict",
    "href": "collections/index.html#dict",
    "title": "5  Collections",
    "section": "dict",
    "text": "dict\nA collection of key-value pairs. (aka map/hashmap in other languages)\n\nKeys must be hashable. tuple, str, scalars – why?\nValues are references, can be any type.\nDynamically resizable\nImplemented using a hashtable, lookup is constant-time. O(1)\nIterable? Yes\nMutable? Yes\nSequence? No. (Why not?)\n\n\nrecord1 = {\n    \"name\": \"Anna\",\n    2024: 42,\n    2023: 12,\n}\nprint(record1)\n\n{'name': 'Anna', 2024: 42, 2023: 12}\n\n\n\n# declaration\nrecord1 = {\n    \"name\": \"Anna\",\n    \"age\": 42,\n}\n\nempty = {}\n\n# alternate form\nrecord2 = dict(age=42, name=\"Anna\")\n# there is also a list(\"a\", \"b\", \"c\") form\n\n# less common: can construct from sequence of tuples\nrecord3 = dict(\n    [\n        (\"name\", \"Anna\"),\n        (\"age\", 42)\n    ]\n)\n\n\nprint(record1)\nprint(record2)\n# compare as equal if all keys/value pairs are equal\nprint(record1 == record2)\n\n{'name': 'Anna', 'age': 42}\n{'age': 42, 'name': 'Anna'}\nTrue\n\n\n\n# read / write to key the same way you do with lists\nprint(record1[\"name\"])\nrecord1[\"name\"] = \"Annabelle\"\n\nAnna\n\n\n\n# sequence method 'in' tests if a key exists (not a value!)\nprint(\"name\" in record1)\nprint(42 in record1)\n\nTrue\nFalse\n\n\n\n# keys, values, items are special iterables\nprint(record1.keys())\nprint(record1.values())\nprint(record1.items())\n\ndict_keys(['name', 'age'])\ndict_values(['Annabelle', 42])\ndict_items([('name', 'Annabelle'), ('age', 42)])\n\n\n\nfor k, v in record1.items():\n    print(k, v)\n\nname Annabelle\nage 42\n\n\n\nhashable keys\nDictionary keys must be hashable, for now you can think of that as the same as immutable.\nDictionaries use a built in hash() function to convert a key to a large integer as part of their internals. (We will revisit these internals in the second half of the course.)\n\nprint(hash(1))\nprint(hash(\"ABC\"))\n\n1\n-592325439161282887\n\n\nhash({}) # TypeError!\nhash([1, 2, 3]) # TypeError!\n\n# tuples are hashable\nd = {}\nd[(1, 2, 3)] = 4\nprint(d)\n\n{(1, 2, 3): 4}\n\n\n\n\nMutability\nDictionaries are mutable, you can change, expand, and shrink them in place.\nThis means we aren’t copying/creating new dictionaries on every edit.\n\norder = {\"spam\": 1, \"eggs\": 2, \"coffee\": 1}\n\norder[\"sausage\"] = 1\nprint(order)\n\n{'spam': 1, 'eggs': 2, 'coffee': 1, 'sausage': 1}\n\n\n\ndel order[\"eggs\"]\nprint(order)\n\n{'spam': 1, 'coffee': 1, 'sausage': 1}\n\n\n\norder[\"bagel\"] = 1\nprint(order)\n\n{'spam': 1, 'coffee': 1, 'sausage': 1, 'bagel': 1}\n\n\n\nhash(\"bagel\"), hash(\"Bagel\")\n\n(9209231884251648678, -8442634502516672634)\n\n\n\n# dictionaries are iterable (keys by default)\nfor key in order:\n    print(key)\n\nspam\ncoffee\nsausage\nbagel\n\n\n\n# can use .items() or .values() to loop over non-keys\nfor key, value in order.items():\n    print(f\"{key=} {value=}\")\n\nprint(order.items())\n\nkey='spam' value=1\nkey='coffee' value=1\nkey='sausage' value=1\nkey='bagel' value=1\ndict_items([('spam', 1), ('coffee', 1), ('sausage', 1), ('bagel', 1)])\n\n\n\n# can use .items() or .values() to loop over non-keys\nfor a_tuple in order.items():\n    print(a_tuple[0], a_tuple[1])\n\nspam 1\ncoffee 1\nsausage 1\nbagel 1\n\n\n\n\ncommon dictionary methods\n\n\n\n\n\n\n\nOperation\nMeaning\n\n\n\n\nd.keys()\nView of all keys.\n\n\nd.values()\nView of all values.\n\n\nd.items()\nView of key, value tuples.\n\n\nd.copy()\nMake a (shallow) copy.\n\n\nd.clear()\nRemove all items.\n\n\nd.get(key, default=None)\nSame as d[key] except if item isn’t present, default will be returned.\n\n\nd.pop(key, default=None)\nFetch item & remove it from dict.\n\n\nlen(d)\nNumber of stored entries.\n\n\n\nSee all at https://docs.python.org/3/library/stdtypes.html#dict\n\nd = {\"eggs\": 2, \"coffee\": 1}\n\nkey = \"fish\"\n# get can return a default if not present\nprint(\"ordered\", d.get(key, 0), key)\n\nordered 0 fish\n\n\n\n# pop removes the item\nprint(d.pop(\"coffee\"), \"coffee served\")\nprint(\"order is now\", d)\n\n1 coffee served\norder is now {'eggs': 2}\n\n\n\n# pop can take a default\nspam_ordered = order.pop(\"spam\", 0)\nprint(spam_ordered)\n\n1\n\n\n\n\nDictionary View Objects\nkeys(), values() and items() return special “view objects” that are meant for iteration.\nThe returned object is a dynamic view, so when the dictionary changes, the view changes.\n\ndishes = {\"eggs\": 2, \"sausage\": 1, \"bacon\": 1, \"spam\": 500}\n\n# Keys is a view object of the keys from the dishes dictionary\nkeys = dishes.keys()\nvalues = dishes.values()\nitems = dishes.items()\n\nprint(keys)\nprint(values)\nprint(items)\n\ndict_keys(['eggs', 'sausage', 'bacon', 'spam'])\ndict_values([2, 1, 1, 500])\ndict_items([('eggs', 2), ('sausage', 1), ('bacon', 1), ('spam', 500)])\n\n\n\n# View objects are dynamic and reflect dictionary changes\n\n# Lets delete the 'eggs' entry\ndel dishes[\"eggs\"]\n\n# Notice the both the views have removed key and its value\nprint(keys)\nprint(values)\nprint(items)\n\ndict_keys(['sausage', 'bacon', 'spam'])\ndict_values([1, 1, 500])\ndict_items([('sausage', 1), ('bacon', 1), ('spam', 500)])\n\n\n\n# Nested Dictionaries Example\n\nmenu = {\n    \"Breakfast\": {\"Eggs\": 2.19, \"Toast\": 0.99, \"Orange Juice\": 1.99},\n    \"Lunch\": {\"BLT\": 3.99, \"Chicken\": 5.99, \"Salad\": 4.50},\n    \"Dinner\": {\"Cheeseburger\": 9.99, \"Salad\": 7.50, \"Special\": 8.49},\n}\n\nprint(menu[\"Lunch\"])\n\nprint(menu[\"Lunch\"][\"Salad\"])\n\n{'BLT': 3.99, 'Chicken': 5.99, 'Salad': 4.5}\n4.5\n\n\n\n\nCaveats\nMutability comes at a cost, mutable types are less memory efficient and more prone to misuse.\nWe’ll talk more about this when we revisit identity next week.\nA common error is attempting to modify a dict while iterating over it.\nImagine the function:\n\nsample = {\"A\": -3, \"B\": 2, \"C\": 0, \"D\": 100}\n\n# this will not work\ndef remove_bad(d):\n    for k, v in d.items():\n        if v &lt;= 0:\n            d.pop(k)\n\n\ntry:\n    remove_bad(sample)\nexcept Exception as e:\n    print(repr(e))\n\nRuntimeError('dictionary changed size during iteration')\n\n\nModifying an iterable while iterating over it is invalid. A list will not allow this either.\nWhat do you do instead?\n\ndef remove_with_copy(d):\n    # create a copy that is safe to modify\n    d_copy = d.copy()\n\n    for k, v in d.items():\n        if v &lt;= 0:\n            d_copy.pop(k)\n\n    return d_copy\n\nremove_with_copy(sample)\n\n{'B': 2, 'D': 100}\n\n\nIf creating a copy is too expensive, you can consider this approach:\n\ndef remove_without_copy(d):\n    to_remove = []\n\n    for k, v in d.items():\n        if v &lt;= 0:\n            to_remove.append(k)\n\n    for k in to_remove:\n        d.pop(k)\n\n    return d\n\nremove_without_copy(sample)\n\n{'B': 2, 'D': 100}\n\n\n\n\n\n\n\n\nWarning\n\n\n\nNote that the two approaches have different behavior. The version without the copy modifies the original dictionary, which can lead to unexpected results.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "collections/index.html#set",
    "href": "collections/index.html#set",
    "title": "5  Collections",
    "section": "set",
    "text": "set\nSets contain an unordered collection of unique & immutable values.\n\nUnique: no duplicates\nImmutable: values cannot be dict, set, list.\n\nSets themselves are mutable.\n\n# defining a set\nanimals = {\"llama\", \"panda\", \"ostrich\"}\nprint(animals)\n\n# or can be made from an iterable\nanimals = set([\"llama\", \"panda\", \"ostrich\"])\nprint(animals)\n\n{'panda', 'llama', 'ostrich'}\n{'panda', 'llama', 'ostrich'}\n\n\n\n# an empty set, why not {}?\ns = set()\ns\n\nset()\n\n\n\n# removes duplicates\nset([\"llama\", \"panda\", \"ostrich\", \"ostrich\", \"panda\"])\n\n{'llama', 'ostrich', 'panda'}\n\n\n\n# can use this behavior to deduplicate a list, if order doesn't matter\nll = [1, 23, 4920, 2091, 4920, 4920, 4920, 23]\ndeduped = list(set(ll))\nprint(deduped)\n\n[4920, 1, 2091, 23]\n\n\nOrdering is lost!\n\nSet Theory Operations\nPython sets are based on the mathematical concept and provide operations based on set theory. A few operations:\n\nUnion (union() or |}: A set containing all elements that are in both sets\nDifference (difference() or -): A set that consists of elements that are in one set but not the other.\nIntersection (intersection or &): A set that consists of all elements that are in both sets.\n\n\n# The following creates a set of single strings 'a','b','c','d','e'\n# and another set of single strings 'b','d','x','y','z'\nA = set(\"abcde\")\nB = set([\"b\", \"d\", \"x\", \"y\", \"z\"])\n\nprint(f\"A = {A}\\nB = {B}\")\n\nA = {'d', 'a', 'b', 'e', 'c'}\nB = {'x', 'd', 'b', 'z', 'y'}\n\n\n\n# Union Operation\nnew_set = A | B\nprint(new_set)\nprint(\"---\")\nnew_set = A.union(B)  # Same operation as above but using method\nprint(new_set)\n\n{'x', 'd', 'a', 'b', 'e', 'c', 'z', 'y'}\n---\n{'x', 'd', 'a', 'b', 'e', 'c', 'z', 'y'}\n\n\n\n# Difference Operation\nnew_set = A - B\nprint(new_set)\nprint(\"---\")\nnew_set = B.difference(A)  # note that order matters for difference\nprint(new_set)\n\n{'e', 'a', 'c'}\n---\n{'z', 'x', 'y'}\n\n\n\n# Intersection Operation\nnew_set = A & B\nprint(new_set)\nprint(\"---\")\nnew_set = A.intersection(B)  # same operation as above but using method\nprint(new_set)\n\n{'d', 'b'}\n---\n{'d', 'b'}\n\n\n\n# Symmetric Difference Operation\nnew_set = A ^ B\nprint(new_set)\nprint(\"---\")\nnew_set = A.symmetric_difference(B)  # same operation as above but using method\nprint(new_set)\n\n{'a', 'x', 'e', 'c', 'z', 'y'}\n---\n{'a', 'x', 'e', 'c', 'z', 'y'}\n\n\n\n\nOther Set Methods\n\n\n\n\n\n\n\nMethod\nPurpose\n\n\n\n\ns.add(item)\nAdds an item to set.\n\n\ns.update(iterable)\nAdds all items from iterable to the set.\n\n\ns.remove(item)\nRemove an item from set.\n\n\ns.discard(item)\nRemove an item from set if it is present, fail silently if not.\n\n\ns.pop()\nRemove an arbitrary item from the set.\n\n\ns.clear()\nRemove all items from the set.\n\n\n\ns = {1, 2, 3}\nprint(s.remove(4)) # KeyError\n\ns = set()  # why not {}?\n\ns.update([\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"J\", \"Q\", \"K\"])\n\ns.remove(\"A\")\nprint(\"Removed Ace\")\nprint(s)\n\nRemoved Ace\n{'9', 'Q', '6', '2', 'K', '4', '7', 'J', '5', '8', '3'}\n\n\n\ns.discard(\"9\")\nprint(s)\n\n{'Q', '6', '2', 'K', '4', '7', 'J', '5', '8', '3'}\n\n\n\ncard = s.pop()\nprint(\"Popped\", card)\nprint(s)\n\nPopped Q\n{'6', '2', 'K', '4', '7', 'J', '5', '8', '3'}\n\n\n\ns.add(\"Joker\")\nprint(s)\n\n{'6', '2', 'K', '4', '7', 'J', '5', '8', '3', 'Joker'}\n\n\nSets can be used for set-like operations on other types by converting them to sets.\n\nd1 = {\"eggs\": 2, \"pancakes\": 100, \"juice\": 1}\nd2 = {\"eggs\": 3, \"waffles\": 1, \"coffee\": 1}\nd3 = {\"eggs\": 1, \"fruit salad\": 1}\n\nprint(\"All 3 ordered:\", set(d1) & set(d2) & set(d3))\nprint(\"Only ordered by #1:\", set(d1) - set(d2))\n\nAll 3 ordered: {'eggs'}\nOnly ordered by #1: {'pancakes', 'juice'}\n\n\n\nset(d1.items())\n\n{('eggs', 2), ('juice', 1), ('pancakes', 100)}\n\n\nSets are iterable.\n\ns = {\"one\", \"two\", \"three\", \"four\"}\nfor x in s:\n    print(x)\n\ntwo\nfour\none\nthree\n\n\n\nstudents = [\n    {\"name\": \"Adam\", \"num\": 123},\n    {\"name\": \"Quynh\", \"num\": 456},\n    {\"name\": \"Quynh\", \"num\": 456},\n    {\"name\": \"Adam\", \"num\": 999},\n]\n\ns = set()\nfor student in students:\n    s.add(tuple(student.items()))\n    # not \n    #s.add(student)\ndeduplicated = s\n\n\nfor student in deduplicated:\n    print(dict(student))\n\n{'name': 'Adam', 'num': 999}\n{'name': 'Quynh', 'num': 456}\n{'name': 'Adam', 'num': 123}\n\n\n\n\nfrozenset\nfrozenset is an immutable set. It has all set methods that do not mutate the set.\n\n# frozenset demo\nnums = [1, 2, 2, 2, 3, 3]\nfrozen_nums = frozenset(nums)\nprint(frozen_nums)\n\nfrozenset({1, 2, 3})\n\n\n\n# allows for nested sets\nnested = {frozen_nums, frozenset(\"ABC\")}\nprint(nested)\n\n{frozenset({1, 2, 3}), frozenset({'C', 'B', 'A'})}",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "collections/index.html#discussion",
    "href": "collections/index.html#discussion",
    "title": "5  Collections",
    "section": "Discussion",
    "text": "Discussion\n\nAre sets sequences?\n\n\nWhy do set members need to be immutable?\n\n\nHow can we store compound values in sets?\n\n\nWhy do dictionary keys have the same restrictions?",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "identity/index.html",
    "href": "identity/index.html",
    "title": "6  Identity & References",
    "section": "",
    "text": "Names & Mutability Revisited\nNow that we’ve seen all of the built-in types we can take a second look at mutability and explore what Python is doing under the hood, so that we are less likely to be surprised by the behavior.\nRemember that when we do an assignment, we are associating a name with an object, a value in memory.\nIt is the object that has a type, not the name.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Identity & References</span>"
    ]
  },
  {
    "objectID": "identity/index.html#names-mutability-revisited",
    "href": "identity/index.html#names-mutability-revisited",
    "title": "6  Identity & References",
    "section": "",
    "text": "# a name is bound to the result of the expression\nx = 1 + 1\n# the name is re-assigned, we aren't changing data\nx = x + 1\n# this is why we can re-assign to a different type\nx = \"hello\"\n\nImmutable Types\n\nstr\ntuple\nfrozenset\nscalars: int, float, complex, bool, None\n\nFor immutable types, this is the only option, any changes require reassignment.\n\n\nMutable Types\n\nlist\ndict\nset\n\nOn the other hand, mutable values can be changed in place.\nx = [1, 2, 3]\nx.append(4)  # no re-assignment needed!\nprint(x)\n\n\nObject\nAll types in Python share an internal representation as an object (PyObject in C).\nll = [1, 2, 3, 4]\nyy = ll           # increase ref count\nobject\n\n\n\n\n\n\n\n\nField\nExample\nPurpose\n\n\n\n\nid\n393239323\nuniquely identify object within Python interpreter\n\n\nrefcount\n2\ncount how many names currently point to this object\n\n\ntype\nlist\ntype of object\n\n\ndata\n0x80000000\nmemory address where the actual data is stored\n\n\nlength\n4\nOnly present on collection types, stores pre-computed length.\n\n\n\nNotice that name is not stored on the object! Why not?",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Identity & References</span>"
    ]
  },
  {
    "objectID": "identity/index.html#shared-references",
    "href": "identity/index.html#shared-references",
    "title": "6  Identity & References",
    "section": "Shared references",
    "text": "Shared references\nMultiple names can refer to the same object in memory, this is noticable when the objects in question are mutable.\n\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(f\"{y=}\")\n# spooky action at a distance\nprint(f\"{x=}\")\n\ny=[1, 2, 3, 4]\nx=[1, 2, 3, 4]\n\n\nFor immutables, any change causes reassignment:\n\na = 3\nb = a\na *= 2         # reassignment!\nprint(f\"{a=} {b=}\")\n\na=6 b=3",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Identity & References</span>"
    ]
  },
  {
    "objectID": "identity/index.html#garbage-collection",
    "href": "identity/index.html#garbage-collection",
    "title": "6  Identity & References",
    "section": "Garbage Collection",
    "text": "Garbage Collection\nPython is a garbage collected language.\nWe don’t free our own memory, Python does instead.\nBehind the scenes, Python stores a reference counter on each object. How many names/objects reference the object.\nWhen reference count drops to zero, Python can reclaim the memory.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Identity & References</span>"
    ]
  },
  {
    "objectID": "identity/index.html#identity",
    "href": "identity/index.html#identity",
    "title": "6  Identity & References",
    "section": "Identity",
    "text": "Identity\nThe built-in id(...) function returns the identity of an object, which is an integer value guaranteed to be unique and constant for lifetime of object\nIn the official (“CPython”) Interpreter we are using in this class, it is the address of the memory location storing the object.\n\nx = \"Orange\" \nprint(id(x))  # Unique integer-value for the object pointed by x\n\n4367717008\n\n\n\ny = \"Apple\" \nprint(id(y)) \n\n4386528288\n\n\n\nfruit1 = (\"Apples\", 4)\nfruit2 = (\"Apples\", 4)\nfruit3 = fruit2\nprint(f\"Fruit1 id = {id(fruit1)} \\n Fruit2 id = {id(fruit2)}\")\nprint(f\"Fruit3 id= {id(fruit3)}\")\n\nFruit1 id = 4386732672 \n Fruit2 id = 4386732480\nFruit3 id= 4386732480\n\n\n\nfruit1 is fruit2\n\nFalse\n\n\n\nEquality vs. Identity\nTwo different ways of testing if objects are the “same”:\n\nEquality operator (==): Returns true if two objects are equal (i.e., have the same value)\nIdentity operator (is): Returns true if two objects identities are the same.\n\na is b means id(a) == id(b)\n\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(\"a == b\", a == b)\n\nprint(id(a))\nprint(id(b))\nprint(\"a is b\", a is b)  # The id values are different\n\na == b True\n4386802304\n4386802432\na is b False\n\n\n\nprint(id(None))\n\n4342702904\n\n\n\ndef f():\n    pass\nid(f())\n\n4342702904\n\n\n\n\nis None\nIf you ever need to check if a value is None, you’d use is None or is not None\n\n\nlist / string mutability revisited\n\n# list d\nd = [1, 2, 3]\nprint(id(d))\nd.append(4)\nprint(d)\nprint(id(d))\n\n4386802496\n[1, 2, 3, 4]\n4386802496\n\n\n\n# str D\ns = \"Hello\"\nprint(id(s))\ns += \" World\"\nprint(s)\n\n# did s change?\nprint(id(s))\n\n4386531504\nHello World\n4386806320\n\n\n\n\nAside: Object Creation Quirk\n\nEach time you generate a new value in your script by running an expression, Python creates a new object (i.e., a chunk of memory) to represent that value.\n– Learning Python 2013\n\nNot quite! CPython does not guarantee this, and in fact sometimes caches & reuses immutable objects for efficiency.\n\na = 100000000\nb = 100000000\n\n# Two different objects, two different ids.\nprint(a is b)\n\nFalse\n\n\n\na = 100\nb = 100\n\n# However, for small integer objects, CPython caches them\n# this means that a and b point to the same object\nprint(a is b)\n\nTrue\n\n\n\n# CPython does the same for short strings\nstr1 = \"MPCS\"\nstr2 = \"MPCS\"\nprint(id(str1), id(str2))\nstr1 is str2\n\n4386524256 4386524256\n\n\nTrue\n\n\nIn practice this is just a quirk of the CPython interpreter, since the objects are immutable it isn’t important to know that they share memory in some cases.",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Identity & References</span>"
    ]
  },
  {
    "objectID": "identity/index.html#copy-deepcopy",
    "href": "identity/index.html#copy-deepcopy",
    "title": "6  Identity & References",
    "section": "copy & deepcopy",
    "text": "copy & deepcopy\nIf y = x does not make a copy, how can we get one?\nWe’ve seen the .copy() method on a few of our types. Which ones?\nWe can also use the copy module:\n\nx = [1, 2, 3]\ny = x.copy()\n\nprint(id(x))\nprint(id(y))\n\nx.append(4)\nprint(x, y)\n\n4386723520\n4386956480\n[1, 2, 3, 4] [1, 2, 3]\n\n\n\n# shallow copy example (nested mutables are not copied)\n\nx = [[1, 2], [3, 4]]\ny = x.copy()  # or copy.copy(x)\n\nprint(\"x is y\", x is y)\nprint(\"x[0] is y[0]\", x[0] is y[0])\nprint(\"x[1] is y[1]\", x[1] is y[1])\n\n# print(x, y)\nx[0].append(5)\nprint(x, \"\\n\", y)\n\nx is y False\nx[0] is y[0] True\nx[1] is y[1] True\n[[1, 2, 5], [3, 4]] \n [[1, 2, 5], [3, 4]]\n\n\n\n# deep copy (nested mutables are copied)\nimport copy\n\n# copy.copy(obj) --&gt; same as obj.copy()\nz = copy.deepcopy(x)\nprint(\"x[0] is z[0]\", x[0] is z[0])\n\nx[0] is z[0] False",
    "crumbs": [
      "Python Overview",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Identity & References</span>"
    ]
  },
  {
    "objectID": "arguments/index.html",
    "href": "arguments/index.html",
    "title": "7  Arguments",
    "section": "",
    "text": "Passing Arguments\nWhile sometimes we can write a function that takes no arguments, usually we’ll want to parameterize a function.\nWe call the variables that are passed in to a function arguments or parameters.\nIn some languages, you can pass arguments by value or by reference. In Python all values are “passed by assignment”.\nThis means mutability determines whether or not a function can modify a parameter in the outer scope.\nUnless otherwise specified, function arguments are required, and can be passed either by position or by name.\nAs we will see, we can also make optional arguments, as well as arguments that can only be passed by position or by name.",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#passing-arguments",
    "href": "arguments/index.html#passing-arguments",
    "title": "7  Arguments",
    "section": "",
    "text": "def func(a, b):\n    ...\n    \nx = 7\ny = [1, 2, 3]\nfunc(x, y)\n\n# you can think of the function starting with assignments to its parameters\na = x\nb = y\n\n\n\ndef calculate_cost(items, tax):\n    pass\n\n# all arguments passed by position\ncalculate_cost([\"salmon\", \"eggs\", \"bagels\"], 0.05)\n# tax passed by name\ncalculate_cost([\"salmon\", \"eggs\", \"bagels\"], tax=0.05)",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#optional-arguments",
    "href": "arguments/index.html#optional-arguments",
    "title": "7  Arguments",
    "section": "Optional Arguments",
    "text": "Optional Arguments\nPython allows default values to be assigned to function parameters.\nArguments with default values are not required. Passed in values will override default.\n\n# default arguments\ndef is_it_freezing(temp, is_celsius=True):\n    if is_celsius:\n        freezing_line = 0\n    else:\n        freezing_line = 32\n    return temp &lt; freezing_line\n\n\nprint(is_it_freezing(65))\nprint(is_it_freezing(30))\nprint(is_it_freezing(30, False))\nprint(is_it_freezing(-1, is_celsius=True))\n\nFalse\nFalse\nTrue\nTrue\n\n\nYou can have as many optional parameters as you wish, but they must all come after any required parameters.\n# intentional error\ndef bad_function(a, b=\"spam\", c):\n    pass",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#argument-matching",
    "href": "arguments/index.html#argument-matching",
    "title": "7  Arguments",
    "section": "Argument Matching",
    "text": "Argument Matching\nThere are two important rules in determining which arguments matched to which parameters:\n\nPositional arguments are matched from left to right.\nKeywords matched by name.\n\n\n# print() as an example [call help to see docstring]\nhelp(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\n\nprint(\"hello\", \"positional\", \"world\", sep=\"~\", end=\";\")\n\nhello~positional~world;",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#keyword-and-positional-only-arguments",
    "href": "arguments/index.html#keyword-and-positional-only-arguments",
    "title": "7  Arguments",
    "section": "keyword and positional-only arguments",
    "text": "keyword and positional-only arguments\nIncluding a bare * as a parameter means everything after can only be passed by keyword.\nFor example:\n\ndef request_page(\n    url,\n    verify,\n    cache=True,\n    retry_if_fail=False,\n    send_cookies=False,\n    https_only=True):\n    pass\n\nrequest_page(\"https://example.com\", True, False, True, False)\n# or did you mean\nrequest_page(\"https://example.com\", True, False, False, True)\n\n# instead, use keyword-only\ndef request_page(url, *, verify, follow_redirects=False, cache=True, send_cookies=False, https_only=True):\n    pass\n\n# forces keyword parameters\n# & allows you to change the function definition leter\nrequest_page(\"https://example.com\", verify=True)\nIncluding a bare / means everything beforehand is positional only:\n\ndef pos_only(x1, x2, /):\n    print(x1, x2)\n\n\npos_only(\"hello\", \"world\")\n\nhello world\n\n\n# ERROR: not allowed\npos_only(x1=\"hello\", x2=\"world\")",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#variable-length-arguments",
    "href": "arguments/index.html#variable-length-arguments",
    "title": "7  Arguments",
    "section": "Variable Length Arguments",
    "text": "Variable Length Arguments\nSometimes we want a function that can take any number of parameters (seen above in print).\nCollect arbitrary positional arguments with *param_name. (Often *args)\nCollect arbitrary named arguments with **param_name. (Often **kwargs)\n\n# *args example\n\ndef add_many(*args):\n    #print(args, type(args))\n    total = 0\n    for num in args:\n        total += num\n    return total\n\n\nadd_many(1, 2, 3, 4, 5)\n\n15\n\n\n\n# **kwargs example\n\ndef show_table(**kwargs):\n    for name, val in kwargs.items():\n        print(f\"{name:&gt;10} | {val}\")\n\n(Using advanced string formatting, see https://docs.python.org/3/library/string.html#formatstrings)\n\nshow_table(spam=100, eggs=12, other=42.0)\n\n      spam | 100\n      eggs | 12\n     other | 42.0\n\n\n\n# combining args & kwargs\ndef func(a, *args, n=5, **kwargs):\n    print(a, args, n, kwargs, sep=\"\\n\")\n\nfunc(1, 2, 3, 4, c=1, b=2)\n\n1\n(2, 3, 4)\n5\n{'c': 1, 'b': 2}\n\n\n# ERROR: why?\nfunc(x=7, x=8)\n\nfunc(1, 2, 3, rest=5)\n\n1\n(2, 3)\n5\n{'rest': 5}\n\n\n\n# some built-in functions work this way as well\nmax(1, 2, 3, 4)\n\n4",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#unpackingsplatting",
    "href": "arguments/index.html#unpackingsplatting",
    "title": "7  Arguments",
    "section": "Unpacking/Splatting",
    "text": "Unpacking/Splatting\n* and ** are also known as unpacking or splatting operators.\nWhen in a function signature, they coalesce arguments into a tuple and dict as we’ve seen.\nWhen used on a parameter when calling a function, they “unpack” the values from a sequence or dict.\n\ndef takes_many(a, b, c, d):\n    print(f\"{a=} {b=} {c=} {d=}\")\n\n# any iterable can be splatted\nthree = [\"A\", \"B\", \"C\"]\nfour = (1, 2, 3, 4)\nfive = (False, False, False, False, False)\n\n\ntakes_many(*four)\n\na=1 b=2 c=3 d=4\n\n\n\ntakes_many(*three, 4)\n\na='A' b='B' c='C' d=4\n\n\n\ntakes_many(4, *three)\n\na=4 b='A' c='B' d='C'\n\n\n# ERROR\ntakes_many(*five)\n\n# double-splat, unpack a dictionary into keyword args\nkeywords = {\"a\": \"sun\", \"c\": \"venus\", \"b\": \"mars\"}\ntakes_many(**keywords, d=\"moon\")\n\na='sun' b='mars' c='venus' d='moon'\n\n\n\nimport math\n\n\ndef distance(x1, y1, x2, y2):\n    \"\"\"\n    Find distance between two points.\n    \n    Inputs:\n        point1: 2-element tuple (x, y)\n        point2: 2-element tuple (x, y)\n\n    Output: Distance between point1 and point2 (float).\n    \"\"\"\n    return math.sqrt(math.pow(x2-x1, 2) + math.pow(y2-y1, 2))\n\n\n# we can use sequence-unpacking to turn tuples/lists into multiple arguments\na = (3, 4)\nb = [5, 5]\ndistance(*a, *b) # our 2 parameters become 4\n\n2.23606797749979\n\n\n\na = [1,2,3,4]\na[0:2], a[2:]\n\n([1, 2], [3, 4])\n\n\nhttp_params = {\"verify\": False, \"https_only\": True, \"timeout_sec\": 3}\nrequest_page(\"http://example.com\", **http_params)\n\ndef fn1(url, kw1=None, kw2=None, kw3=None):\n    ...\n    \ndef fn2(url, **kwargs):\n    if is_valid(url):\n        kwargs[\"additional_arg\"] = 4\n        return fn1(url, **kwargs)\n    return None",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#caveat-mutable-default-arguments",
    "href": "arguments/index.html#caveat-mutable-default-arguments",
    "title": "7  Arguments",
    "section": "Caveat: Mutable Default Arguments",
    "text": "Caveat: Mutable Default Arguments\nAn important rule to remember is that the declaration (def statement) of a function is only evaluated once, not every time the function is called.\nThis can lead to surprising behavior at first. It is important to understand & remember that only the inner-block of a function is executed on each call.\nThis is a common cause of bugs when a mutable is a part of the default arguments.\n\ndef add_many(item, n, base_list=[]):\n    print(\"adding to\", id(base_list))\n    base_list.extend([item] * n)\n    return base_list\n\n\n# passing in a list for base_list works as expected...\nanimals = [\"cow\"]\nprint(\"animals id\", id(animals))\nadd_many(\"bear\", 3, animals)\nadd_many(\"fish\", 5, animals)\nprint(animals)\n\nanimals id 4373547712\nadding to 4373547712\nadding to 4373547712\n['cow', 'bear', 'bear', 'bear', 'fish', 'fish', 'fish', 'fish', 'fish']\n\n\n\n# let's invoke without a base_list parameter\nanimals2 = add_many(\"dog\", 3)\nprint(animals2)\n\nadding to 4373423232\n['dog', 'dog', 'dog']\n\n\n\nanimals3 = add_many(\"turtle\", 4)\nprint(animals3)\n\nadding to 4373423232\n['dog', 'dog', 'dog', 'turtle', 'turtle', 'turtle', 'turtle']\n\n\n\nanimals2\n\n['dog', 'dog', 'dog', 'turtle', 'turtle', 'turtle', 'turtle']\n\n\n\nanimals2 is animals3\n\nTrue\n\n\nThe correct pattern is to avoid mutable defaults and instead assign a fresh mutable within the function as needed:\n\n# fixed version\ndef add_many(item, n, base_list=None):\n    if base_list is None:\n        base_list = []\n    base_list.extend([item] * n)\n    return base_list\n\n\ntemp = []\nprint(id(temp))\nreturned = add_many(\"fish\", 3)\nprint(returned)\nprint(id(returned))\n\n4373205952\n['fish', 'fish', 'fish']\n4373203008\n\n\nThis is not a bug per se, but a somewhat unfortunate side effect of how Python proceses statements and handles mutables.\nThere are times when it can be used to your advantage.\nIn the below example, the cache_dict persists between calls, allowing it to be used as a sort of cache/memory for the calling function. This should only be done thoughtfully and with ample commenting to explain the intended behavior.\n\ndef add_cached(x, y, cache_dict={}):\n    print(cache_dict)\n    if (x, y) not in cache_dict:\n        print(\"did calculation\", x, y)\n        cache_dict[x, y] = x + y\n    return cache_dict[x, y]\n\n\nadd_cached(4, 5)\n\n{}\ndid calculation 4 5\n\n\n9\n\n\n\nadd_cached(6, 10)\n\n{(4, 5): 9}\ndid calculation 6 10\n\n\n16\n\n\n\n# will use cache\nadd_cached(4, 5)\n\n{(4, 5): 9, (6, 10): 16}\n\n\n9",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "arguments/index.html#discussion",
    "href": "arguments/index.html#discussion",
    "title": "7  Arguments",
    "section": "Discussion",
    "text": "Discussion\n\nWhat types are args and kwargs?\n\n\nWhen should you use defaults, name-only, positional-only?\nYour function provides an “interface” for other programmers to interact with.\nProper choices help other programmers understand how to call your functions and should be chosen to make things easier for others.\nWhat would you prefer?\nget(\"https://example.com\", [500, 501, 503], 2.5, 2, False)\nor\nget(\"https://example.com\", retry_if=[500, 501, 503], timeout_sec=2.5, retries=2, verify_ssl=False)\nAlways consider “future you” among those hypothetical “other programmers”.\n\n\nExamples\n\n# two required args\ndef f(x, y):\n    print(f\"{x=} {y=}\")\n\n\n# a default argument\ndef g(x, y=3):\n    print(f\"{x=} {y=}\")\n\n\n# all default args\ndef h(x=\"abc\", y=3, z=True):\n    print(f\"{x=} {y=} {z=}\")\n\n\n# mixture of arg types\ndef j(x, *args, y=3, **kwargs):\n    print(f\"{x=} {y=} {args=} {kwargs=}\")\n\n\n# 1.\nf()\n\n# 2.\nf(x=1, 2)\n\n# 3.\nd = {\"x\": 0, \"y\": 0}\nf(**d)\n\n# 4.\ng(**d)\n\n# 5.\ng(**d, x=2)\n\n# 6.\ng(x=1)\n\n# 7.\nh()\n\n# 8.\nh(**d)\n\n# 9.\nh(z=False, **d)\n\n# 10.\nj(1, 2, 3, 4, 5, 6, 7)\n\n# 11.\nj(**d)\n\n# 12.\nt = (9, 9, 9, 9, 9, 9)\nj(t)\n\n# 13.\nj(*t)",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Arguments</span>"
    ]
  },
  {
    "objectID": "functional/index.html",
    "href": "functional/index.html",
    "title": "8  Functional Programming",
    "section": "",
    "text": "Procedural vs. Functional\nThe style of programming we’ve been doing is called imperative or procedural. Statements run in sequence and change a program’s state.\nFrom the “procedural” point of view, a function (procedure) is a set of statements that can be called more than once, we use parameters to make our procedures more reusable.\nThis is the “recipe” model of programming, a procedure is a recipe: a series of steps to follow to achieve a result.\nOur first paradigm, procedural programming leans heavily on the constructs we’ve seen: loops, conditionals, and the use of functions to break large procedures into smaller ones.\nSome languages make a distinction between procedures and functions. In Python we don’t make this distinction, but we will soon see another style of programming where we’ll think differently about how we use functions.\nBenefits of procedures (functions):",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functional Programming</span>"
    ]
  },
  {
    "objectID": "functional/index.html#procedural-vs.-functional",
    "href": "functional/index.html#procedural-vs.-functional",
    "title": "8  Functional Programming",
    "section": "",
    "text": "Encapsulation: package logic so “user” does not need to understand implementation, only interface.\nAvoid copy/paste to repeat same task: maximize code reuse and minimize redundancy.\nProcedural decomposition: split our program into subtasks (i.e., functions) with separate roles.\n\nSmall functions are easier to test, easier to write, and easier to refactor.\nMakes life easier for debugging, testing, doing maintenance on code.",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functional Programming</span>"
    ]
  },
  {
    "objectID": "functional/index.html#functional-programming",
    "href": "functional/index.html#functional-programming",
    "title": "8  Functional Programming",
    "section": "Functional Programming",
    "text": "Functional Programming\nLanguages like LISP, Haskell, and Racket are purely functional & differ significantly from procedural & object-oriented languages.\nFunctional programming uses a definition of functions more compatible with the mathematical definition. Instead of the recipe model of procedural programming, mathematical functions take input(s) and return an output.\nThese functions do not have the concept of “state”: the same call with the same parameters always results in the same result. that is, calling a function in math creates a mapping from inputs to outputs.\nWhen we call sin(x) we do not speak of it modifying its inputs, just returning a value.\nSimilarly, when we workin a functional style we’ll often write smaller functions that we chain together, instead of long procedures that rely on internal state.\nPython has many features that stem from pure functional languages & support functional programming:\n\nFunctions as first class objects\nLambda expressions\nmap/filter\nfunctools\ncomprehensions",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functional Programming</span>"
    ]
  },
  {
    "objectID": "functional/index.html#functions-as-first-class-objects",
    "href": "functional/index.html#functions-as-first-class-objects",
    "title": "8  Functional Programming",
    "section": "Functions as “first-class objects”",
    "text": "Functions as “first-class objects”\nA key feature of Python that makes it possible to write code in the functional style is the fact that functions are objects. (Everything in Python is an object.)\nThis means functions don’t have special rules about how they can be used compared to other types, any variable can reference a function. (Remember, a variable is an association between a name & object.)\n\ndef echo(message):\n    print(message, message)\n    \nprint(f\"echo = {echo}\")\nprint(f\"type(echo) = {type(echo)}\")\n\necho = &lt;function echo at 0x1042804a0&gt;\ntype(echo) = &lt;class 'function'&gt;\n\n\n\n# we can assign names to objects, including functions\nx = echo\nx(\"hello\")\n\nhello hello\n\n\n\nid(x), id(echo)\n\n(4364698784, 4364698784)\n\n\n\n# we can also store functions in other types, like list\nfunc_list = [print, echo, print, echo]\nfor i, func in enumerate(func_list):\n    func(i)\n\n0\n1 1\n2\n3 3\n\n\n\n# dictionaries too\nfunc_mapping = {False: print, True: echo}\n\nprint_twice = True\nfunc_mapping[True](\"twice\")\n\nprint_twice = False\nfunc_mapping[print_twice](\"once\")\n\ntwice twice\nonce\n\n\n\n# we can pass functions into other functions\ndef add(a, b):\n    return a + b\n\ndef sub(a, b):\n    return a - b\n\ndef perform_op(op_func, a, b):\n    return op_func(a, b)\n\nprint(\"add, 3, 4 = \", perform_op(add, 3, 4))\nprint(\"sub, 3, 4 = \", perform_op(sub, 3, 4))\n\nadd, 3, 4 =  7\nsub, 3, 4 =  -1\n\n\n\n# and we can return functions from other functions\ndef get_op(name):\n    if name == \"div\":\n        def f(a, b):\n            return a / b\n    elif name == \"mod\":\n        def f(a, b):\n            return a % b\n    return f\n\n\nfn = get_op(\"mod\")\nfn(100, 5)\n#perform_op(fn, 10, 3)\n\n0\n\n\n\nsorted example\nIt isn’t uncommon in Python for functions to take other functions, let’s look at sorted\n\nhelp(sorted)\n\nHelp on built-in function sorted in module builtins:\n\nsorted(iterable, /, *, key=None, reverse=False)\n    Return a new list containing all items from the iterable in ascending order.\n\n    A custom key function can be supplied to customize the sort order, and the\n    reverse flag can be set to request the result in descending order.\n\n\n\n\nd = [(\"Nick\", 1), (\"Nick\", -100), (\"Yusong\", 9000), (\"Emma\", 100)]\n\ndef second_key(item):\n    return item[1]\n\ndef negate(item):\n    return -item[1]\n\n\n# default sort\nsorted(d)    \n\n[('Emma', 100), ('Nick', -100), ('Nick', 1), ('Yusong', 9000)]\n\n\n\nsorted(d, key=negate)\n\n[('Yusong', 9000), ('Emma', 100), ('Nick', 1), ('Nick', -100)]\n\n\n\nsorted(d, key=second_key)\n\n[('Nick', -100), ('Nick', 1), ('Emma', 100), ('Yusong', 9000)]",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functional Programming</span>"
    ]
  },
  {
    "objectID": "functional/index.html#lambda-functions",
    "href": "functional/index.html#lambda-functions",
    "title": "8  Functional Programming",
    "section": "lambda functions",
    "text": "lambda functions\nPython also provides another way to generate function objects.\nThese are called lambda functions (aka anonymous functions), which:\n\nAre expressions that return a function object that can be called later without providing a name (hence ``anonymous”)\nCan be used in places where def statement is not syntactically legal (inside a literal list, inlined as a function argument, etc.)\n\nThe body of an lambda function is a single expression, not a block of statements. The body is similar to a return statement in a def statement.\n\nlambda arg1, arg2: expression\n\n# essentially the same as\n\ndef __(arg1, arg2):\n    return expression\n(0 or more arguments, but must have an expression)\n\nReminder: expressions vs. statements\nRemember that expressions evaluate to a value, and can be assigned to a variable.\nExpresssions are valid in assignment, function calls, sequence values, etc. (Anywhere a value is needed.)\nWhen it comes to lambda: * a lambda defines a function that maps input to a single expression, def can be used if statements are needed * a lambda is itself an expression, it can be used anywhere other expresssions are needed\nAs an expression, lambda can be used as a parameter:\n\nperform_op(lambda a, b: a * b, 5, 6)\n\n30\n\n\n\nwords = [\"abc\", \"Abb\", \"aaa\", \"ABC\", \"AAB\"]\nsorted(words)\n\n['AAB', 'ABC', 'Abb', 'aaa', 'abc']\n\n\n\nsorted(words, key=lambda s: s.upper())\n\n['aaa', 'AAB', 'Abb', 'abc', 'ABC']\n\n\n\n# can be assigned to a variable\nmul = lambda a, b: a * b\nmul(5, 6)\n\n# same as\ndef mul2(a, b):\n    return a * b\n\n\ntype(mul), type(mul2)\n\n(function, function)\n\n\nGeneral rule: If you’re giving a lambda a name, use a function.",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functional Programming</span>"
    ]
  },
  {
    "objectID": "functional/index.html#functional-methods",
    "href": "functional/index.html#functional-methods",
    "title": "8  Functional Programming",
    "section": "Functional Methods",
    "text": "Functional Methods\nPython has several built in methods that are useful when writing programs with a functional mindset.\nmap, filter, functools\n\nmap\nmap(function, iterable1, [...iterableN])\nReturns a new iterable that calls function with parameters from iterable1 ... iterableN.\n\ndef add_two(x):\n    print(\"called add_two\", x)\n    return x + 2\n\nfor x in map(add_two, [1, 2, 3]):\n    print(x)\n\ncalled add_two 1\n3\ncalled add_two 2\n4\ncalled add_two 3\n5\n\n\n\nhelp(map)\n\nHelp on class map in module builtins:\n\nclass map(object)\n |  map(function, iterable, /, *iterables)\n |\n |  Make an iterator that computes the function using arguments from\n |  each of the iterables.  Stops when the shortest iterable is exhausted.\n |\n |  Methods defined here:\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __next__(self, /)\n |      Implement next(self).\n |\n |  __reduce__(self, /)\n |      Return state information for pickling.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n\n\n\n\nx = list(map(add_two, [1, 2, 3]))\nprint(x)\n\ncalled add_two 1\ncalled add_two 2\ncalled add_two 3\n[3, 4, 5]\n\n\n\n# commonly used with lambdas\nfor x in map(lambda x, y: x+y, (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"]):\n    print(x)\n\nA!\nB?\nC.\n\n\n\n# number of parameters must match number of iterables\nfor x in map(lambda x, y, z: x+(y*z), (\"A\", \"B\", \"C\"), [\"!\", \"?\", \".\"], [2, 3, 4]):\n    print(x)\n\nA!!\nB???\nC....\n\n\n\n# operator module contains all of the common operators in function form\nimport operator\noperator.sub(20, 5)\n\n15\n\n\nmap returns a special kind of iterable, can be wrapped in things other than list.\n\nset(map(operator.sub, [20, 19], [10, 9]))\n\n{10}\n\n\n\n# can use anywhere you can use an iterable\ntuple(map(lambda x: x * 3, (\"A\", \"B\", \"C\")))\n\n('AAA', 'BBB', 'CCC')\n\n\n\n\nfilter\nfilter(function, iterable)\nreturns an iterable that contains all items from iterable for which function(item) returns True\nWe call this kind of function a predicate.\n\nlist(filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\", \"\"]))\n\n['ABC', 'XYZ']\n\n\n\nlist(map(lambda s: s*2, filter(str.isupper, [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n\n['ABCABC', 'XYZXYZ']\n\n\n\nlist(filter(str.isupper, map(lambda s: s.title(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n\n['A']\n\n\n\nlist(map(lambda s: s.lower(), filter(lambda s: s.isupper(), [\"a\", \"ABC\", \"AbCdeF\", \"XYZ\"])))\n\n['abc', 'xyz']\n\n\n\n\nfunctools\nhttps://docs.python.org/3/library/functools.html\n\nimport functools\n[name for name in dir(functools) if name[0].islower()]\n\n['cache',\n 'cached_property',\n 'cmp_to_key',\n 'get_cache_token',\n 'lru_cache',\n 'namedtuple',\n 'partial',\n 'partialmethod',\n 'recursive_repr',\n 'reduce',\n 'singledispatch',\n 'singledispatchmethod',\n 'total_ordering',\n 'update_wrapper',\n 'wraps']\n\n\nfunctools.reduce(function, iterable[, initializer])\nApply function to pairs of items successively and return a single value as the result. You can optionally specify the initial value.\n\nimport functools \nimport operator \n\n# accumulator = 0\n# for item in my_list:\n#     accumulator += item\n\n# 1st iteration: Call operator.add(1,2) -&gt; 3 \n# 2nd iteration: Call operator.add(3,3) -&gt; 6 \n# 3rd iteration: Call operator.add(6,4) -&gt; 10 \n# final result = 10 \nfunctools.reduce(operator.add, [1,2,3,4])\n\n10\n\n\n\nnames = [\"Ben\", \"Martha\", \"Susan\"]\n# 1st iteration: call f(0, \"Ben\") -&gt; 0 + len(\"Ben\") -&gt; 3\n# 2nd iteration: call f(3, \"Martha\") -&gt; 3 + len(\"Martha\") -&gt; 9\n# 3rd iteration: call f(9, \"Susan\") -&gt; 9 + len(\"Susan\") -&gt; 14\nfunctools.reduce(lambda accumulator, new_val: accumulator + len(new_val), \n                 names, \n                 0)\n\n14\n\n\n\n# What happens if you pass in an initial value \n# 1st iteration: Call operator.mul(2,1) -&gt; 2 \n# 2nd iteration: Call operator.mul(2,2) -&gt; 4 \n# 3rd iteration: Call operator.mul(4,3) -&gt; 12 \n# 4th iteration: Call operator.mul(12,4) -&gt; 48 \n# Final result = 48 \nfunctools.reduce(operator.mul, [1,2,3,4], 2)\n\n48\n\n\n\nfunctools.reduce(lambda a,b: a+b, [1, 2, 3])\n\n6\n\n\nfunctools.partial(func, *args, **kwargs)\nfunctools.partial returns a new function that “binds” any passed args & kwargs, and leaves other parameters unbound.\n\nimport operator\noperator.mul(2, 10)\n\n20\n\n\n\nimport functools\nnegate = functools.partial(operator.mul, -1)\nnegate(5)\n\n-5\n\n\n\nlist(map(negate, [1, 2, 3, 4]))\n\n[-1, -2, -3, -4]\n\n\n\ndef calls_twice(f):\n    print(f())\n    print(f())\n    \n\ng = functools.partial(operator.mul, 4, 4)\n#print(g())\ncalls_twice(g)\n\n16\n16\n\n\n\nprint_ex = functools.partial(print, sep=\"!\")\nprint_ex(\"a\", \"b\", \"c\")\n\na!b!c\n\n\n# ERROR: parameters must be valid\nprint_foo = functools.partial(print, foo=\"x\")\n\n# another way to deal with functions we're calling with the same args repeatedly\ndef request_page(url, verify, cache=True, send_cookies=False, https_only=True):\n    pass\n\nsecure_request = functools.partial(request_page, verify=True, https_only=True)\n\n\nsecure_request(\"\", verify=False)",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functional Programming</span>"
    ]
  },
  {
    "objectID": "comprehensions/index.html",
    "href": "comprehensions/index.html",
    "title": "9  Comprehensions",
    "section": "",
    "text": "List Comprehensions\nComprehensions are a special kind of expression in Python that perform significant work within a list, dict, set literal.\nIt is common to have code that converts one iterable to a new iterable, often building one element at a time:\nComprehensions allow us to reduce the above to a single line. Additionally, they can be much more efficient than building a list, dict, or set one element at a time. assuming we want to use the new_iterable.\nThis is not true if you are just trying to iterate: if you just want to do work in a for loop, continue to use a for loop as you have been!\nCreate a new list from another iterable.\nRemember that we can take any iterable and convert it to a list by calling list():\ns = \"hello world\"\nlist(s)\n\n['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']\nThe simplest list comprehension does the same thing (you should prefer list if this is all you are doing):\nt = (1, 2, 3, 4, 5)\n[i for i in t]\n\n[1, 2, 3, 4, 5]\nThis looks a bit like an inside-out for loop:\nThe for var in iterable portion declares a new temporary variable for iteration, just like a traditional for loop, but The benefit comes in when we start modifying the expression portion:\n[i**2 for i in t]\n\n[1, 4, 9, 16, 25]\n[c.upper() for c in s]\n\n['H', 'E', 'L', 'L', 'O', ' ', 'W', 'O', 'R', 'L', 'D']\nThese list comprehensions map values from the original iterable to new values, the same as map!\nBut they do not need to be one-to-one, we can remove some items conditionally with one more optional clause:\ndef isvowel(c):\n    return c in \"aeiou\"\n\n[c.upper() for c in s if isvowel(c)]\n# or [c.upper() for c in s if c in \"aeiou\"]\n\n['E', 'O', 'O']\nThis can replace filter!",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Comprehensions</span>"
    ]
  },
  {
    "objectID": "comprehensions/index.html#list-comprehensions",
    "href": "comprehensions/index.html#list-comprehensions",
    "title": "9  Comprehensions",
    "section": "",
    "text": "# basic list comprehension syntax\nnew_list = [expression for var in iterable]\n\n\n\n\n\n# full list comprehension syntax with optional if clause\nnew_list = [expression for var in iterable if condition]\n\n\n\nNested Comprehensions\nSince comprehensions are expressions, and the first clause needs to be an expression, we can nest comprehensions:\n\n# possible to nest comprehensions, but beware readability\nfaces = (\"K\", \"Q\", \"J\")\nsuits = (\"♠\", \"♣\", \"♦\", \"♥\")\n[(face + suit) for face in faces for suit in suits if face != \"K\"]\n\n['Q♠', 'Q♣', 'Q♦', 'Q♥', 'J♠', 'J♣', 'J♦', 'J♥']",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Comprehensions</span>"
    ]
  },
  {
    "objectID": "comprehensions/index.html#set-dict-comprehensions",
    "href": "comprehensions/index.html#set-dict-comprehensions",
    "title": "9  Comprehensions",
    "section": "Set & Dict Comprehensions",
    "text": "Set & Dict Comprehensions\nIt is also possible to make set and dict comprehensions by using {}.\n\n# powers of two set\n{2 ** n for n in [1,1,2,2,3,3,3,4,4,4]}\n\n{2, 4, 8, 16}\n\n\n\n# powers of two mapping\n{n+2: n+1 for n in range(5) if n &gt; 0}\n\n{3: 2, 4: 3, 5: 4, 6: 5}\n\n\nIf the expression contains a : (colon), result is a dictionary.",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Comprehensions</span>"
    ]
  },
  {
    "objectID": "comprehensions/index.html#thinking-in-list-comprehensions",
    "href": "comprehensions/index.html#thinking-in-list-comprehensions",
    "title": "9  Comprehensions",
    "section": "Thinking in List Comprehensions",
    "text": "Thinking in List Comprehensions\nHere is a way of thinking about list comprehensions that may help you write more complex comprehensions in a natural way:\n\ndef make_powers_lc(n, inputs):\n    \"\"\"\n    Given list of inputs, return each input raised to the 1st-Nth power\n    \n    e.g.\n    &gt;&gt;&gt; make_powers_lc(4, range(10))\n    [[0, 0, 0, 0],\n     [1, 1, 1, 1],\n     [2, 4, 8, 16],\n     [3, 9, 27, 81],\n     [4, 16, 64, 256],\n     [5, 25, 125, 625],\n     [6, 36, 216, 1296],\n     [7, 49, 343, 2401],\n     [8, 64, 512, 4096],\n     [9, 81, 729, 6561]]\n    \"\"\"\n\n\n# 1) start with shape: \n# Output will be a list of list of ints, \n# so create simplest version of that\ndef make_powers_lc(n, inputs):\n    return [[1]]\nmake_powers_lc(4, range(10))\n\n[[1]]\n\n\n\n# 2) expand outer list comprehension to have correct number of elements\n# using inputs as foundation, we haven't modified the first term yet\ndef make_powers_lc(n, inputs):\n    return [[1] for x in inputs]\nmake_powers_lc(4, range(10))\n\n[[1], [1], [1], [1], [1], [1], [1], [1], [1], [1]]\n\n\n\n# 3) Now expand inner list to have correct number of elements.\ndef make_powers_lc(n, inputs):\n    return [[1 for y in range(n)] for x in inputs]\nmake_powers_lc(4, range(10))\n\n[[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]]\n\n\n\n# 4) Fix initial term to do calculation\ndef make_powers_lc(n, inputs):\n    return [[x**y for y in range(n)] for x in inputs]\nmake_powers_lc(4, range(10))\n\n[[1, 0, 0, 0],\n [1, 1, 1, 1],\n [1, 2, 4, 8],\n [1, 3, 9, 27],\n [1, 4, 16, 64],\n [1, 5, 25, 125],\n [1, 6, 36, 216],\n [1, 7, 49, 343],\n [1, 8, 64, 512],\n [1, 9, 81, 729]]\n\n\n\n# 5) With correct shape, make modifications to ranges/etc. as needed\ndef make_powers_lc(n, inputs):\n    return [[x**y for y in range(1, n+1)] for x in inputs]\nmake_powers_lc(4, range(10))\n\n[[0, 0, 0, 0],\n [1, 1, 1, 1],\n [2, 4, 8, 16],\n [3, 9, 27, 81],\n [4, 16, 64, 256],\n [5, 25, 125, 625],\n [6, 36, 216, 1296],\n [7, 49, 343, 2401],\n [8, 64, 512, 4096],\n [9, 81, 729, 6561]]",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Comprehensions</span>"
    ]
  },
  {
    "objectID": "generators/index.html",
    "href": "generators/index.html",
    "title": "10  Generators",
    "section": "",
    "text": "range revisited\nWhat does range return?\nWe can see that it is iterable, perhaps a list or tuple?\nHow much memory does a list of 1 billion integers take?\n(4 bytes/int) * 1B = 4GB of RAM?!\nKeep in mind, we’re only using one of these integers at a time!\nThis wasteful behavior was indeed the case in Python 2, range had to allocate all of the needed memory at once.\nFortunately in Python 3, a range is lazily-evaluated, but how?\nrg = range(1000)\nprint(rg, type(rg))\n\nrange(0, 1000) &lt;class 'range'&gt;",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "generators/index.html#range-revisited",
    "href": "generators/index.html#range-revisited",
    "title": "10  Generators",
    "section": "",
    "text": "# Tip: you can separate digits with _ for readability (Python ignores the _)\nfor i in range(1_000_000_000):\n    print(i)\n    if i == 3:\n        break",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "generators/index.html#generators",
    "href": "generators/index.html#generators",
    "title": "10  Generators",
    "section": "Generators",
    "text": "Generators\nGenerators are a special type of object that is iterable, but not a collection.\nA generator object yields a single result at a time, which means we can use far less memory in most cases, especially when we won’t use the entire iterable.\nToday we’ll see two ways to write generators: generator functions, and generator expressions.",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "generators/index.html#generator-expressions",
    "href": "generators/index.html#generator-expressions",
    "title": "10  Generators",
    "section": "Generator Expressions",
    "text": "Generator Expressions\nWhen we introduced comprehensions we mentioned that they only made sense to use if you are planning to use the entire iterable.\n\n# this allocates a list of 100 integers\npowers_of_two = [2**x for x in range(100)]\n\n# this is a wasteful way to use a list comprehension, only one value is needed at a time\nfor num in powers_of_two:\n    print(num)\n    if num &gt; 1_000_000:\n        break\n\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n1048576\n\n\nThere is one more expression that uses the comprehension-style syntax, and that is the generator expression.\n\n# parenthesis () instead of square brackets [], creates a generator expression\npowers_of_two_gen = (2**x for x in range(100))\n\n# what is this type?\nprint(powers_of_two_gen)\nprint(type(powers_of_two_gen))\n\n# iteration works as you'd expect\nfor num in powers_of_two_gen:\n    print(num)\n    if num &gt; 1_000_000:\n        break\n\n&lt;generator object &lt;genexpr&gt; at 0x10bf95630&gt;\n&lt;class 'generator'&gt;\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n1048576\n\n\nThe generator expression creates a generator object, which, like range, is iterable, but not a collection.\n\nIteration Revisited\nIteration in Python is achieved via a protocol, one or more special methods that describe how a given type can be used in a certain context.\nWe’ll explore these protocols in more detail later in the course.\nIteration depends on two functions: iter() and next().\niter() takes an iterable and returns an iterator, a kind of object we usually don’t interact with directly.\nAny iterable can be passed into next(), which will return the next value, or raise a StopIteration error if the iterable is exhausted.\nfor i in iterable:\n    print(i)\n\n# can be rewritten as\niterator = iter(iterable)\nwhile True:\n    try:\n        i = next(iterator)\n        print(i)\n    except StopIteration:\n        # this break only runs when next runs out\n        break\n\n# we usually don't see the iterator!\nWhile we usually don’t see the iterator, a generator is both iterable and iterator, so we can use next on them:\n\npower_of_three = (3**n for n in range(5))\nprint(next(power_of_three))\nprint(next(power_of_three))\nprint(next(power_of_three))\nprint(next(power_of_three))\nprint(next(power_of_three))\n\n# one more call would raise an error!\ntry:\n    print(next(power_of_three))\nexcept StopIteration:\n    print(\"done!\")\n\n1\n3\n9\n27\n81\ndone!",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "generators/index.html#generator-functions",
    "href": "generators/index.html#generator-functions",
    "title": "10  Generators",
    "section": "Generator Functions",
    "text": "Generator Functions\nWhile generator expressions are one way to create simple generators, they have the same limitations that comprehensions have: they can have a single expression for each input, and use a single conditional.\nWe can also create generators by writing generator functions. These are special functions that return the generator type.\nNote that this is the same type as the generators we’ve already introduced, just a different way to create them.\nA function that contains the yield keyword, is automatically a generator function. Let’s rewrite one of our earlier examples as a function:\n\ndef powers_of_2(limit):\n    for n in range(limit):\n        yield 2**n\n\nCalling this function returns a generator:\n\np2g = powers_of_2(10)\nprint(p2g)\nprint(type(p2g))\n\n&lt;generator object powers_of_2 at 0x10bf95150&gt;\n&lt;class 'generator'&gt;\n\n\nWe can iterate over it with a for loop:\n\nfor x in p2g:\n    print(x)\n\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n\n\nAll generators can only be consumed once, so an attempt to call next() leads to an error:\n\ntry:\n    print(next(p2g))\nexcept Exception as e:\n    print(repr(e))\n\nStopIteration()\n\n\nGenerator functions do give us an option that expressions did not, we can create a fresh generator by calling the function again:\n\ng1 = powers_of_2(10)\ng2 = powers_of_2(10)\n\n# g1 and g2 are independent, we can move one forward,\n# and it doesn't affect the other\n\nprint(\" g1\", next(g1))\nprint(\" g1\", next(g1))\nprint(\" g1\", next(g1))\nprint(\" g2\", next(g2))\nprint(\" g2\", next(g2))\nprint(\" g1\", next(g1))\n\n g1 1\n g1 2\n g1 4\n g2 1\n g2 2\n g1 8\n\n\nGenerator functions can contain multiple yield, each yield pauses execution of the generator. The internal state of the function remains intact, unlike return.\n\ndef simple_generator_func():\n    print(\"start\")\n    yield 1\n    print(\"still running\")\n    yield 2\n    print(\"one more\")\n    yield 3\n\n\ng = simple_generator_func()\n\nprint(\"got (first)\", next(g))\n\nprint(\"--before loop--\")\n\nfor x in g:\n    print(\"got\", x)\n\nstart\ngot (first) 1\n--before loop--\nstill running\ngot 2\none more\ngot 3\n\n\n\nInfinite Generators\nGenerators do not need to ever actually exit, let’s create an abstraction for our powers-of-n generators:\n\ndef powers_of_n(n):\n    i = 0\n    while True:\n        yield n ** i\n        i += 1\n\n\npow5 = powers_of_n(5)\n\nprint(next(pow5))\nprint(next(pow5))\nprint(next(pow5))\nprint(next(pow5))\nprint(next(pow5))\n\n1\n5\n25\n125\n625\n\n\nThis code works because we’re only asking for one more iteration of the loop, each time we call next the code in the function runs until it hits the next yield.\nWe can also use this in a loop if we’re careful to break!:\n\nfor x in powers_of_n(7):\n    print(x)\n    # it is up to the calling loop to break, without this we run forever!\n    if x &gt; 10000:\n        break \n\n1\n7\n49\n343\n2401\n16807",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "generators/index.html#discussion-benefits-of-generators",
    "href": "generators/index.html#discussion-benefits-of-generators",
    "title": "10  Generators",
    "section": "Discussion: Benefits of Generators",
    "text": "Discussion: Benefits of Generators\n\nExercise: Write your own range\n\n# there is a third optional parameter to range, the *step*\nfor x in range(3, 10, 2):\n    print(x)\n\n3\n5\n7\n9\n\n\ndef new_range(lower_bound, upper_bound, step=1):\n    pass",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Generators</span>"
    ]
  },
  {
    "objectID": "scope/index.html",
    "href": "scope/index.html",
    "title": "11  Scope",
    "section": "",
    "text": "Python’s four scopes\nThe above code has three different variables named x, each independent from one another.\nTo determine which name print(x) is referring to, we have to understand scope.\nScope in Python is determined by the location of an assignment, or presence in a parameter list.\nWe’ve dealt with two types of scope so far:\nAnything declared inside of a function, including its parameter names, are considered local to that function.\nAssignment statements create or change local names by default.\nThe scope can be\nLEGB\nIf the name is not found after this search, an exception is raised.",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "scope/index.html#pythons-four-scopes",
    "href": "scope/index.html#pythons-four-scopes",
    "title": "11  Scope",
    "section": "",
    "text": "Local: Scope of the current function.\nEnclosing: Scope of any enclosing functions.\nGlobal (sometimes called Module): Scope of the file.\nBuilt-in: Built-ins.",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "scope/index.html#local-vs.-global",
    "href": "scope/index.html#local-vs.-global",
    "title": "11  Scope",
    "section": "Local vs. Global",
    "text": "Local vs. Global\nLocal scope refers to variables in the current function, global/module scope refers to anything at the top-level of a file:\n\n# demo.py\n\nx = 10000     # global scope\n\ndef f(x, y):\n    z = 3\n    print(\"locals=\", locals())\n    print(\"global names\", {k for k in globals() if k[0] != \"_\"})\n\nf(1, 2)\n\nlocals= {'x': 1, 'y': 2, 'z': 3}\nglobal names {'exit', 'quit', 'f', 'Out', 'In', 'open', 'ojs_define', 'x', 'get_ipython'}\n\n\nThe functions locals() and globals() can be used to view these for debugging purposes.\n\nModifying a global variable within a function\nIt is possible for a function to modify a global mutable:\n\nd = {\"key\": 123}\n\ndef f():\n    d[\"key\"] = 456\n\nf()\n\n# changes to d persist outside function, mutability!\nprint(d)\n\n{'key': 456}\n\n\nDespite being possible, this is generally a bad idea, mutability is why using globals makes programs hard to follow.\nWhat if we instead try to change an immutable via reassignment?\n\ns = \"hello \"\n\ndef f():\n    s += \" world!\"   # attempt to both use & reassign s\n\ntry:\n    f()\nexcept Exception as e:\n    print(repr(e))\n\nUnboundLocalError(\"cannot access local variable 's' where it is not associated with a value\")\n\n\n\n\nglobal\nVery very occasionally, we want to allow for this:\n\ns = \"hello \"\n\ndef f():\n    # indicates that the name s within the function refers to the global s\n    global s\n    s += \" world!\"   # attempt to both use & reassign s\n\ntry:\n    f()\n    print(\"s after function:\", s)\nexcept Exception as e:\n    print(repr(e))\n\ns after function: hello  world!\n\n\nThis is a bad idea for the same reason that modifying the mutable was, tracking changes to global state makes it very hard to reason about functions.\n# this seems like a reasonably safe use of globals\nNUM_ENTRIES = 1000\nSECRET_KEY = \"1899232-32kldfj3\"\nIGNORED_KEYS = [\"middle_name\", \"old_badge_num\"]\n\n# looking at this code, one assumes that it'd be possible to reorder/parallelize\n# clean_data_part1 and part2, but if the author of these functions for some\n# reason used `global`, or modifies the list IGNORED_KEYS, there are hard-to-observe\n# actions that can lead to subtle bugs\ndata = read_data()\ndata = clean_data_part1(data)\ndata = clean_data_part2(data)\npublish_data(data)",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "scope/index.html#builtins",
    "href": "scope/index.html#builtins",
    "title": "11  Scope",
    "section": "builtins",
    "text": "builtins\nBuilt-in scope is above global scope, if a variable does not exist at the global/module level, a final scope is searched.\nWhen you use functions like print(), dict(), or map(), those are from the builtin scope:\n\nfor name in dir(__builtins__):\n    if name[0].islower():\n        print(name)\n\nabs\naiter\nall\nanext\nany\nascii\nbin\nbool\nbreakpoint\nbytearray\nbytes\ncallable\nchr\nclassmethod\ncompile\ncomplex\ncopyright\ncredits\ndelattr\ndict\ndir\ndisplay\ndivmod\nenumerate\neval\nexec\nexecfile\nfilter\nfloat\nformat\nfrozenset\nget_ipython\ngetattr\nglobals\nhasattr\nhash\nhelp\nhex\nid\ninput\nint\nisinstance\nissubclass\niter\nlen\nlicense\nlist\nlocals\nmap\nmax\nmemoryview\nmin\nnext\nobject\noct\nopen\nord\npow\nprint\nproperty\nrange\nrepr\nreversed\nround\nrunfile\nset\nsetattr\nslice\nsorted\nstaticmethod\nstr\nsum\nsuper\ntuple\ntype\nvars\nzip",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "scope/index.html#enclosing-scope",
    "href": "scope/index.html#enclosing-scope",
    "title": "11  Scope",
    "section": "Enclosing Scope",
    "text": "Enclosing Scope\nRemember, our scope lookup order is LEGB: local, enclosing, global, built-in.\nEnclosing scope exists when we have nested functions:\n\n# here we see that f2 can access f1's y, and that there\n# are two distinct x variables, inside f1 and f2\ndef f1():\n    x = \"OUTER\"\n    y = \"from enclosing\"\n    def f2():\n        x = \"INNER\"\n        print(\"y=\", y)\n        print(\"inside f2 x=\", x)\n    print(\"inside f1 before f2 has been called x=\", x)\n    f2()\n    print(\"inside f1 after f2 has been called\", x)\n\nf1()\n\ninside f1 before f2 has been called x= OUTER\ny= from enclosing\ninside f2 x= INNER\ninside f1 after f2 has been called OUTER\n\n\n\nClosures\nWhen a function is nested inside another function, future calls can continue to access the original enclosing scope.\nThe combination of a nested function and its enclosing scope is called a closure.\n\ndef make_func(n):\n    def f(x):\n        # n: locally scoped to make_func() &lt; enclosing scope\n        # x: locally scoped to f()\n        # we are using the n from the enclosing scope\n        return x ** n \n    return f\n\n\nto_the_third = make_func(3)\nto_the_third(10) # remembers the n from the enclosing scoped\n\n1000\n\n\n\nsquared = make_func(2)\nsquared(10)  # has it's own distinct n from it's closure\n\n100\n\n\nWe can use this to create cache behavior:\n\nimport math\n\ndef make_cached_calc():\n    prior_calls = {}\n    \n    def calc(x, y):\n        # this portion only runs if we haven't seen x, y before\n        if (x, y) not in prior_calls:\n            print(f\"doing computation on {x} and {y}...\")\n            # do 'expensive' computation\n            answer = math.sin(x) + math.exp(y)\n            # save to cache\n            prior_calls[x, y] = answer\n\n        # always runs\n        print(\"cache=\", prior_calls)\n        # retrieve from cache, will be present by this point\n        return prior_calls[x, y]\n\n    # return function w/ enclosing scope of prior_calls    \n    return calc\n\n# obtain inner function\ndo_computation = make_cached_calc()\n\n\ndo_computation(1, 2)\n\ndoing computation on 1 and 2...\ncache= {(1, 2): 8.230527083738547}\n\n\n8.230527083738547\n\n\n\ndo_computation(1, 2)\n\ncache= {(1, 2): 8.230527083738547}\n\n\n8.230527083738547\n\n\n\ndo_computation(0.5, 0.7)\n\ndoing computation on 0.5 and 0.7...\ncache= {(1, 2): 8.230527083738547, (0.5, 0.7): 2.4931782460746796}\n\n\n2.4931782460746796\n\n\n\n# has own enclosure\ndo_computation2 = make_cached_calc()\ndo_computation2(1, 2)\n\ndoing computation on 1 and 2...\ncache= {(1, 2): 8.230527083738547}\n\n\n8.230527083738547\n\n\n\n\nnonlocal\nThere is also a nonlocal, which allows modifying a variable declared in enclosing scope.\nLike global, it is placed inside the inner function, allowing access to an enclosing variable (not vice-versa!).\ndef create_counter_func():\n    counter = 0\n    def f():\n        # gives us permission to access the enclosing counter\n        nonlocal counter\n        counter += 1\n        print(f\"called {counter} times\")\n    return f\n\ng = create_counter_func()\nh = create_counter_func()",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "decorators/index.html",
    "href": "decorators/index.html",
    "title": "12  Decorators",
    "section": "",
    "text": "Decorators\nA common pattern in functional programs, are functions that are built to “wrap” other functions.\nThis pattern allows one to attach behavior before or after a function call, making it possible to:\n# a simple example\ndef print_before_and_after(func):\n    def newfunc(*args, **kwargs):\n        print(\"BEFORE\", func)\n        func(*args, **kwargs)\n        print(\"AFTER\", func)\n    return newfunc\nThis function print_before_and_after is called a decorator, it takes a function, and returns a new function.\nTypically this new function will call the original function, but that is not required!\ndef inner(a, b, c):\n    print(\"inner function\", a, b, c)\nwrapped_inner = print_before_and_after(inner)\n\nwrapped_inner(1, 2, 3)\n\nBEFORE &lt;function inner at 0x1088e0360&gt;\ninner function 1 2 3\nAFTER &lt;function inner at 0x1088e0360&gt;\n# often we want to replace the function altogether\ninner = print_before_and_after(inner)\ninner(1, 2, 3)\n\nBEFORE &lt;function inner at 0x1088e0360&gt;\ninner function 1 2 3\nAFTER &lt;function inner at 0x1088e0360&gt;",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Decorators</span>"
    ]
  },
  {
    "objectID": "decorators/index.html#decorators",
    "href": "decorators/index.html#decorators",
    "title": "12  Decorators",
    "section": "",
    "text": "log function calls\nvalidate or modify arguments (before)\nvalidate or modify return value (after)\ncheck performance or other characteristics of the function (e.g. time elapsed)\nreplace the inner function wholesale, for any purpose",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Decorators</span>"
    ]
  },
  {
    "objectID": "decorators/index.html#decorator-syntax",
    "href": "decorators/index.html#decorator-syntax",
    "title": "12  Decorators",
    "section": "Decorator Syntax",
    "text": "Decorator Syntax\nWanting to replace a function with its decorated form is so common, we have a special syntax:\n\n@print_before_and_after\ndef add_nums(a, b, c):\n    print(f\"{a} + {b} + {c} =\", a + b + c)\n\nadd_nums(1, 2, 3)\n# same as add_nums = print_before_and_after(add_nums)\n\nBEFORE &lt;function add_nums at 0x1088e0220&gt;\n1 + 2 + 3 = 6\nAFTER &lt;function add_nums at 0x1088e0220&gt;\n\n\nWe can apply multiple decorators, here we’ll apply the same one twice:\n\n@print_before_and_after\n@print_before_and_after\ndef mult_nums(a, b, c):\n    print(f\"{a} * {b} * {c} =\", a * b * c)\n\nmult_nums(1, 2, 3)\n# same as mult_nums = print_before_and_after(print_before_and_after(add_nums))\n\nBEFORE &lt;function print_before_and_after.&lt;locals&gt;.newfunc at 0x1088e0540&gt;\nBEFORE &lt;function mult_nums at 0x1088e00e0&gt;\n1 * 2 * 3 = 6\nAFTER &lt;function mult_nums at 0x1088e00e0&gt;\nAFTER &lt;function print_before_and_after.&lt;locals&gt;.newfunc at 0x1088e0540&gt;\n\n\n\nCreating a Cache\nWe saw that we can use enclosing scope to create a cache, now we can do that in a generic way that will work for any function:\n\ndef cache(func):\n    inner_cache = {}\n    \n    def newfunc(*args):\n        if args not in inner_cache:\n            inner_cache[args] = func(*args)\n        return inner_cache[args]\n    \n    return newfunc\n\n\n@cache\ndef expensive_calculation(a, b, *, c=0):\n    print(f\"doing expensive calculation on {a} {b}...\")\n    return a ** b\n\n@cache\ndef cheap_calculation(a, b):\n    print(f\"doing cheap calculation on {a} {b}...\")\n    return a + b\n\n\nexpensive_calculation(4, 10)\n\ndoing expensive calculation on 4 10...\n\n\n1048576\n\n\n\nexpensive_calculation(4, 10)\n\n1048576\n\n\n\n# independent cache\ncheap_calculation(4, 10)\n\ndoing cheap calculation on 4 10...\n\n\n14\n\n\n\nexpensive_calculation(5, 6)\n\ndoing expensive calculation on 5 6...\n\n\n15625\n\n\n\nexpensive_calculation(5, 6)\n\n15625\n\n\n\n\nDecorators with Arguments\nPython has a built in functools.lru_cache function, which gives us a cache of a defined size:\n@lru_cache(100)\ndef some_calc(a, b, c):\n    pass\nTo write a decorator that takes additional arguments, you must write one more function.\nWe already had:\n\ndecorator function: takes function, returns function\ninner function: takes *args, **kwargs typically, since outer function isn’t known, returns same type as wrapped func\n\nNow we add one more outside that decorator function, a factory function that returns a decorator!\n\ndef repeat(n):  # factory: takes integer, returns decorator\n    def repeat_decorator(func):                  # decorator: takes function, returns function\n        def newfunc(*args, **kwargs):            # inner function: takes ?, returns ?\n            for i in range(n):\n                func(*args, **kwargs)\n        return newfunc\n    return repeat_decorator\n\n@repeat(10)\ndef print_backwards(s):\n    print(s[::-1])\n\nprint_backwards(\"backwards\")\n\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\nsdrawkcab\n\n\n\n# we can see the layers if we call one step at a time:\n# first, obtain the decorator from the factory\nrepeat_10 = repeat(10) \nprint(repeat_10)\n# apply the decorator to the wrapped function\nprint_backwards = repeat_10(print_backwards)\n\n&lt;function repeat.&lt;locals&gt;.repeat_decorator at 0x1088e04a0&gt;",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Decorators</span>"
    ]
  },
  {
    "objectID": "decorators/index.html#function-properties",
    "href": "decorators/index.html#function-properties",
    "title": "12  Decorators",
    "section": "Function Properties",
    "text": "Function Properties\nLet’s look at functools.partial again:\nhttps://docs.python.org/3/library/functools.html#functools.partial\n\nimport functools\nprint_hello_names = functools.partial(print, \"Hello\", sep=\", \")\n\n\nprint_hello_names(\"Scott\", \"Paul\", \"Lauren\")\n# \"hello\" already bound, as is sep, so this is the same as:\n# print(\"Hello\", \"Scott\", \"Paul\", \"Lauren\", sep=\", \")\n\nHello, Scott, Paul, Lauren\n\n\nPartial stores attributes on the function, functions are mutable!\n\n# bound args\nprint_hello_names.args\n\n('Hello',)\n\n\n\n# bound keywords\nprint_hello_names.keywords\n\n{'sep': ', '}\n\n\n\n# original func\nprint_hello_names.func\n\n&lt;function print(*args, sep=' ', end='\\n', file=None, flush=False)&gt;\n\n\n\n# since functions are objects, we can attach arbitrary values to them\ndef wrapper(func):\n    def newfunc(*args, **kwargs):\n        return func(*args, **kwargs)\n    # we can do whatever we like after defining newfunc, but before returning it\n    newfunc.xyz = \"hello\"*2\n    return newfunc\n\n\n# property is assigned to all wrapped functions\n@wrapper\ndef our_function():\n    print(\"inside our function\")\n\nour_function.xyz\n\n'hellohello'\n\n\n\nWriting our own partial\n\ndef our_partial(func, /, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = {**keywords, **fkeywords}\n        return func(*args, *fargs, **newkeywords)\n    # assign these properties from within the closure\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\n\n\nprint_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\")\n\nHello, Scott, Paul, Lauren!\n\n\n\n#print_hello_names2 = our_partial(print, \"Hello\", sep=\", \")\nprint_hello_names2(\"Scott\", \"Paul\", \"Lauren\", end=\"!\", sep=\"?\")\n\nHello?Scott?Paul?Lauren!\n\n\n\nprint_hello_names2.args\n\n('Hello',)\n\n\n\nprint_hello_names2.keywords\n\n{'sep': ', '}\n\n\n\nprint_hello_names2.func\n\n&lt;function print(*args, sep=' ', end='\\n', file=None, flush=False)&gt;",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Decorators</span>"
    ]
  },
  {
    "objectID": "decorators/index.html#more-decorator-examples",
    "href": "decorators/index.html#more-decorator-examples",
    "title": "12  Decorators",
    "section": "More Decorator Examples",
    "text": "More Decorator Examples\n\nNot Calling the Wrapped Function\n\ndef disable(f):\n    def newfunc(*args, **kwargs):\n        print(\"would have called \", f.__name__)\n    return newfunc\n\n@disable\ndef expensive_func(a, b):\n    print(\"expensive!\")\n\nexpensive_func(1, 2)\n\nwould have called  expensive_func\n\n\n\n\nModifying Arguments within newfunc\n\ndef reverse_args(func):\n    def newfunc(*args):\n        # within newfunc we are able to write whatever we'd like\n        # we could decide that we want to reverse the arguments\n        reversed_args = reversed(args)\n        return func(*reversed_args)\n    return newfunc\n\n\n@reverse_args\ndef print_args(*args):\n    for arg in args:\n        print(arg)\n\n\nprint_args(1, 2, 3)\n\n3\n2\n1\n\n\n\n@reverse_args\ndef divide(a, b):\n    return a / b\n\ndivide(10, 2)\n\n0.2\n\n\n\n\nExample: Authorization\n\n# perhaps we want a function that checks if a user can perform an action\ndef auth_required(func):\n    \n    # list of allowed users. in practice, we'd look this up in a database\n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, **kwargs):\n        # here, we're actually using an argument within newfunc\n        # by checking if it is in the kwargs dictionary\n        if kwargs.get(\"auth_user\") in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# these functions must also accept auth_user so that the above call to func(*args, **kwargs)\n# doesn't send an invalid parameter through\n@auth_required\ndef withdraw_funds(account, amount, auth_user):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account, auth_user):\n    print(\"deleted\", account)\n\n\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n\nwithdrew 100 funds from account=jim\n\n\n\ndelete_account(\"kevin\", auth_user=\"jim\")\n\nACCESS DENIED\n\n\n\n\nModifying Keyword Parameters\n\n# if we didn't want auth_user to be passed through, we'd make a small modification to newfunc\n\ndef auth_required(func):    \n    allowed_users = (\"lauren\", \"mitch\")\n    \n    def newfunc(*args, auth_user, **kwargs):\n        # newfunc now requires auth_user, and passes through all *other* parameters\n        if auth_user in allowed_users:\n            func(*args, **kwargs)\n        else:\n            print(\"ACCESS DENIED\")\n    return newfunc\n\n# auth_user is no longer seen in the definition of these functions \n# but it can be passed in since the newfunc returned from auth_required accepts it\n@auth_required\ndef withdraw_funds(account, amount):\n    print(f\"withdrew {amount} funds from account={account}\")\n\n@auth_required\ndef delete_account(account):\n    print(\"deleted\", account)\n\n\nwithdraw_funds(\"jim\", 100, auth_user=\"lauren\")\n\nwithdrew 100 funds from account=jim\n\n\n\ndelete_account(\"kevin\", auth_user=\"jim\")\n\nACCESS DENIED",
    "crumbs": [
      "Understanding Functions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Decorators</span>"
    ]
  },
  {
    "objectID": "oop/index.html",
    "href": "oop/index.html",
    "title": "13  Object-Oriented Programming",
    "section": "",
    "text": "Motivations\nWe often find ourselves working with many functions that use the same data structure(s).\nLet’s look at a hypothetical program that only uses the types we’ve learned so far in Python:\nperson_a = {\"name\": \"Andy\", \"costume\": \"Cowboy\", \"candy\": []}\nperson_b = {\"name\": \"Gil\", \"costume\": \"Robot\", \"candy\": []}\nperson_c = {\"name\": \"Lisa\", \"costume\": \"Ghost\", \"candy\": []}\n\ncandy_bag = [\"Kit Kat\", \"Kit Kat\", \"Lollipop\", \"M&Ms\"]\n\ndef costume_is_scary(person : dict) -&gt; bool:\n    return person[\"costume\"] in (\"Ghost\", \"Wolfman\", \"Mummy\")\n\ndef do_trick(person):\n    print(f\"{person['name']} did a trick\")\n\ndef trick_or_treat(person):\n    success = give_candy(candy_bag, person)\n    # extra candy for scary costumes!\n    if costume_is_scary(person):\n        give_candy(candy_bag, person)\n    if not success:\n        do_trick(person)\n\ndef give_candy(candy_bag, person):\n    if candy_bag:\n        candy = random.choice(candy_bag)\n        candy_bag.remove(candy)\n        person[\"candy\"].append(candy)\n        return True\n    else:\n        return False\nThis is, in effect, object-oriented code.\nAn “object” is a grouping of data with behavior.\nPurely procedural programming focused on using control flow & procedures (impure functions) to structure our application.\nWe saw that functional programming focused on composition of smaller functions to achieve larger goals.\nObject-oriented programming focuses on groupings of data and associated behaviors.\nA common misconception is that a language needs classes to be object-oriented. While classes are the most common feature provided in OO-focused languages, one can write code without them as we saw above.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "oop/index.html#classes-methods",
    "href": "oop/index.html#classes-methods",
    "title": "13  Object-Oriented Programming",
    "section": "Classes & Methods",
    "text": "Classes & Methods\nThe code above might be rewritten as:\n\nclass Person:\n    def __init__(self, name, costume):\n        self.name = name\n        self.costume = costume\n        self.candy = []\n\n    def is_scary(self):\n        return self.costume in (\"Ghost\", \"Wolfman\", \"Mummy\")\n    \n    def do_trick(self):\n        self.tricks = True\n        print(f\"{self.name} did a trick\")\n        \n    def accept_candy(self, candy):\n        self.candy.append(candy)\n        \nclass NoCandy(Exception):\n    pass\n\nclass House:\n    def __init__(self, initial_candy):\n        self.candy = initial_candy\n    \n    def get_candy(self):\n        if not self.candy:\n            raise NoCandy(\"no more candy!\")\n        candy = random.choice(self.candy)\n        self.candy.remove(candy)\n        return candy\n\nThis code provides blueprints for what data & actions a “person” has.\n\nClass - A blueprint for an object, providing methods that will act on instances of the data.\nMethod - A function that is tied to a specific class.\nAttribute - Data that is tied to a specific instance.\nConstructor - A special method that creates & populates an instance of a class.\n\nWhen we use the object, we create instances of our class, and use those as we would any other type.\n\ndef trick_or_treat(person, house):\n    try:\n        candy = house.get_candy()\n        person.accept_candy(candy)\n        if person.is_scary():\n            person.accept_candy(house.get_candy())\n    except NoCandy:\n        do_trick(person, house)\n\n\np = Person(\"James\", \"Wolfman\")\np2 = Person(\"Fred\", \"Mummy\")\nl1 = list()\nl2 = list()\np.is_scary()\np.accept_candy(\"Chocolate\")\np.candy\n\n['Chocolate']",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "oop/index.html#everything-in-python-is-an-object",
    "href": "oop/index.html#everything-in-python-is-an-object",
    "title": "13  Object-Oriented Programming",
    "section": "Everything in Python is an Object",
    "text": "Everything in Python is an Object\nWe’ve been doing this all along! list, dict, and all the rest down to int and None are objects with their own data and methods.\nisinstance is the preferred way to check if an item is of a particular type.\nIt can return true for multiple types, we’ll see why this is the case shortly.\n\nisinstance([1, 2, 3], list)\n\nTrue\n\n\n\nisinstance([1, 2, 3], tuple)\n\nFalse\n\n\n\nisinstance([1, 2, 3], object)\n\nTrue\n\n\n\ns = set([1,2,3])\n\n# using constructors here for demo purposes, generally would use a literal (e.g. [], 0, \"\") for these\nll = list()  \nll.append(str())\nll.append(int())\nll.append(float())\nll.append(s)\nll.append(print)\n\nprint(ll)\n\n['', 0, 0.0, {1, 2, 3}, &lt;built-in function print&gt;]\n\n\n\n[isinstance(item, object) for item in ll]\n\n[True, True, True, True, True]\n\n\nKeeping this in mind can help keep things straight when we delve deeper into making our own objects.\nLet’s revisit a few things that we already know:\n\neach list is independent of all others, when you create a new via list() (or []) that is an instance\ncalling things like .append operate on the instance they are called from.\nSome methods modify the underlying object (.append) while others just provide a return value like any other function. (What are some non-modifying methods?)",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "oop/index.html#classes-in-python",
    "href": "oop/index.html#classes-in-python",
    "title": "13  Object-Oriented Programming",
    "section": "Classes in Python",
    "text": "Classes in Python\n\nInstances, Classes, and Instantiation\nWe often use the blueprint analogy for a class, a class tells us how an object will act, but on its own doesn’t do anything until instantiated.\nThe blueprint can specify features that vary from car to car (color, transmission type, etc.) and behavior that is common among all cars.\nWe can create multiple car instances with different values for a given attribute.\n\nclass Car:\n    # __init__ is a special method\n    # known as a double-underscore or dunder method\n    #  in Python it represents our constructor\n\n    def __init__(self, make, model, year=2000):\n        #print(type(self))\n        self.make = make\n        self.model = model\n        self.year = year\n        self.mileage = 0\n        self.hybrid = False\n        \n# to actually create Cars, we need to call this constructor\ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\nprint(car1.make, car1.model, car1.year)\nprint(car2.make, car2.model, car2.year)\ncar3 = car2\n\nHonda Civic 2019\nChevy Volt 2022\n\n\n\ncar3 is car2\n\nTrue\n\n\n\ncar2.year += 1\n\n\nprint(car3.year)\n\n2023\n\n\nThis is known as instantiation, making an instance of the class.\n\n\nself & methods\nThe first parameter of methods is always self.\nThis parameter is never passed directly, but is a local reference to the object the instance is being called upon.\n\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.mileage = 0\n        self.hybrid = False\n        self.driver = None\n        \n    def print_report(self):\n        print(f\"{self.year} {self.make} {self.model} with {self.mileage} miles\")\n        \n    def drive(self, miles):\n        self.mileage += miles\n        \ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\ncar2.mileage\n\n0\n\n\n\ncar1.print_report()\n\n2019 Honda Civic with 0 miles\n\n\n\ncar2.drive(500)\nprint(car2.mileage)\ncar2.print_report()\n\n500\n2022 Chevy Volt with 500 miles\n\n\n\ncar1.print_report()\n\n2019 Honda Civic with 0 miles\n\n\n\nprint(car1.mileage)\n\n0\n\n\nBecause of self, methods can know which instance they are operating upon.\n\nHow does this work?\nThis is confusing at first glance, where does self come from?\nIt is actually the “parameter before the dot”.\n\n# explicitly call Car.print_report and pass self\nCar.print_report(car2)\n\n# this works, but is not how we call class methods!\n# instead write as car2.print_report()\n\n2022 Chevy Volt with 500 miles\n\n\n\n# this is true of all types\nll = []\nll.append(3)\nlist.append(ll, 4) # list is class, ll is self here\nll\n\n[3, 4]\n\n\n\n\n\nWhat happens if self is omitted?\n\nclass Mistake:\n    def __init__(self):\n        print(\"constructor!\")\n    \n    def method_no_self():\n        print(\"method!\")\n\ntry:\n    m = Mistake()\n    m.method_no_self()\n    # rewritten as Mistake.method_no_self(m)\nexcept Exception as e:\n    print(repr(e))\n\nconstructor!\nTypeError('Mistake.method_no_self() takes 0 positional arguments but 1 was given')\n\n\n\n\nAttributes\nAttributes in Python are created on assignment, like other variables.\nself.name = value\nTypically they will be assigned in the constructor, but not explicitly required.\nWhy is it a good idea to always do this?\nBy default, all attributes are accessible from inside the class and outside:\n\nself.name from inside.\ninstance_name.name from outside.\n\nBest practice: create all attributes inside constructor!\nWhy?\n\nmy_car = Car(\"DMC\", \"DeLorean\", 1982)\nmy_car.driver_name = \"Marty\" # allowed, but to be avoided\nmy_car.whatever_i_want = [1, 2, 3]\n\n\nprint(my_car.driver)\n\nNone\n\n\n\n\nException to the rule: function objects\nFunctions are objects, and can have attributes assigned to them as well.\nWe sometimes do this since there’s no opportunity to assign them before. (Because functions do not have constructors we can modify.)\n\ndef f():\n    print(f\"called f()\")\n    #f.call_count = 0 # NO\nf.call_count = 0\n\n\nf.call_count += 1\nf()\nprint(f.call_count)\n\ncalled f()\n1\n\n\n\n# using a decorator to add call_count to any function\ndef counter(func):\n    #inner.call_count\n    def inner(*args, **kwargs):\n        inner.call_count += 1\n        print(f\"call count {inner.call_count}\")\n        return func(*args, **kwargs)\n    inner.call_count = 0\n    return inner\n\n\n@counter\ndef f():\n    print(\"called f()\")\n\n\n@counter\ndef g():\n    print(f\"called g()\")\n\n\nf()\nf()\nf()\n\ncall count 1\ncalled f()\ncall count 2\ncalled f()\ncall count 3\ncalled f()\n\n\n\ng()\n\ncall count 1\ncalled g()",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "oop/index.html#protocols-duck-typing-and-polymorphism",
    "href": "oop/index.html#protocols-duck-typing-and-polymorphism",
    "title": "13  Object-Oriented Programming",
    "section": "Protocols, Duck-Typing, and Polymorphism",
    "text": "Protocols, Duck-Typing, and Polymorphism\nIn some languages, functions can be created with one name but different argument lists.\n// C++\nvoid foo(int x)\nvoid foo(double x)\nvoid foo(int x, double y)\nThe compiler can decide which function to call at compile time based on the types given.\nThis is called polymorphism, the specific implementation of an operation depends on the objects being operated on.\nThe + operator exhibits polymorphism in Python:\n1 + 5  # addition\n\"1\" + \"5\" # string concatenation\n[1,2,3] + [4,5] # list concatenation\nRemember, we mentioned that everything in Python is an object and objects have operations associated with them.\ndef times(x, y):\n     return x * y\nAs long as our objects x and y support the * protocol, it is safe to call times(x, y).\nIn Python, instead of forcing our arguments to be specific types, we use something known as duck typing.\n\n“If it looks like a duck, and it quacks like a duck, it might as well be a duck.”\n\nIf we had a function:\ndef do_something(a, b):\n    a.append(b[0])\nWe can pass any type for a that has an append, and any type for b that has a way to call it with [0].\n\nProtocols & Dunder Methods\nAnother way of thinking about this is that objects of a given type follow a certain protocol.\n\niterable\ncallable\naddable\ncomparable\n\nIn the above example, while we could add the .append method, if we want to make our own types that are comparable, iterable, etc. we need to use dunder methods.\ndunder or double-underscore methods are specially-named methods that are called when specific syntax is used.\nFor example, to be “addable” an object needs a __add__ method, to be comparable it needs __eq__ and __lt__ or __gt__ at least. (We’ll see more of these later.)\nFor now, let’s look at a few of these:\n\n__repr__\n__str__\n__eq__\n\n\nclass Car: \n    def __init__(self, make, model, year):\n        self._make = make \n        self._model = model \n        self._year = year\n        self.__mileage = 0\n\n    def drive(self, miles):\n        if miles &gt; 0:\n            self.__mileage += miles\n        else:\n            ...\n       \n    def __eq__(self, other):\n        # we can decide equality does/doesn't include mileage\n        return (self._make == other._make \n                and self._model == other._model \n                and self._year == other._year)\n    \n    def __repr__(self):\n        return f\"repr Car({self._make}, {self._model}, {self._year}, mileage={self.__mileage})\"\n\n    def __str__(self):\n        return f\"str {self._year} {self._make} {self._model} with {self.__mileage} miles\"\n\n    # common to only define __repr__, then add \n    # __str__ = __repr__\n\n\ntruck = Car(\"Ford\", \"F-150\", 1985)\ntruck2 = Car(\"Ford\", \"F-150\", 1985)\n\n\n# stating a variable name in the REPL will show the `repr`\ntruck\n\nrepr Car(Ford, F-150, 1985, mileage=0)\n\n\n\n# printing a variable will call the `str`\nprint(truck)\n\nstr 1985 Ford F-150 with 0 miles\n\n\n\n# we can also cast using `str()`\nvar = str(truck)\nvar\n\n'str 1985 Ford F-150 with 0 miles'\n\n\n\n# calls __eq__\ntruck == truck2 \n\nTrue\n\n\n\n# truck == truck2, rewritten as \ntruck.__eq__(truck2)\n\nTrue\n\n\n\n\nstr vs repr\nrepr is supposed to be a programmatic interpretation, used in debugging output. In jupyter/ipython if a function returns a value we see the repr by default.\nstr is used when print is called, or an explicit conversion to string as shown above.\nIf only __repr__ is defined, then str(obj) will use __repr__, so if you don’t have a need for them to differ, then define __repr__ and add __str__ = __repr__.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "oop/index.html#discussion",
    "href": "oop/index.html#discussion",
    "title": "13  Object-Oriented Programming",
    "section": "Discussion",
    "text": "Discussion\n\nWhat else is iterable?\nWhat are other protocols we’ve seen?\nDo all iterables eventually raise StopIteration?\nWhat dunder methods are being called by:\n\nf(x[0] + y[\"test\"])",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "inheritance/index.html",
    "href": "inheritance/index.html",
    "title": "14  Inheritance",
    "section": "",
    "text": "Motivations\nLet’s say we’re building an application that tracks students.\nclass Student:\n\n    # this is a class-level variable\n    # instead of each instance having its own copy\n    # the variable is shared among all `Student`\n    next_id_counter = 1\n    \n    def __init__(self, name):\n        # assign each student a unique id\n        # note use of Student. not self.\n        self.id = Student.next_id_counter\n        Student.next_id_counter += 1\n        \n        self.name = name\n        self.year = 1\n        self.major = \"Undeclared\"\n        self.course_grades = {}\n        self.extracurriculars = []\n        \n    def add_grade(self, course_name, grade):\n        self.course_grades[course_name] = grade\n    \n    @property\n    def gpa(self):\n        grade_pts = {\"A\":4.0, \"A-\":3.7, \"B+\":3.3, \"B\":3.0, \"B-\":2.7, \"C+\":2.3, \"C\":2.0, \"C-\":1.7, \"D+\":1.3, \"D\":1.0, \"F\":0.0} \n        if len(self.course_grades) == 0:\n            return 0\n        return sum(grade_pts[g] for g in self.course_grades.values()) / len(self.course_grades)\n    \n    def __repr__(self):\n        return f\"Student(name={self.name}, id={self.id}, gpa={self.gpa})\"\ns1 = Student(\"Adam\")\ns2 = Student(\"Beth\")\ns2.add_grade(\"Programming Python\", \"A\")\ns2.add_grade(\"Discrete Math\", \"B+\")\nprint(s1)\nprint(s2)\n\nStudent(name=Adam, id=1, gpa=0)\nStudent(name=Beth, id=2, gpa=3.65)\nPerhaps we want to add Alumni to our application.\nAn alum will have some things in common with students:\nWe now also:\nHow to implement?\nWe could copy student.py and rename to alum.py and rename the class as needed.\nBut copying & pasting is generally a bad idea!\nWe’d need to fix bugs & add features in both classes separately.\nA new feature in Student would need to be copied over to Alum, this will quickly get messy.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Inheritance</span>"
    ]
  },
  {
    "objectID": "inheritance/index.html#motivations",
    "href": "inheritance/index.html#motivations",
    "title": "14  Inheritance",
    "section": "",
    "text": "They still have a name.\nWe want to remember their major.\nWe’ll still want to keep track of their grades/GPA.\n\n\n\nWant to record their year of graduation.\nNo longer want to allow grades to be recorded.\nWant to be able to calculate how long ago they graduated.\nWhen displaying them, we want to display their graduation year.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Inheritance</span>"
    ]
  },
  {
    "objectID": "inheritance/index.html#inheritance-in-python",
    "href": "inheritance/index.html#inheritance-in-python",
    "title": "14  Inheritance",
    "section": "Inheritance in Python",
    "text": "Inheritance in Python\nInstead we will use inheritance, which allows us to create a new class from an existing one. The new class inherits the attributes and methods from the parent.\n\nsuperclass, parent, or base class: The pre-existing class.\nsubclass, child, or derived class: The new class that inherits the code (attributes & methods) of another class.\n\nSubclasses can extend/modify the functionality of superclasses.\nSyntax:\nclass Subclass(Superclass):\n    pass\nFor example:\nclass Alum(Student):\n    pass\nAt this point, Alum is a new class with the exact same implementation as Student.\nTypically we’ll want to add new instance & class variables, methods, etc.\nNewly defined features will only apply to instances of Alum\nIt is possible to override parent class behavior, or rely on parent behavior, whichever is needed.\n\nAdding & Overriding Behavior\n\nclass Alum(Student):\n    def __init__(self, name, grad_year):\n        # call Student's constructor, which contains id logic\n        super().__init__(name)\n        self.graduation_year = grad_year\n        \n    # new behavior\n    def years_since_graduation(self, now):\n        return now - self.graduation_year\n    \n    # overrides parent's add_grade\n    def add_grade(self, course_name, grade):\n        raise NotImplementedError(\"cannot add grades to Alum\")\n        #print(\"Sorry, you cannot add grades to Alums\")\n        # we choose not call super().add_grade here\n    \n    # overrides parent's __repr__\n    def __repr__(self):\n        #return f\"Alum(name={self.name}, id={self.id}, gpa={self.gpa}, graduated={self.graduation_year})\"\n        string = super().__repr__()\n        string += \" is an alum\"\n        return string\n\n\nalum1 = Alum(\"Charlie\", 2016)\nprint(alum1)\nprint(alum1.years_since_graduation(2022), \"years since graduation\")\n#alum1.add_grade(\"Python\", \"B\")\nalum1.gpa\n\nStudent(name=Charlie, id=3, gpa=0) is an alum\n6 years since graduation\n\n\n0\n\n\n\nalum2 = Alum(\"Charlie\", 2016)\n\n\n\nsuper()\nAllows direct access to parent class(es).\nMany different ways to be called, but for our purposes we will stick to super().method_name() to access parent implementation of method_name()\n\n\nissubclass & isinstance\n\nisinstance(object, class_type) - Check if an object is of an instance.\nissubclass(class_type, class_type2) - Check if a type is a subclass of another type.\n\n\nisinstance(7, int)\n\nTrue\n\n\n\n# same as?\ntype(7) == int\n\nTrue\n\n\n\ntype(7) == object\n\nFalse\n\n\n\nisinstance(7,  object)\n\nTrue\n\n\n\n# isinstance checks the inheritance hierarchy \nisinstance(alum2, object)\n\nTrue\n\n\n\ntype(alum2) == Student\n\nFalse\n\n\n\nisinstance([1, 2, 3], list)\n\nTrue\n\n\n\ns1 = Student(\"Sarah\")\nisinstance(s1, Student)\n\nTrue\n\n\n\n# child classes are instances of parent types\nalum1 = Alum(\"Charlie\", 2016)\nisinstance(alum1, Student)\n\nTrue\n\n\n\n# but not vice-versa\nisinstance(s1, Alum)\n\nFalse\n\n\n# INCORRECT: issubclass takes class names, not instances\nissubclass(alum1, Student)\n\n# Instead\nissubclass(Alum, Student)\n\n\nobject\nEvery object derives from a base class named object.\nclass Point:\n    def __init__(self, x, y):\n        self.x = y\n\n# Same as: \n\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = y\n        self.y = y\n\n\nMRO\nWhen we call a function, Python walks up the chain of parent classes to determine the first one that has the method defined.\nThis is called the method resolution order.\n\nhelp(Alum)\n\nHelp on class Alum in module __main__:\n\nclass Alum(Student)\n |  Alum(name, grad_year)\n |\n |  Method resolution order:\n |      Alum\n |      Student\n |      builtins.object\n |\n |  Methods defined here:\n |\n |  __init__(self, name, grad_year)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self)\n |      Return repr(self).\n |\n |  add_grade(self, course_name, grade)\n |      # overrides parent's add_grade\n |\n |  years_since_graduation(self, now)\n |      # new behavior\n |\n |  ----------------------------------------------------------------------\n |  Readonly properties inherited from Student:\n |\n |  gpa\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Student:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Student:\n |\n |  next_id_counter = 7\n\n\n\n\nAlum.__mro__\n\n(__main__.Alum, __main__.Student, object)\n\n\n\nhelp(super)\n\nHelp on class super in module builtins:\n\nclass super(object)\n |  super() -&gt; same as super(__class__, &lt;first argument&gt;)\n |  super(type) -&gt; unbound super object\n |  super(type, obj) -&gt; bound super object; requires isinstance(obj, type)\n |  super(type, type2) -&gt; bound super object; requires issubclass(type2, type)\n |  Typical use to call a cooperative superclass method:\n |  class C(B):\n |      def meth(self, arg):\n |          super().meth(arg)\n |  This works for class methods too:\n |  class C(B):\n |      @classmethod\n |      def cmeth(cls, arg):\n |          super().cmeth(arg)\n |\n |  Methods defined here:\n |\n |  __get__(self, instance, owner=None, /)\n |      Return an attribute of instance, which is of type owner.\n |\n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |\n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __self__\n |      the instance invoking super(); may be None\n |\n |  __self_class__\n |      the type of the instance invoking super(); may be None\n |\n |  __thisclass__\n |      the class invoking super()",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Inheritance</span>"
    ]
  },
  {
    "objectID": "inheritance/index.html#abstract-base-classes",
    "href": "inheritance/index.html#abstract-base-classes",
    "title": "14  Inheritance",
    "section": "Abstract Base Classes",
    "text": "Abstract Base Classes\nSometimes we want to define a class that can’t be instantiated directly, but is intended to be inherited from.\nThese are known as abstract classes. This helps us define an interface, which contains a collection of methods that the concrete class must implement.\n\ndef print_dot_prod(v1, v2):\n    \"\"\" prints dot product between two vectors \"\"\"\n    print(v1.dot_product(v2))\n\nIf we want this method to be polymorphic for vectors of multiple dimensions, such as:\n\nclass Vec2:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y  \n\n    def dot_product(self, other):\n        ...\n        \nclass Vec3:\n    def __init__(self,x,y,z):\n        self.x = x\n        self.y = y  \n        self.z = z \n\n    def dot(self, other):\n        ...\n\nWe can force that these types implement an interface (i.e., an abstract base class) such that we can guarantee that objects we pass to print_dot_prod will always work by forcing them to implement a dot_product method.\nWe will define an abstract class called Vector that has only the required method:\ndef dot_product(self, other)\n\nfrom abc import ABC, abstractmethod\n\nclass Vector(ABC):\n    # an unimplemented method\n    @abstractmethod\n    def dot_product(self, other):\n        pass\n\n    # demonstrate we can have a normal method\n    def print_x(self):\n        print(self.x)\n\n\n# we can't instantiate abstract classes\ntry:\n    v = Vector()\nexcept Exception as e:\n    print(repr(e))\n\nTypeError(\"Can't instantiate abstract class Vector without an implementation for abstract method 'dot_product'\")\n\n\n\nclass Vec2(Vector):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y  \n        \n    def dot_product(self, other): \n        return self.x * other.x + self.y * other.y\n        \nclass Vec3(Vector):\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y  \n        self.z = z \n        \n    def dot_product(self, other): \n        return self.x * other.x + self.y * other.y + self.z * other.z\n\nNow print_dot_prod works:\n\n# Vec2 and Vec3 objects are instances of Vector since their classes \n# inherit from the Vector ABC.\nv2a = Vec2(1,2)\nv2b = Vec2(3,4)\nv3a = Vec3(6,7,3)\nv3b = Vec3(1,2,3)\n\nprint(isinstance(v2a, Vec2)) \nprint(isinstance(v2a, Vector)) \nprint(\"----\")\nprint(isinstance(v3a, Vec3)) \nprint(isinstance(v3a, Vector))\n\nTrue\nTrue\n----\nTrue\nTrue\n\n\n\nv2a.print_x()\n\n1\n\n\n\nprint_dot_prod(v2a, v2b)\n\n11\n\n\n\nprint_dot_prod(v3a, v3b)\n\n29",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Inheritance</span>"
    ]
  },
  {
    "objectID": "inheritance/index.html#dataclasses",
    "href": "inheritance/index.html#dataclasses",
    "title": "14  Inheritance",
    "section": "Dataclasses",
    "text": "Dataclasses\nPython 3.7 added dataclasses as a handy way to create classes that are mostly responsible for representing data. These classes often have few or no methods defined.\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass InventoryItem:\n    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n    name: str\n    unit_price: float\n    quantity_on_hand: int = 0\n\n    def total_cost(self) -&gt; float:\n        return self.unit_price * self.quantity_on_hand\n\n# class decorator!\n# similar concept, much harder to write\n# \n# InventoryItem = dataclass(InventoryItem)\n\n\nwrench = InventoryItem(\"Wrench\", 12.95, 10)\nhammer = InventoryItem(\"Hammer\", 16, 8)\nnails = InventoryItem(\"Nails\", 0.03, 1000)\nsaw = InventoryItem(\"Saw\", 99)\nsaw2 = InventoryItem(\"Saw\", 99)\n\n\nsaw == saw2\n\nTrue\n\n\nDataclasses get an automatic __init__, __repr__, __eq__, and several other helpful options. (Even more is possible via the decorator: https://docs.python.org/3/library/dataclasses.html)\n\nnails.total_cost()\n\n30.0\n\n\nBeyond this, additional methods/staticmethods/etc. can be defined in the usual way.\nThis syntax uses Python’s type-hinting, and if you’re looking to use it you’ll want to get familiar with the rules around complex types: https://docs.python.org/3/library/typing.html\n\n# instead of returning tuples and \n# remembering the positional order, can instead\n@dataclass\nclass RetType:\n    data: list[int]\n    counter: int\n\ndef fn():\n    return RetType([], counter)",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Inheritance</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html",
    "href": "exceptions/index.html",
    "title": "15  Exceptions",
    "section": "",
    "text": "Error Handling\nGoals\nNo matter how good your code is, there’s always going to be a chance that something goes wrong.\ndef my_func(a, b):\n    \"\"\" what can go wrong with this function? \"\"\"\n    if a &gt; b:\n        return a / b\n    else:\n        return a * c\nIf we were to try to handle all errors, we’d need to return some error value, perhaps None.\nBut this has issues of it’s own:\nCode winds up littered with:\nSome languages, like C, do not have exceptions, and as a result correct C code is commonly filled with checks like the above examples.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html#error-handling",
    "href": "exceptions/index.html#error-handling",
    "title": "15  Exceptions",
    "section": "",
    "text": "NoteError One\n\n\n\n\n\n\ntry:\n    my_func(3, 0)\nexcept Exception as e:\n    print(repr(e))\n\nZeroDivisionError('division by zero')\n\n\n\n\n\n\n\n\n\n\n\nNoteError Two\n\n\n\n\n\n\ntry:\n    my_func(10, 12)\nexcept Exception as e:\n    print(repr(e))\n\nNameError(\"name 'c' is not defined\")\n\n\n\n\n\n\n\n\n\n\n\nNoteError Three\n\n\n\n\n\n\ntry:\n    my_func(\"two\", \"three\")\nexcept Exception as e:\n    print(repr(e))\n\nTypeError(\"unsupported operand type(s) for /: 'str' and 'str'\")\n\n\n\n\n\n\ndef my_func(a, b):\n  # make sure both variables are numeric\n  if not isinstance(a, (int, float, complex)):\n      return None\n  if not isinstance(b, (int, float, complex)):\n      return None\n    if a &gt; b:\n        if b == 0:\n            return None   # can't divide by zero\n        return a / b\n    else:\n        return a * b\n\n\nThe function is significantly harder to read, now half the code is dedicated to error handling.\nThere are other numeric types, such as fraction.Fraction, the function is now artificially constrained to only work with those that the author considered.\nBy returning None we get no information about what happened. This would make debugging harder if we found a None result later in our program.\nNow code using this function will always need to check if it got a numeric value or None on result.\n\n\nq = my_func(r, s)\nif q is not None:\n  ... # good path\nelse:\n  ... # error path",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html#exceptions",
    "href": "exceptions/index.html#exceptions",
    "title": "15  Exceptions",
    "section": "Exceptions",
    "text": "Exceptions\nIn Python we have exceptions, which allow us to write our code assuming that things went well. This means we can generally call functions and use their return values without checking for an error result between each step.\nThis makes it possible to write concise code:\nurl = get_url()\nresp = httpx.get(url)\nroot = lxml.html.fromstring(resp.text)\n\n# or even as a single line\nroot = lxml.html.fromstring(httpx.get(get_url()).text)\nMost of the time, that code should work as intended, but errors might occur:\n\nget_url() might have a bug and return None or an invalid URL.\nThe server might be down, so httpx.get encounters a timeout.\nlxml.html.fromstring might not be able to parse the HTML.\n\nInstead of a long potentially complex series if/else statements, we can write the code assuming things will go well. If something exceptional happens, the functions will raise an exception.\nIf we write nothing else, any exception will force the program to exit. Often that’s the desired behavior. For example, if the program depends on a website being up, exiting if the server is unavailable is a reasonable choice.\nSometimes however, there might be some code that we’d like to run when something exceptional happens.\nSome examples:\n\nsome errors are recoverable, perhaps the site was down momentarily and we can retry after a short wait\nsave/close open files so no work is lost before exiting\nor perhaps just printing a user-friendly error message before exiting\n\nExceptions are very useful in Python, so sometimes we may even use them for non-error conditions, just to handle a less-common case.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html#handling-exceptions",
    "href": "exceptions/index.html#handling-exceptions",
    "title": "15  Exceptions",
    "section": "Handling Exceptions",
    "text": "Handling Exceptions\nWe surround the “risky” code with a try/except statement.\ntry:\n    might_encounter_error()\n    maybe_works()\nexcept (ValueError, KeyError) as exc:\n    handle_error(exc)\n\nthen_this()\nIf either of the lines of code within the try portion produce an exception, Python will check the type against the except statement.\nIf the type matches any of the listed types, it will assign the exception to exc, then run the block under the matching except. (The variable name is your choice, common names are e, err, exc).\nIf no exception is raised, the next line of code to execute would be after the except block, the function then_this().\n\nMultiple Exception Types\nIf you are only handling a single type you would use except ExceptionType. If you are handling multiple exceptions you can combine them in a tuple if you want the same code to handle multiple types, as we saw above.\nSometimes however, you may want to handle different exceptions differently:\ntry:\n    response = httpx.get('http://example.com')\n    response.raise_for_status()\n    print(f\"Success! Status code: {response.status_code}\")\nexcept (httpx.RequestError, httpx.TimeoutException) as e:\n    # Handles network-related errors (DNS failures, connection errors, etc.)\n    #  as well as timeouts.\n    print(f\"Server error occurred: {e}\")\nexcept httpx.HTTPStatusError as e:\n    # Handles HTTP status errors (4xx, 5xx responses)\n    print(f\"HTTP error occurred: {e}\")\nHere we use multiple except statements to execute different code depending on the kind of error encountered. Like elif statements, only the first except to match will be executed.\nThis means that when the server is down, we can retry after some time. However, if the error is that the password is invalid there’s no benefit in retrying with the same data.\n\n\ntry-except-else-finally\nA try/except may have:\n\none try block\nas many except blocks as desired\nan optional else\nan optional finally\n\nThe else statement only executes if no exception is raised. (Somewhat akin to the else executing if no elif runs.)\nfinally is unique to exception handling. It executes no matter what, after any other blocks are evaluated.\ntry:\n    something()\nexcept ValueError as e:\n    ...   # executes only if ValueError was raised\nexcept (IndexError, KeyError) as e:\n    ...   # executes only if IndexError or KeyError was raised\nelse:\n    ...   # executes if no exception raised\nfinally:\n    ...   # executes after try/except/else no matter what",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html#raising-exceptions",
    "href": "exceptions/index.html#raising-exceptions",
    "title": "15  Exceptions",
    "section": "Raising Exceptions",
    "text": "Raising Exceptions\nIf your code encounters a condition that it cannot handle, you can raise an exception.\nTo raise an exception, you use the raise keyword, which similarly to return exits a function immediately.\n\ndef f(positive):\n    if positive &lt; 0:\n        raise ValueError(\"f requires a positive argument\")\n    return positive * positive\n\n\nf(3)\n\n9\n\n\n\ntry:\n    y = f(-1)\nexcept ValueError as exc:\n    y = 0\n    print(\"got an error: \", exc)\nprint(\"y=\", y)\n\ngot an error:  f requires a positive argument\ny= 0\n\n\n\nPropagation\nExceptions propagate unless caught, you’ve encountered this in your own code:\n\ndef inner():\n    raise Exception(\"example\")\n\ndef middle():\n    inner()\n\ndef outer():\n    middle()\n\ntry:\n    outer()\nexcept Exception as e:\n    # this code being used for this example to show\n    # stack output in notebook\n    print(\"Uncaught: \", repr(e))\n    import traceback\n    print(traceback.format_exc())\n\nUncaught:  Exception('example')\nTraceback (most recent call last):\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_78119/2424353647.py\", line 11, in &lt;module&gt;\n    outer()\n    ~~~~~^^\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_78119/2424353647.py\", line 8, in outer\n    middle()\n    ~~~~~~^^\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_78119/2424353647.py\", line 5, in middle\n    inner()\n    ~~~~~^^\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_78119/2424353647.py\", line 2, in inner\n    raise Exception(\"example\")\nException: example\n\n\n\nThis is sometimes called “bubbling up”, the uncaught exception pops functions off the call stack, exiting them in LIFO “last-in-first-out” order.\nA try/except may catch the exception at any level. If the exception is caught within middle for instance, execution will resume in that function’s except block.\n\ndef inner():\n    raise Exception(\"example\")\n\ndef middle():\n    try:\n       inner()\n    except Exception:\n       print(\"caught in the middle, stops propagation\")\n\ndef outer():\n    middle()\n\ntry:\n    outer()\nexcept Exception as e:\n    # this code being used for this example to show\n    # stack output in notebook\n    print(\"Uncaught: \", repr(e))\n    import traceback\n    print(traceback.format_exc())\n\ncaught in the middle, stops propagation\n\n\n\n\nre-raising\nWhile an except usually stops propagation, sometimes you want to handle an exception and then still allow it to propagate/end the program.\n\ndef risky_code():\n    print(\"running risky code...\")\n    raise Exception(\"!\")\n\ndef save_data():\n    print(\"saving data!\")\n\ndef main():\n    try:\n        risky_code()\n    except Exception as e:\n        print(f\"Handling Error: {e}\")\n        raise\n    finally:\n        save_data()\n\n\ntry:\n    main()\nexcept Exception as e:\n    # this code being used for this example to show\n    # stack output in notebook\n    print(\"Uncaught: \", repr(e))\n    import traceback\n    print(traceback.format_exc())\n\nrunning risky code...\nHandling Error: !\nsaving data!\nUncaught:  Exception('!')\nTraceback (most recent call last):\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_78119/2649118250.py\", line 19, in &lt;module&gt;\n    main()\n    ~~~~^^\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_78119/2649118250.py\", line 10, in main\n    risky_code()\n    ~~~~~~~~~~^^\n  File \"/var/folders/rs/85dqs00543v8l_mvhbsxzrmh0000gn/T/ipykernel_78119/2649118250.py\", line 3, in risky_code\n    raise Exception(\"!\")\nException: !\n\n\n\nThis example runs the function risky_code, and if an error occurs will print the error message",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html#exception-types",
    "href": "exceptions/index.html#exception-types",
    "title": "15  Exceptions",
    "section": "Exception Types",
    "text": "Exception Types\nExceptions in Python form a hierarchy.\nThe exceptions you’re used to seeing inherit from Exception:\n\nException (base type)\n\nValueError\nTypeError\nKeyError\nIndexError\nNotImplementedError\nOSError\n\nFileNotFoundError\n\n\n\nThe Python exception documentation contains the full hierarchy.\nAn except OSError will also catch FileNotFoundError since the second is a child of the first.\nThis means that if you catch Exception almost all of the common exceptions.\n\n\n\n\n\n\nWarningexcept Exception & bare except:\n\n\n\nexcept Exception is usually a bug. Rarely do you want to handle all exceptions in the same manner.\nOne time that it would be acceptable to do this would be to print a human readable error message. You can catch Exception in your main function and print a more useful error message.\nThough not shown in any of the examples on this page, except: without any exception at all is also valid syntax. This will catch all exceptions, not just those that are children of Exception.\nThis is an even worse idea, and the general advice is to never use this. It will include special exceptions like SystemExit which are raised when someone tries to quit your program. This means that programs that catch except: can appear to be stuck.\n\n\n\nDefining Custom Exception Types\nSometimes a built-in exception type is a natural fit, if you are writing a dictionary-like object you would probably use KeyError if an invalid key is accessed.\nMost of the time, it is a good idea to define your own exception type, or types.\nCustom exception types let you handle your own errors differently from Python’s built in types:\nclass InvalidColor(Exception):\n    \"\"\" This exception is raised when an invalid color is passed. \"\"\"\n    pass\n\nVALID_COLORS = (...)\n\ndef draw_point(x, y, color):\n    if color not in VALID_COLORS:\n        raise InvalidColor(\"color should be one of the valid colors\")\nException classes must inherit from Exception or another exception. This will define their place in the exception hierarchy.\nIf you’re unfamiliar with inheritance at this point, this refers to the (Exception) portion of the above declaration.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html#best-practices",
    "href": "exceptions/index.html#best-practices",
    "title": "15  Exceptions",
    "section": "Best Practices",
    "text": "Best Practices\nWhen a programmer first encounters except it may feel tempting to just catch every error. Doing so doesn’t magically make your code work, it just hides errors and makes debugging impossible.\nInstead, you want to keep exception handling to cases that your code intends to handle, not use except to ignore errors.\nBest practices are to keep error handling as narrow as possible:\n\nTry to keep your try blocks as small as possible, only including the code that might raise an exception.\nCatch the most specific exception possible, and only catch exceptions that you can handle.\nraise the most specific exception that you can, DivisionByZeroError tells you more than ArithmeticError.\n\nCreate & use custom exception types liberally!\n\nAlways avoid catching Exception, or omitting the exception type entirely.\nProvide useful messages to augment common exception types, for example raise ValueError(\"say why the value was rejected\").",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions/index.html#further-exploration",
    "href": "exceptions/index.html#further-exploration",
    "title": "15  Exceptions",
    "section": "Further Exploration",
    "text": "Further Exploration\n\nPython Docs - Errors and Exceptions\nPython Docs - Context Managers\nPython Docs - with Statement",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "pdm/index.html",
    "href": "pdm/index.html",
    "title": "16  Python Data Model",
    "section": "",
    "text": "Python Data Model\nNow that we understand classes, we can take a deeper look at how Python’s built in types work.\nThis allows us to better understand their usage, and create our own classes that work just like the built-ins.\nWe’ve seen that Python uses dunder methods to provide syntactical sugar, allowing us to use nicer syntax to write things like:\nPython Data Model Docs: https://docs.python.org/3/reference/datamodel.html",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Python Data Model</span>"
    ]
  },
  {
    "objectID": "pdm/index.html#python-data-model",
    "href": "pdm/index.html#python-data-model",
    "title": "16  Python Data Model",
    "section": "",
    "text": "l = [1, 2, 3] * 2\nl[4]\n\n# instead of\nl = list(1, 2, 3)\nl = l.repeat(2)\nl.get_item_at_index(4)\n\n\nEmulating Collections & Sequences\nCollections\n\nHave a length: len(obj)\nCan be iterated over: for item in obj\nCan query for membership: item in obj\n\nSequences\n\nEverything a collection can do\nCan be indexed: obj[0]\n\n\n\n\nYou Write…\nPython Calls…\n\n\n\n\nlen(obj)\nobj.__len__()\n\n\nfor item in obj\nobj.__iter__()\n\n\nitem in obj\nobj.__contains__(item)\n\n\nobj[i]\nobj.__getitem__(i)\n\n\nobj[i] = x\nobj.__setitem__(i, x)\n\n\ndel obj[i]\nobj.__delitem__(i)\n\n\n\n\n\nNumeric Operators\n\n\n\nYou Write…\nPython Calls…\n\n\n\n\nx + y\nx.__add__(y)\n\n\nx - y\nx.__sub__(y)\n\n\nx * y\nx.__mul__(y)\n\n\nx / y\nx.__truediv__(y)\n\n\nx // y\nx.__floordiv__(y)\n\n\nx % y\nx.__mod__(y)\n\n\nx ** y\nx.__pow__(y)\n\n\nx @ y\nx.__matmul__(y)\n\n\n\n\n\nReverse / Reflected / Right Operators\nThese operators are called if the attempt to call on the left-hand-side fails with a NotImplemented or is not present.\n\n\n\nYou Write…\nPython Calls…\n\n\n\n\nx + y\ny.__radd__(x)\n\n\nx - y\ny.__rsub__(x)\n\n\nx * y\ny.__rmul__(x)\n\n\nx / y\ny.__rtruediv__(x)\n\n\nx // y\ny.__rfloordiv__(x)\n\n\nx % y\ny.__rmod__(x)\n\n\nx ** y\ny.__rpow__(x)\n\n\nx @ y\ny.__rmatmul__(x)\n\n\n\n\n\nComparison Operators\n\n\n\nYou Write…\nPython Calls…\n\n\n\n\nx &lt; y\nx.__lt__(y)\n\n\nx &lt;= y\nx.__le__(y)\n\n\nx &gt; y\nx.__gt__(y)\n\n\nx &gt;= y\nx.__ge__(y)\n\n\nx == y\nx.__eq__(y)\n\n\nx != y\nx.__ne__(y)",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Python Data Model</span>"
    ]
  },
  {
    "objectID": "pdm/index.html#building-our-staticarray",
    "href": "pdm/index.html#building-our-staticarray",
    "title": "16  Python Data Model",
    "section": "Building our StaticArray",
    "text": "Building our StaticArray\nTo demonstrate, we’ll implement a sequence type seen in other languages known as a static array:\n\nA static array is a sequence type where there is a fixed capacity to number of items the collection can hold.\nResizing of the array is not allowed after initialization.\n\nWe will define a class StaticArray that will allow use of built-in operators.\nWe’ll be able to use it like this:\n&gt;&gt;&gt; from static_array import StaticArray\n&gt;&gt;&gt; sa = StaticArray([1, 2, 3])\n# should produce the following output:\n&gt;&gt;&gt; print(sa * 2) # repetition using *\n[1, 2, 3, 1, 2, 3]\n&gt;&gt;&gt; print(sa[1])  # indexing using []\n2\n\nDual-Purpose Constructor using isinstance\n\nfrom collections.abc import Iterable\n\nclass StaticArray:\n    def __init__(self, init_val, capacity=5):\n        if isinstance(init_val, Iterable):\n            self.items = list(init_val)\n            self.capacity = len(self.items)\n        else:\n            self.items = [init_val] * capacity\n            self.capacity = capacity\n\n\nsa = StaticArray([1, 2, 3])\nprint(sa)\n\n&lt;__main__.StaticArray object at 0x105e70ec0&gt;\n\n\n\nsa = StaticArray(0, 5)\nprint(sa)\n\n&lt;__main__.StaticArray object at 0x105b6ae90&gt;\n\n\n\n\nAdding a __repr__\n\nclass StaticArray:\n    def __init__(self, init_val, capacity=5):\n        if isinstance(init_val, Iterable):\n            self.items = list(init_val)\n            self.capacity = len(self.items)\n        else:\n            self.items = [init_val] * capacity\n            self.capacity = capacity\n\n    def __repr__(self):\n        return f\"StaticArray({self.items})\"\n\n\nsa = StaticArray([1, 2, 3])\nprint(sa)\n\nStaticArray([1, 2, 3])\n\n\n\nsa = StaticArray(0, 5)\nprint(sa)\n\nStaticArray([0, 0, 0, 0, 0])\n\n\n\n\nCollection & Sequence Methods\nHere we’re using an underlying list, so our methods are quite simple:\n\nclass StaticArray:\n    def __init__(self, init_val, capacity=5):\n        if isinstance(init_val, Iterable):\n            self.items = list(init_val)\n            self.capacity = len(self.items)\n        else:\n            self.items = [init_val] * capacity\n            self.capacity = capacity\n\n    def __repr__(self):\n        return f\"StaticArray({self.items})\"\n\n    def __str__(self):\n        return f\"StaticArray({self.items})\"\n\n    def __len__(self):\n        return self.capacity\n\n    def __contains__(self, item):\n        return item in self.items\n\n    def __getitem__(self, index):\n        if index &gt;= self.capacity or index &lt; -self.capacity:\n            raise IndexError(\"Index out of range\")\n        return self.items[index]\n\n    def __setitem__(self, index, val):\n        if index &gt;= self.capacity or index &lt; -self.capacity:\n            raise IndexError(\"Index out of range\")\n        self.items[index] = val\n\n    def __delitem__(self, index):\n        raise NotImplementedError(\"StaticArray does not support deletion\")\n\n\nsa = StaticArray([1, \"hi\", 3.14, True])\nlen(sa)\n\n4\n\n\n\n42 in sa\n\"hi\" in sa\n\nTrue\n\n\n\nsa[3]\n\nTrue\n\n\n\ntry:\n    sa[42] = \"hello\"\nexcept Exception as e:\n    print(repr(e))\n\nIndexError('Index out of range')\n\n\n\n\nIteration Revisited\nRemember that we have iterables, and iterators.\nObjects like lists, tuples, and strings are iterable.\nTo keep track of the position within a given iteration (for loop, calls to next), Python uses an iterator.\n\nll = [1, 2, 3, 4]\niterator = iter(ll)\nprint(\"iterator 1 next()\", next(iterator))\nprint(\"iterator 1 next()\", next(iterator))\niterator2 = iter(ll)\nprint(\"iterator 2 next()\", next(iterator2))\nprint(\"iterator 1 next()\", next(iterator))\n\niterator 1 next() 1\niterator 1 next() 2\niterator 2 next() 1\niterator 1 next() 3\n\n\nTo be iterable, a class needs an __iter__ method that returns an iterator.\nAn iterator is an object with a __next__ method that returns the next item in the iteration. It should raise StopIteration when there are no more items.\nCommon Pattern: If a class only needs to be iterable once, it can return itself as the iterator, thus fulfilling both roles.\nfor i in iterable:\n    print(i)\n\niterator = iter(iterable)\nwhile True:\n    print(next(iterator))\n\nclass SimpleRange:\n    def __init__(self, n):\n        self.current = 0\n        self.n = n\n\n    def __iter__(self):\n        print(\"iter has been called\")\n        return self\n\n    def __next__(self):\n        if self.current &gt;= self.n:\n            print(\"at the end\")\n            raise StopIteration\n        else:\n            print(f\"next was called, moving {self.current} to {self.current+1}\")\n            self.current += 1\n            return self.current - 1\n\n    def __repr__(self):\n        return f\"SimpleRange({self.n}, current={self.current})\"\n\n\nsr = SimpleRange(3)\nfor i in sr:\n    for j in sr:\n        print(i, j)\n\niter has been called\nnext was called, moving 0 to 1\niter has been called\nnext was called, moving 1 to 2\n0 1\nnext was called, moving 2 to 3\n0 2\nat the end\nat the end\n\n\n\nsr = SimpleRange(5)\nsiter = iter(sr)\nprint(siter)\n\niter has been called\nSimpleRange(5, current=0)\n\n\n\nsiter is sr\n\nTrue\n\n\n\nnext(siter)\nprint(siter)\n\nnext was called, moving 0 to 1\nSimpleRange(5, current=1)\n\n\n\nIteration Advice\n\nDo not implement the __next__() in a class that should only be an iterable.\nIn order to support multiple traversals, the iterator must be a seperate object.\nA common design pattern is to delegate iteration to a seperate class that is iterable.\n\nFor example, defining an StaticArrayIterator class that is in charge iterating through the objects within an StaticArray object.\n\n# Adding __iter__ to StaticArray\nclass StaticArrayIterator:\n    def __init__(self, values):\n        self.values = values\n        self.position = 0\n\n    def __next__(self):\n        if self.position &gt;= len(self.values):\n            raise StopIteration\n        item = self.values[self.position]\n        self.position += 1\n        return item\n\n    def __repr__(self):\n        return f\"iterating over {self.values}, at position {self.position}\"\n\n\nclass StaticArray:\n    def __init__(self, capacity, initial=None):\n        self._items = [initial] * capacity\n        self._capacity = capacity\n        self._iter_position = 0\n\n    @classmethod\n    def from_iterable(self, iterable):\n        new_array = StaticArray(len(iterable))\n        for idx, item in enumerate(iterable):\n            new_array._items[idx] = item\n        return new_array\n\n    def __repr__(self):\n        # __repr__ is the unambiguous string representation\n        # of an object\n        return f\"StaticArray({self._capacity}, {self._items})\"\n\n    def __str__(self):\n        return repr(self._items)\n\n    # Sequence Operations\n\n    def __len__(self):\n        return self._capacity\n\n    def __contains__(self, x):\n        return x in self._items\n\n    def __getitem__(self, i):\n        if i &gt;= self._capacity or i &lt; -self._capacity:\n            raise IndexError  # an invalid index\n        return self._items[i]\n\n    def __setitem__(self, i, x):\n        if i &gt;= self._capacity or i &lt; -self._capacity:\n            raise IndexError  # an invalid index\n        self._items[i] = x\n\n    def __delitem__(self, i):\n        raise NotImplementedError(\"Cannot delete from a static array\")\n\n    # Iterable Operations\n    def __iter__(self):\n        return StaticArrayIterator(self._items.copy())\n\n\nsa = StaticArray(5, 2)\nsa[0] = 1\nsa[1] = 2\nsa[2] = 3\nsa[3] = 4\nsa[4] = 5\nprint(sa)\nfor x in sa:\n    for y in sa:\n        print(x, y)\n\n[1, 2, 3, 4, 5]\n1 1\n1 2\n1 3\n1 4\n1 5\n2 1\n2 2\n2 3\n2 4\n2 5\n3 1\n3 2\n3 3\n3 4\n3 5\n4 1\n4 2\n4 3\n4 4\n4 5\n5 1\n5 2\n5 3\n5 4\n5 5",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Python Data Model</span>"
    ]
  },
  {
    "objectID": "pdm/index.html#bonus-more-dunder-methods",
    "href": "pdm/index.html#bonus-more-dunder-methods",
    "title": "16  Python Data Model",
    "section": "Bonus: More Dunder Methods",
    "text": "Bonus: More Dunder Methods\n\nContext Managers / with\nWe also saw this idea of needing to clean up after ourselves when we used with to open files.\n\nwith open(filename) as f:\n    # do things with f\n    g(f)\n# f is guaranteed to be closed even if \n# exceptions are raised within with block\n\nclass DatabaseConnection:\n    def __init__(self, username, password):\n        # connect to database\n        self.username = username\n        self.password = password\n        self.connected = True\n\n    def __enter__(self):\n        print(\"__enter__\")\n        # must return self!\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_traceback):\n        print(\"__exit__\")\n        if exc_type:\n            print(\"rolling back changes\")\n        self.connected = False\n\n    def query(self, sql):\n        print(\"ran query\", sql)\n\n    def __repr__(self):\n        return f\"Connection connected={self.connected}\"\n\n\ndb = DatabaseConnection(\"hello\", \"world\")\ndb.query(\"SELECT * FROM users;\")\n\ntry:\n    # do something dangerous\n    1 / 0\nexcept Exception as e:\n    print(repr(e))\n\n# our connection is possibly left in a broken state\nprint(db)\n\nran query SELECT * FROM users;\nZeroDivisionError('division by zero')\nConnection connected=True\n\n\nwith DatabaseConnection(\"hello\", \"world\") as db:\n    # __enter__\n    db.query(\"SELECT * from users;\")\n    1 / 0\n    # __exit__\n\n# changes were rolled back, and our connection is safe\ndb.connected\n\nTrue\n\n\n\n\nCallable Objects Examples\nFunctions have a few attributes like __name__ and __doc__ that we can use to introspect on them.\n\ndef add(x, y):\n    \"\"\"Adds two numbers\"\"\"\n    return x + y\n\n\nprint(add.__name__)\nprint(add.__doc__)\n\nx = add\n\nadd\nAdds two numbers\n\n\n\nx.__name__\n\n'add'\n\n\n\nclass Example:\n    def __init__(self, name):\n        self.name = name\n        self.num_calls = 0\n    def __call__(self, *args):\n        print(self.num_calls)\n        self.num_calls += 1\n        print(self.name, \"got\", args)\n\nexample = Example(\"one\")\ntwo = Example(\"two\")\n\n\nexample(1, 2, 3)\n\n0\none got (1, 2, 3)\n\n\n\ntwo()\n\n0\ntwo got ()\n\n\nThey also have a __call__ method that allows us to make our own objects callable. For example:\n\nclass Memoized:\n    def __init__(self, func):\n        self.cache = {}\n        self.wrapped_func = func\n\n    def __call__(self, *args):\n        if args not in self.cache:\n            self.cache[args] = self.wrapped_func(*args)\n        return self.cache[args]\n\n\n@Memoized\ndef expensive_func(a, b, c):\n    print(\"running expensive_func\")\n    return a + b + c\n\n#expensive_func = Memoized(expensive_func)\n\nprint(expensive_func(1, 2, 3))\nprint(expensive_func(1, 2, 3))\n\nrunning expensive_func\n6\n6\n\n\n\nclass PartialFunc:\n    # simplified functools.partial\n\n    def __init__(self, func, *args, **kwargs):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n\n    def __call__(self, *args, **kwargs):\n        temp_kwargs = self.kwargs.copy()\n        temp_kwargs.update(kwargs)\n        return self.func(*(self.args + args), **temp_kwargs)\n\n    @property\n    def __name__(self):\n        return f\"{self.func.__name__}(args={self.args} kwargs={self.kwargs})\"\n\n    @property\n    def __doc__(self):\n        return self.func.__doc__\n\n\ndef add(x, y):\n    \"\"\"Adds two numbers\"\"\"\n    return x + y\n\nadd_5 = PartialFunc(add, 5)\nprint(add_5(10))\n\nprint(add_5.__name__)\nprint(add_5.__doc__)\n\n15\nadd(args=(5,) kwargs={})\nAdds two numbers",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Python Data Model</span>"
    ]
  },
  {
    "objectID": "more-classes/index.html",
    "href": "more-classes/index.html",
    "title": "17  Class Methods & Properties",
    "section": "",
    "text": "Encapsulation\nWe’ve discussed how a fundamental principle of class-based OOP is that a class should be usable without needing to understand, or even know how data is stored within.\nWe call this encapsulation, the bundling of data with all behaviors that can act on or modify that data. This separation of concerns is what allows you to use a Python dictionary without worrying about hashtable semantics, or a list without thinking about memory allocation.\nAnother way to put this is that a class should be responsible for any modifications to its internal state.\nWhen you are working on a large team, proper use of encapsulation/OOP provides one mechanism to ensure that your changes won’t break other people’s code. Encapsulation allows the implementation of an object’s interface to be changed without impacting the users of that object.”\nTo understand this better, let’s look at why it may be a bad idea to allow users to change attributes:\nImagine that in our data year is sometimes an integer and sometimes a string, but we always want to be able to calculate a vehicles age, we could decide to force the type in the constructor:\nWe also protect against trying to roll back the odometer by driving in reverse by ensuring that drive only accepts positive values.\nThis may not be sufficient however, a user might still see the year attribute and assume they can set it themselves, outside the constructor, or modify mileage directly.\nTo help enforce encapsulation, languages often provide features like private attributes, getters & setters, and properties. We’ll take a look at how Python approaches these.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Class Methods & Properties</span>"
    ]
  },
  {
    "objectID": "more-classes/index.html#encapsulation",
    "href": "more-classes/index.html#encapsulation",
    "title": "17  Class Methods & Properties",
    "section": "",
    "text": "car2.mileage -= 100     # rewind the odometer\ncar2.hybrid = \"no\"      # should have been False & probably immutable\n\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = int(year)   # coerce to int year\n        self.mileage = 0\n        self.hybrid = False\n        \n    def drive(self, miles):\n        if miles &lt; 0:\n            raise ValueError('miles must be positive')\n        self.mileage += miles",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Class Methods & Properties</span>"
    ]
  },
  {
    "objectID": "more-classes/index.html#there-is-no-private-in-python",
    "href": "more-classes/index.html#there-is-no-private-in-python",
    "title": "17  Class Methods & Properties",
    "section": "There is no “private” in Python",
    "text": "There is no “private” in Python\nSome languages use access specifiers like “private”, “public”, “protected” to disallow modifications from outside of the class. With these keywords in Java for instance, modification of private attributes is restricted to methods of the class.\nPython does not have this kind of variable, and instead relies on convention, we signal to other programmers what we expect them to do. If they choose to break those rules, they can expect to deal with unintended consequences or interface breakage.\nBy convention a name with a single underscore at the front is meant to be “internal” to the class, and should not be modified except from methods of that class. (self._mileage, self._year)\nGoing a step further, a name with a double underscore at the front is actually modified internally by Python to avoid people assigning to it accidentally.\n\nclass Car: \n    def __init__(self, make, model, year):\n        self._make = make \n        self._model = model \n        self._year = year\n        self.__mileage = 0\n                \n    def drive(self, miles):\n        if miles &gt; 0:\n            self.__mileage += miles\n        else:\n            ...\n            \n    def print_report(self):\n        print(f\"{self._year} {self._make} {self._model} with {self.__mileage} miles\")\n    \ncar1 = Car(\"Honda\", \"Civic\", 2019)\ncar2 = Car(\"Chevy\", \"Volt\", 2022)\n\ncar2.drive(500)\ncar2.print_report()\n\n2022 Chevy Volt with 500 miles\n\n\n\ncar2._year\n\n2022\n\n\n\ndir(car2)\n\n['_Car__mileage',\n '__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__firstlineno__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getstate__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__static_attributes__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_make',\n '_model',\n '_year',\n 'drive',\n 'print_report']\n\n\n\n# soft protection, can still access but \"at your own risk\"\ncar2._make = \"???\"\nprint(car2._make) \n\n???",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Class Methods & Properties</span>"
    ]
  },
  {
    "objectID": "more-classes/index.html#getters-setters",
    "href": "more-classes/index.html#getters-setters",
    "title": "17  Class Methods & Properties",
    "section": "Getters / Setters",
    "text": "Getters / Setters\nTo avoid issues with people depending on internal attributes, it is common in some languages (and tempting in Python) to force users to make all modifications through get & set methods, sometimes called getters and setters:\n\nclass Person:\n    def __init__(self, name, age):\n        self.__name = name  #  Assume it has getter/setters not shown here\n        self.set_age(age)\n\n    def get_age(self):\n        return self.__age\n\n    def set_age(self, age):\n        # can protect against invalid data\n        if age &lt; 0:\n            raise ValueError(\"Person can't have a negative age!\")\n        self.__age = age\n\n\np = Person(\"C. Montgomery Burns\", 100)\n\n\np.get_age()\n\n100\n\n\n\np.set_age(101)\n\n\np.get_age()\n\n101\n\n\n\ntry:\n    p.set_age(-1)\nexcept Exception as e:\n    print(repr(e))\n\nValueError(\"Person can't have a negative age!\")\n\n\nThis is a fine solution when there is work for the getters & setters to do, but often there isn’t– and they’ll (at least initially) be very repetitive.\nWe still must provide them from the start, because if we didn’t we couldn’t make changes to the class (for example, storing birthdate instead of age) since there would be code in our program that directly accessed Person.age.\nHowever, in Python, we tend not to use getters and setters, instead we allow attributes that are meant to be changed to be set directly.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Class Methods & Properties</span>"
    ]
  },
  {
    "objectID": "more-classes/index.html#properties",
    "href": "more-classes/index.html#properties",
    "title": "17  Class Methods & Properties",
    "section": "Properties",
    "text": "Properties\nThis difference is possible because of how Python allows us to define properties.\nSay we want the advantages of encapsulation (being able to avoid improper use, hiding our internal representation, etc.) but without the need to start with a bunch of getter/setter functions that aren’t (yet) needed.\nThere is a built in function property() that creates and returns a property object.\nproperty(fget=None, fset=None, fdel=None, doc=None)\n\nfget is a function to get value of the attribute\nfset is a function to set value of the attribute\nfdel is a function to delete the attribute\ndoc is a docstring for the attribute\n\n\nclass Person:\n    \n    def __init__(self, name, age):\n        self.name = name  #  Assume it has getter/setters \n        self.age = age\n\n    def _get_age(self):\n        print(\"inside get age\")\n        return self.__age\n\n    def _set_age(self, age):\n        if age &lt; 0:\n            raise ValueError(\"Person can't have a negative age!\")\n        self.__age = age\n        \n    def __repr__(self):\n        return f\"Person({self.__name!r}, {self.__age})\"\n        \n    age = property(_get_age, _set_age, doc=\"age of the person\")\n\n\np = Person(\"Wayne\", 30)\np.age # will call _get_age\n\ntry:\n    p.age = -1 # will call _set_age\nexcept Exception as e:\n    print(repr(e))\n\nprint(p.age)\n\ninside get age\nValueError(\"Person can't have a negative age!\")\ninside get age\n30\n\n\n\n@property\nWe can also use property as a decorator.\nThe usage looks a bit strange since we need to decorate multiple functions:\n\nPlace the @property directly above the function header of the getter function.\nPlace the code @name_of_property.setter above the function header of the setter function. You need to replace the name_of_property with the actual name of the property.\nThe function names for both the setter/getter need to match.\n\n\nclass Person:\n    def __init__(self, name, age):\n        self.__name = name  #  Assume it has getter/setters \n        # invokes setter\n        self.age = age #self.set_age(age)\n        self.birth_date = ...\n\n    @property\n    def age(self):\n        \"\"\" returns the age property \"\"\"\n        print('getter called')\n        return self.__age\n    # same as \n    #age = property(age)\n    \n    @age.setter\n    def age(self, age):\n        print('setter called')\n        if age &lt; 0:\n            raise ValueError(\"Person can't have a negative age!\")\n        self.__age = age\n        \n    def __repr__(self):\n        return f\"Person({self.__name!r}, {self.__age})\"\n\nThe existence of properties allows us to start all attributes out as public ones, and convert to properties as needed. The user of the class does not need to know that a change was made, preserving encapsulation without forcing us into calling setter/getters.\n\n\nRead-only/Calculated Properties\n\nclass Rectangle: \n    \n    def __init__(self,width,height):\n        self.width = width \n        self.height = height\n        # this would only happen once and not update when width or height are changed\n        # self.area = width*height\n    \n    # read-only calculated property (no setter)\n    @property \n    def area(self):\n        return self.width * self.height \n\n\nr = Rectangle(3, 9)\n\n\nprint(r.area)\n\n27\n\n\n\n# area is dynamically calculated each call\nr.width = 6\nprint(r.area)\n\n54\n\n\n\n# but can't be set\ntry:\n    r.area = 4\nexcept Exception as e:\n    print(\"ERROR\", e)\n\nERROR property 'area' of 'Rectangle' object has no setter",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Class Methods & Properties</span>"
    ]
  },
  {
    "objectID": "more-classes/index.html#class-attributes",
    "href": "more-classes/index.html#class-attributes",
    "title": "17  Class Methods & Properties",
    "section": "Class Attributes",
    "text": "Class Attributes\nSometimes we want to share data between all instances of a given class.\nAll cars have 4 wheels, so we could define a shared variable accessible to all instances of the Car class.\nTo do this, we create them within the class body, usually right above the __init__.\n\nimport datetime\n\nclass Car:\n    # class attribute\n    wheels = 4\n    registrations = []\n\n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n        # add this car to the global registry of all cars\n        Car.registrations.append(self)\n\n        # setting this attribute would shadow Car.wheels\n        # both would exist, but we'd need to be explicit\n        # about which we intended to use (avoid this!)\n        # self.wheels = 0\n    \n    def compute_age(self):\n        return datetime.date.today().year - self.year \n    \n    \ncar1 = Car(\"Honda\", \"Accord\", 2019)\ncar2 = Car(\"Toyota\", \"RAV4\", 2006)\n\n\n# class attribute can be accessed on instances, or the class itself\nprint(Car.wheels)\nprint(car1.wheels)\nprint(car2.wheels)\n\n4\n4\n4\n\n\n\n# these are all the same variable\nCar.wheels is car1.wheels\n\nTrue\n\n\n\n# this means changes to the class attribute affect all classes\n\nCar.wheels = 3\nprint(car1.wheels)\nprint(car2.wheels)\n\n3\n3\n\n\n\n# Careful: assigning to an instance attribute makes a new attribute\n\n# creates a new instance variable! not what we wanted!\ncar2.wheels = 2\nprint(car2.wheels is car1.wheels)\nprint(car1.wheels)\nprint(Car.wheels)\n\nFalse\n3\n3",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Class Methods & Properties</span>"
    ]
  },
  {
    "objectID": "more-classes/index.html#class-methods",
    "href": "more-classes/index.html#class-methods",
    "title": "17  Class Methods & Properties",
    "section": "Class Methods",
    "text": "Class Methods\nIt can also be useful to provide methods that are accessible to all instances of a class.\nClass methods are similar to instance methods with a few distinctions:\n\nThey can not access instance methods or attributes.\nThe first argument to the method is not self, but instead cls by convention. cls is the class object itself (e.g. Car)\nClass methods are declared with the @classmethod decorator.\n\n\nfrom datetime import date\n\nclass Car: \n    \n    # wheels class attribute \n    wheels = 4\n    # tire pressure class attribute  \n    psi = 35 \n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n    \n    def compute_age(self):\n        print(self)\n        current_year = int(date.today().year)\n        return current_year - self.year \n    \n    @classmethod \n    def tire_description(cls):\n        print(cls)\n        return f'Car has {cls.wheels} wheels with a tire pressure of {Car.psi}' \n    \ncar1 = Car(\"Honda\", \"Accord\", 2019)\ncar2 = Car(\"Toyota\", \"RAV4\", 2006)\n\n\nprint(Car.tire_description())\n#print(car1.tire_description())\nprint(car1.compute_age())\n\n&lt;class '__main__.Car'&gt;\nCar has 4 wheels with a tire pressure of 35\n&lt;__main__.Car object at 0x106872660&gt;\n7\n\n\nNotice that we can use Car.psi or cls.wheels to access class attributes. cls is generally preferred, both to avoid repetition and for reasons we’ll see when we get to inheritance.\nFinally, note that we can access class methods and instances from within instance methods. (but not vice-versa!)\n\nfrom datetime import date\nclass Car: \n    \n    # wheels class attribute \n    wheels = 4\n    \n    # tire pressure amount \n    psi = 35 \n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n    \n    def compute_age(self):\n        current_year = int(date.today().year)\n        return current_year - self.year \n    \n    @classmethod \n    def tire_description(cls):\n        return f'Car has {cls.wheels} wheels, each with a tire pressure of {Car.psi}' \n\n    def __repr__(self): \n        instance_str = f'Car(make={self.make}, model={self.model}, year={self.year}, '\n        instance_str += f'wheels={Car.wheels}, {self.tire_description()})'\n        return instance_str\n\n\ncar1 = Car(\"Honda\", \"Civic\", 2019)\nprint(car1)\n\nCar(make=Honda, model=Civic, year=2019, wheels=4, Car has 4 wheels, each with a tire pressure of 35)\n\n\n\nAlternate Constructors\nA common use of class methods is to define alternate ways to initialize an isntance. In Python there can only be one constructor (__init__), whereas some other languages allow multiple.\nPerhaps we have Car data coming from a file, meaning we’d have strings like:\n\ncar1str = \"Pontiac|Grand Am|1997|4892\"\ncar2str = \"Ford|Mustang|1970|800\"\ncar3str = \"Hyundai|Sonata|2007|0\"\n\n\ndef make_car_from_string(s: str) -&gt; Car:\n    ...\n\n\nfrom datetime import date\n\nclass Car: \n    wheels = 4\n    psi = 35\n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n        self.mileage = 0\n        \n    @classmethod\n    def from_string(cls, string):\n        make, model, year, mileage = string.split(\"|\")\n        # invoke Car's constructor\n        new_instance = cls(make, model, year)\n        new_instance.mileage = mileage\n        return new_instance\n    \n    def compute_age(self):\n        current_year = int(date.today().year)\n        return current_year - self.year \n    \n    @classmethod \n    def tire_description(cls):\n        return f'Car has {cls.wheels} wheels, each with a tire pressure of {Car.psi}' \n\n    def __repr__(self): \n        instance_str = f'Car(make={self.make}, model={self.model}, year={self.year}, '\n        instance_str += f'wheels={Car.wheels})'\n        return instance_str\n\n\ncar1 = Car.from_string(car1str)\ncar2 = Car.from_string(car2str)\ncar3 = Car.from_string(car3str)\n\n\nprint(car1)\nprint(car2)\nprint(car3)\n\nCar(make=Pontiac, model=Grand Am, year=1997, wheels=4)\nCar(make=Ford, model=Mustang, year=1970, wheels=4)\nCar(make=Hyundai, model=Sonata, year=2007, wheels=4)\n\n\nThis is a common pattern, seen throughout Python:\n\nint.from_bytes()\nfloat.fromhex()\ndatetime.date.fromtimestamp()\nitertools.chain.from_iterable()\n\nx = list(map(...))\ny = dict(...)\n\nimport datetime\ndatetime.date(2024, 11, 11)\n\ndatetime.date(2024, 11, 11)\n\n\n\ndatetime.date.fromtimestamp(1234567890)\n\ndatetime.date(2009, 2, 13)\n\n\n\nimport itertools\nfor x in itertools.chain.from_iterable([(1,2,3), (4,5,6)]):\n    print(x)\n#for x in (1,2,3):\n#    print(x)\n#for x in (4,5,6):\n#    print(x)\n\n1\n2\n3\n4\n5\n6\n\n\n\n\nstaticmethod\nSometimes it makes sense to just attach a method to a class for the purpose of namespacing.\n\ndef which_is_newer(a, b):\n    if a.year &gt; b.year:\n        return a\n    else:\n        return b\n\nwhich_is_newer(car1, car2)\n\nCar(make=Pontiac, model=Grand Am, year=1997, wheels=4)\n\n\n\n# it might make sense to attach this to the class, \n# but neither a classmethod nor an instance method\n\nfrom datetime import date\nclass Car: \n    wheels = 4\n    psi = 35\n    \n    # does not take self or cls\n    @staticmethod\n    def which_is_newer(a, b):\n        if a.year &gt; b.year:\n            return a\n        else:\n            return b\n        \n    @staticmethod\n    def something():\n        return []\n    \n\n    \n    def __init__(self, make, model, year):\n        self.make = make \n        self.model = model \n        self.year = year\n        \n    @classmethod\n    def from_string(cls, string):\n        make, model, year = string.split(\"|\")\n        # invoke Car's constructor\n        return cls(make, model, year)\n\n    def __repr__(self): \n        instance_str = f'Car(make={self.make}, model={self.model}, year={self.year}, '\n        instance_str += f'wheels={Car.wheels})'\n        return instance_str\n\n\n# now would be called this way\nCar.which_is_newer(car1, car2)\n\nCar(make=Pontiac, model=Grand Am, year=1997, wheels=4)\n\n\nThere is nothing special about a staticmethod, it can always be replaced by a method outside of the class. It is a matter of preference.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Class Methods & Properties</span>"
    ]
  },
  {
    "objectID": "packages/index.html",
    "href": "packages/index.html",
    "title": "18  Python Packages",
    "section": "",
    "text": "Terminology\nGoals\nBefore we get started, it is probably helpful to review some terminology:\nPython modules are single .py files. Modules are a useful way to group related code, you may keep all code related to the database in a db.py file and everything related to the user interface in a ui.py file.\nPython packages are one or more .py files, typically in a directory. You will sometimes here these referred to as libraries when they are meant to be used by other developers. Some packages you’ve already seen would be built-in ones like math or pathlib, or third-party packages like pandas and pytest.\nFinally, Python applications are packages that are meant to be run. A package may be useful as a library as well as an application.\nFor example, Python’s built in http library allows one to work with the HTTP protocol in their own code, but it also contains an application that will let you start an HTTP server:\nWill start a local web server making the contents of the current directory available at http://localhost:8000.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Python Packages</span>"
    ]
  },
  {
    "objectID": "packages/index.html#terminology",
    "href": "packages/index.html#terminology",
    "title": "18  Python Packages",
    "section": "",
    "text": "$ python3 -m http.server",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Python Packages</span>"
    ]
  },
  {
    "objectID": "packages/index.html#how-do-packages-work",
    "href": "packages/index.html#how-do-packages-work",
    "title": "18  Python Packages",
    "section": "How do packages work?",
    "text": "How do packages work?\nA Python package is typically a directory containing one or more .py files.\nAn example project layout might look like this:\nbaking-pkg\n├── baking\n│   ├── __init__.py\n│   ├── cli.py\n│   ├── ingredients.py\n│   ├── sizes.py\n│   ├── units.py\n│   └── utils.py\n├── LICENSE\n├── README.md\n└── tests\n    ├── test_baking.py\n    ├── test_units.py\n    └── test_utils.py\nThe package is the directory baking. The inclusion of an (often empty) __init__.py marks the directory as a package.\nThis hypothetical library would be imported via import baking. Or there could be nested imports such as from baking.units import Liter. (Remember: the slashes in paths become dots when we’re using Python paths.)",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Python Packages</span>"
    ]
  },
  {
    "objectID": "packages/index.html#imports-and-sys.path",
    "href": "packages/index.html#imports-and-sys.path",
    "title": "18  Python Packages",
    "section": "Imports and sys.path",
    "text": "Imports and sys.path\nWhen you type import baking, Python will not immediately find the package.\nPython has what we often refer to as a search path. When you import something, Python searches a list of directories for a package or module with that name.\nIn Python’s case the special variable sys.path is a list of strings that make up the search path.\nExecuting the code:\nimport sys\n\nfor p in sys.path:\n    print(p)\nMight output something like:\n/opt/python@3.13/Python/Versions/3.13/lib/python313.zip\n/opt/python@3.13/Python/Versions/3.13/lib/python3.13\n/opt/python@3.13/Python/Versions/3.13/lib/python3.13/lib-dynload\n/opt/python3.13/site-packages\nOn your system it will vary, but this shows the list of directories that Python will search when you type import baking.\nIf it finds a baking/__init__.py or baking.py it will execute it and stop the search. If it checks them all without success, it raises an ImportError.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Python Packages</span>"
    ]
  },
  {
    "objectID": "packages/index.html#imports-relative-imports",
    "href": "packages/index.html#imports-relative-imports",
    "title": "18  Python Packages",
    "section": "Imports & Relative Imports",
    "text": "Imports & Relative Imports\nNow’s a good time to review the different ways you can import modules and packages.\nimport module_name\nImports the module and makes it available in the current namespace. You can access the module’s functions by prefixing them with the module name. For example, for the module math with a function called sin, you can access it by calling math.sin().\nfrom module_name import module_attr\nImports a specific attribute from a module and makes it available in the current namespace. For example, from math import sin will import the sin function from the math module and make it available in the current namespace. You can then call it directly by calling sin().\nimport module_name as alias or from module_name import module_attr as alias\nImports a module or attribute and gives it an alias. For example, import pandas as pd will import the pandas module and make it available as pd. You can then access the DataFrame class as pd.DataFrame. This is commonly used in data science libraries (import numpy as np, import pandas as pd, etc) but overuse can make code harder to read. It’s best to use aliases sparingly.\nfrom module import *\nMakes full contents of module available in the current namespace.\n\nWhy we don’t use import * in our programs.\nMost style guides for large projects ban import *. Consider it banned in this course as well.\nIt breaks a very nice feature of Python that you may take for granted if you’ve never used another language. Typically, if you see a symbol like BASE_URL or download used in a file you are guaranteed it is either declared in that file, or you can look at the import statements and discover where it came from.\nimport * breaks this rule, making it difficult to track down where a symbol came from, especially if there is more than one star import.\nThis also can lead to bugs:\nfrom math import *\nfrom travel import *\n\n...\n\ndist(chicago, philadelphia)\nDoes this use math.dist’s euclidean distance or a function named dist defined within travel?\nThe answer would vary based on changes to the other files or re-ordering the imports. That’s a confusing bug just waiting to happen.\n\n\n\n\n\n\nNoteCan we ever use import *?\n\n\n\nIt is OK to use import * in one-off scripts that nobody else will maintain, or more commonly, in the REPL.\nSince these are short-lived invocations there is minimal chance of confusion, and you aren’t creating a maintenance nightmare for anybody.\n\n\n\n\nRelative Imports\nWhen working with packages, we have the option to also use relative imports.\nThese imports allow you to refer to other files from the same package without specifying the full path.\nLet’s imagine a larger project with a few sub-packages:\nboard_game\n├── __init__.py\n├── ui\n│   ├── __init__.py\n│   ├── gui.py\n│   └── images.py\n├── network\n│   ├── __init__.py\n│   ├── high_score.py\n│   └── matchmaking.py\n└── logic\n    ├── __init__.py\n    ├── rules.py\n    └── scoring.py\nWith traditional absolute imports, code within board_game/ui/gui.py would need to import other packages by their full path:\n# within board_game/ui/gui.py\nfrom board_game.ui.images import Piece\nfrom board_game.logic.scoring import check_victory\nRelative imports offer an alternative that is less repetitious:\n# within board_game/ui/gui.py\nfrom .images import Piece\nfrom ..logic.scoring import check_victory\nIn this example .images refers to the file images.py which is in the same directory as gui.py, which is why the import starts with a ..\nThen ..logic.scoring traverses up a directory (from ui/ to logic/) and then imports the scoring.py file.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Python Packages</span>"
    ]
  },
  {
    "objectID": "packages/index.html#creating-application-entrypoints",
    "href": "packages/index.html#creating-application-entrypoints",
    "title": "18  Python Packages",
    "section": "Creating application entrypoints",
    "text": "Creating application entrypoints\nWhen a package is imported, the .py file is executed, so if a file contained:\n# tlprint.py\nprint(\"debug statment inside baking2\")\n\ndef some_func(...):\n    ...\nWhether you executed import tlprint or from tlprint import some_func, you would see the output of the print function since the entire file needs to be executed to complete the import.\nIf you have code that you only want to be run when the .py file is executed as a program, you can put it in a special block:\n# main_demo.py\ndef some_func(...):\n    ...\n\nif __name__ == \"__main__\":\n    print(\"run as a program\")\nThe statement if __name__ == \"__main__\" checks a special built-in variable named __name__ that contains the name of the imported module.\nIf the module is imported the normal way, this condition will be false, but if the program is executed from the command line via either:\n$ python3 main_demo.py\nor\n$ python3 -m main_demo\nThe special variable __name__ will be set to __main__, indicating that it is being run as a program, not imported as a library.\n\nCommand Line Arguments\nWhichever way you run a Python module, you can pass command line arguments to it.\nThese arguments wind up in a special list called sys.argv. The first element sys.argv[0] is the name of the module.\nThe second element is the first command line argument, and so on.\nIf you take the file argdemo.py:\n\nExecuting it lets you see how argv works in practice:\n$ python3 argdemo.py -k filename.txt \nprogram name: argdemo.py\nargv[1]: -k\nargv[2]: filename.txt\nYour program could then use the contents of sys.argv however you wanted.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Python Packages</span>"
    ]
  },
  {
    "objectID": "packages/index.html#further-exploration",
    "href": "packages/index.html#further-exploration",
    "title": "18  Python Packages",
    "section": "Further Exploration",
    "text": "Further Exploration\n\nPackages & Modules\n\nOfficial Python Tutorial on Modules & Packages\nPython Language Reference: The import system.\n\n\n\nArgument Parsing\nIn practice, parsing sys.argv yourself is limiting.\nIf you’d like to write programs that take many options like ls, cd, and git you will benefit from using a package to manage the parameters.\nSome common libraries include:\n\nargparse - Built in to Python, but a bit verbose for larger applications.\nclick - Popular and easy to get started with.\ntyper - Built on top of click and uses type annotations to generate help text.\ndocopt - A novel approach using a docstring to define arguments.",
    "crumbs": [
      "Modules & Objects",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Python Packages</span>"
    ]
  },
  {
    "objectID": "data-structures/index.html",
    "href": "data-structures/index.html",
    "title": "19  Data Structures",
    "section": "",
    "text": "What are data structures?\nGoals\nData structures are ways of organizing data in working memory. They are not purely inventions of computer science, but reflect real-world patterns of organizing information.\nData structures like stacks, queues, and trees mimic the way we already think about the world.\nA stack of documents on a desk has the same properties as the stack data structure: the first document finds its way to the bottom of the stack as new ones come in & the document on the top of the stack gets your attention. The queue data structure even more clearly behaves its real-world counterpart: standing in a line being processed by order of arrival is a regular occurrence. And trees map to all kinds of hierarchical relationships: genealogy, organizational structure, file systems, HTML.\nData structures help us model real-world scenarios and play an essential role in writing performant programs. As we’ll see, the choice of data structure can often make a big difference in the complexity class of an algorithm.",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data-structures/index.html#arrays",
    "href": "data-structures/index.html#arrays",
    "title": "19  Data Structures",
    "section": "Arrays",
    "text": "Arrays\nWe’ll start by looking at one of the most fundamental data structures: arrays.\nArrays are collections of items that are stored in contiguous memory.\nThe RAM in your computer can be thought of as a sequential set of boxes that can store individual values. The operating system and programming language assign these blocks to your program as it requires memory for variables.\nIf you were running a Python program with variables:\ns = \"Hello\"\nx = 100*100\ny = 36912\nA snapshot of that memory might look like:\n\n\n\nAddress\nOwned by\nContents\n\n\n\n\n0x7000-0x8000\nSafari\n…\n\n\n0x8016\nyour program\nH\n\n\n0x8020\nyour program\ne\n\n\n0x8024\nyour program\nl\n\n\n0x8028\nyour program\nl\n\n\n0x8032\nyour program\no\n\n\n0x8090-0x8400\nSpotify\n…\n\n\n0x8500\nyour program\n10000\n\n\n0x8504\nyour program\n36912\n\n\n0x8600-0x9000\nSafari\n…\n\n\n\nThis is a simplified version showing a small range of memory. The important details:\n\nEach location in memory has a sequential address associated with it.\nThe memory is allocated in blocks of a standard size (here I am using 4 byte blocks).\nPrograms are not guaranteed contiguous memory, both your program and Safari have disjoint chunks of memory.\nIt is often faster to access contiguous memory than to seek around at random within this space.\n\nAn array is a data structure that consists of a block of contiguous memory to store many similar items near one another.\nIn a language where we can request specifically sized blocks of memory (such as C) you might have:\n// this is C code, not Python\nint my_array[5] = {1, 2, 3, 4, 5};\nThis would allocate memory owned by your program in a contiguous block of 5 integers:\n\n\n\nAddress\nContents\n\n\n\n\n\n0x10000\n1\n\n\n\n0x10004\n2\n\n\n\n0x10008\n3\n\n\n\n0x10012\n4\n\n\n\n0x10016\n5\n\n\n\n\nThe variable array would track the starting address, here 0x10000.\nCode that reads or sets a particular value such as my_array[3] = 100 then needs to compute the offset.\nSince we have contiguous memory and a fixed block size (of 4 bytes for an integer) the language can perform these operations in constant \\(O(1)\\) time.\nmemory_location = initial_offset + block_size * index\nSo to find my_array[3] that would be:\nmemory_location = 0x10000 + 4 * 3 = 0x10012\nThis is why arrays are zero-indexed! The first box with index=0 becomes initial_offset + block_size * 0, or just initial_offset.\nEach array will have its own initial_offset and block_size, the latter determined by the type of data being stored.\n\nPython’s list\nIn Python, list is implemented as an array.\nIt has two properties that not all arrays share however:\n\nIt can store items of heterogeneous type.\nIt can expand as needed, we do not need to pre-define how many elements are in the list.\n\nArrays must have fixed block sizes for the arithmetic above to work, this seems like it may pose problems for both of these use cases.\nTo allow heterogeneous data (including data that may change size), the object stored in each cell of the array is a C type (called PyObject) that we do not interact with directly from Python.\nInstead of each box storing the actual value, they store the PyObject, which in turn stores a pointer or reference to the actual data, which will be stored elsewhere:\n\nNow instead of a direct lookup, the index-based lookup returns the address of the actual data. This remains \\(O(1)\\) since this extra step is a constant operation, and will not take more time as the number of items grows.\nAllowing an array to grow takes another trick: we are going to over-allocate memory.\nWhen you create a new list Python allocates a block of memory that is large enough to hold the list, and then some extra space.\nx = [1, 2, 3]\nThe language might allocate eight memory blocks instead of three.\nNote 1: Numbers for illustration only, implementation details will vary.\nNote 2: I am not showing the extra level of indirection here, instead using the notation -&gt; 1 to remind you that the data stored in that block is not the actual value, but a reference to it.\n\n\n\nAddress\nContents\n\n\n\n\n0x5000\n–&gt; 1\n\n\n0x5004\n–&gt; 2\n\n\n0x5008\n–&gt; 3\n\n\n0x5012\n\n\n\n0x5016\n\n\n\n0x5020\n\n\n\n0x5024\n\n\n\n0x5028\n\n\n\n\nNow when you call x.append(4), Python has room for it already.\nThis keeps the operation \\(O(1)\\), but at the cost of keeping around some empty blocks of memory.\nBut this would only allow our lists to grow up to this arbitrary capacity. What happens in practice is that Python will grow the capacity when some threshold is exceeded.\nIn our hypothetical list, we are now using four of the allocated eight blocks.\nx.append(5)\nx.append(6)\nx.append(7)\nx.append(8)\nx.append(9) # what happens?!\nAs we know, this code will run fine! Python tracks how many cells are used, and if an insertion would cause the capacity to be exceeded it moves the entire list.\nIt cannot just expand in place, since the adjacent memory is likely used by other variables or even other programs. This means that the occasional insertion does need to do more work, copying the list over to a new block of contiguous memory.\nSo after the additional insertions our list may have had it’s items moved, and new additional capacity allocated:\n\n\n\nAddress\nContents\n\n\n\n\n0x9100\n–&gt; 1\n\n\n0x9104\n–&gt; 2\n\n\n0x9108\n–&gt; 3\n\n\n0x9112\n–&gt; 4\n\n\n0x9116\n–&gt; 5\n\n\n0x9120\n–&gt; 6\n\n\n0x9124\n–&gt; 7\n\n\n0x9128\n–&gt; 8\n\n\n0x9128\n–&gt; 9\n\n\n0x9128\n\n\n\n0x9128\n\n\n\n0x9128\n\n\n\n\nNotice it again over allocates. Because this move can be expensive, it will add additional padding so that the next move does not come right away.\nBecause lists (arrays) are typically accessed much more often than they grow, this is a good trade-off in most cases.\nIn practice, the amount of padding that Python adds would affect the memory usage vs. performance of this data structure.",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data-structures/index.html#linked-lists",
    "href": "data-structures/index.html#linked-lists",
    "title": "19  Data Structures",
    "section": "Linked Lists",
    "text": "Linked Lists\nIn Python we typically use a list or tuple to store an ordered sequence of items. This is contrasted with an unordered collection, such as a set.\nThere is another data structure that is useful for ordered sequences:\nLinked lists are ordered collections of items, but use non-contiguous memory.\nEach item in the list contains a pointer to the next item in the list.\n\n# data-structures/linked_list.py\nclass Node:\n    def __init__(self, value, next=None): \n        self.value = value\n        self.next = next\n\nclass LinkedList:\n    def __init__(self):\n        self.root = None\n\n    def __len__(self):\n        count = 0\n        cur = self.root\n        while cur is not None:\n            count += 1\n            cur = cur.next\n\n    def append(self, value):\n        # new tail node\n        new = Node(value)\n        # special case for first node\n        if self.root is None:\n            self.root = new\n        else:\n            cur = self.root\n            # iterate to end-1\n            while cur.next is not None:\n                cur = cur.next\n            # append node\n            cur.next = new\n            \n    def prepend(self, value):\n        # add new node that points at old root\n        new = Node(value, self.root)\n        self.root = new\n\n    def __str__(self):\n        s = \"\"\n        cur = self.root\n        while cur:\n            s += f\"{cur.value} -&gt; \"\n            cur = cur.next\n        s += \"END\"\n        return s\n\nll = LinkedList()\nll.append(1)\nll.append(2)\nll.prepend(0)\nll.prepend(-1)\nll.append(3)\nprint(ll)\n\n-1 -&gt; 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; END\n\n\nTo use an implementation of a doubly-linked list, we use collections.deque.\nThis stores forward & backward references allowing bidirectional traversal at a slightly higher cost.\n\nLinked List vs. Array\n\n\n\nOperation\nLinked List\nArray\n\n\n\n\nAccess by Index\nO(n)\nO(1)\n\n\nInsert/Delete at Start\nO(1)\nO(n)\n\n\nInsert/Delete at End\nO(1)\nO(1)*\n\n\nInsert/Delete at Middle\nO(n)\nO(n)\n\n\n\nIt is also common to have a doubly-linked list, where each item contains a pointer to the next item and the previous item.",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data-structures/index.html#stacks",
    "href": "data-structures/index.html#stacks",
    "title": "19  Data Structures",
    "section": "Stacks",
    "text": "Stacks\nOne of the most common data structures is the stack.\nA stack is a data structure that enables Last In, First Out processing.\nLIFO means that the last item added to the stack is the first item removed.\nThe common analogy is a stack of plates.\nYou also deal with a stack whenever calling functions: the last function called is the first to return.\nInsertions & deletions happen on the same end of the data structure.\n\nCall Stack Example\n\ndef a():\n    print(\"a on call stack\")\n    b()\n    print(\"a off call stack\")\n\ndef b():\n    print(\"  b on call stack\")\n    c()\n    print(\"  b off call stack\")\n\ndef c():\n    print(\"    c on call stack\")\n    print(\"    c off call stack\")\n\na()\n\na on call stack\n  b on call stack\n    c on call stack\n    c off call stack\n  b off call stack\na off call stack\n\n\nWhat data structure is best for a stack?\n\n\nExample Implementation\n\nclass Stack:\n    def __init__(self):\n        # because it is faster to add/remove at the end of a list\n        # we'll treat the end of the list as the top of the stack\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def __str__(self):\n        \"\"\"Return a string representation of the stack.\"\"\"\n        output = []\n        output.append(f\"[ {self.items[-1]} ] &lt;- top\")\n        for item in reversed(self.items[:-1]):\n            output.append(f\"[ {item} ]\")\n        return \"\\n\".join(output)\n\n\nstack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nprint(stack)\n\n[ 3 ] &lt;- top\n[ 2 ]\n[ 1 ]\n\n\nHow would a linked list perform?",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data-structures/index.html#queues",
    "href": "data-structures/index.html#queues",
    "title": "19  Data Structures",
    "section": "Queues",
    "text": "Queues\nIn a queue, the first item added is the first item removed. First In, First Out, or FIFO.\nThe common analogy is a line at a grocery store.\nInsertions & deletions happen on opposite ends of the data structure.\nWhat data structure is best for a queue?\n\nExample Implementation\n\nclass ArrayQueue:\n    def __init__(self, _iterable=None):\n        if _iterable:\n            self._data = list(_iterable)\n        else:\n            self._data = []\n\n    def push(self, item):\n        # adding to the end of the list is faster than the front\n        self._data.append(item)\n\n    def pop(self):\n        # only change from `Stack` is we remove from the other end\n        # this can be slower, why?\n        return self._data.pop(0)\n\n    def __len__(self):\n        return len(self._data)\n\n    def __repr__(self):\n        return \" TOP -&gt; \" + \"\\n        \".join(\n            f\"[ {item} ]\" for item in reversed(self._data)\n        )\n\n\nfrom collections import deque\n\n\nclass DequeQueue:\n    def __init__(self, _iterable=None):\n        if _iterable:\n            self._data = deque(_iterable)\n        else:\n            self._data = deque()\n\n    def push(self, item):\n        self._data.append(item)\n\n    def pop(self):\n        return self._data.popleft()\n\n    def __len__(self):\n        return len(self._data)\n\n    def __repr__(self):\n        return \" TOP -&gt; \" + \"\\n        \".join(\n            f\"[ {item} ]\" for item in reversed(self._data)\n        )\n\n\n\nTesting Queue Performance\n\nimport timeit\n\nnumber = 1_000_000\n\nelapsed = timeit.timeit(\n    \"queue.push(1)\",\n    setup=\"queue = QueueCls()\",\n    globals={\"QueueCls\": ArrayQueue},\n    number=number,\n)\nelapsed2 = timeit.timeit(\n    \"queue.push(1)\",\n    setup=\"queue = QueueCls()\",\n    globals={\"QueueCls\": DequeQueue},\n    number=number,\n)\nprint(f\"{number}x ArrayQueue.push, took\", elapsed)\nprint(f\"{number}x DequeQueue.push, took\", elapsed2)\nprint(f\"DequeQueue is {(elapsed-elapsed2) / elapsed * 100:.3f}% faster\")\n\n1000000x ArrayQueue.push, took 0.022327916929498315\n1000000x DequeQueue.push, took 0.02456929103937\nDequeQueue is -10.038% faster\n\n\n\nnumber = 10_000\n\nelapsed = timeit.timeit(\n    \"queue.pop()\",\n    setup=\"queue = QueueCls([0] * 1000000)\",\n    globals={\"QueueCls\": ArrayQueue},\n    number=number,\n)\nelapsed2 = timeit.timeit(\n    \"queue.pop()\",\n    setup=\"queue = QueueCls([0] * 1000000)\",\n    globals={\"QueueCls\": DequeQueue},\n    number=number,\n)\nprint(f\"{number}x ArrayQueue.pop, took\", elapsed)\nprint(f\"{number}x DequeQueue.pop, took\", elapsed2)\nprint(f\"DequeQueue is {(elapsed-elapsed2) / elapsed * 100:.3f}% faster\")\n\n10000x ArrayQueue.pop, took 1.1975467910524458\n10000x DequeQueue.pop, took 0.00020591693464666605\nDequeQueue is 99.983% faster\n\n\n\n\nQueue Performance\n\n\n\nOperation\nArrayQueue\nDequeQueue\n\n\n\n\npush\nO(1)\nO(1)\n\n\npop\nO(n)\nO(1)",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data-structures/index.html#hash-tables",
    "href": "data-structures/index.html#hash-tables",
    "title": "19  Data Structures",
    "section": "Hash Tables",
    "text": "Hash Tables\nA hash table is a data structure that maps a unique identifying key with some associated value.\nA dict is an implementation of a hash table.\nIf all we wanted to do was associate items with keys, we could store a list of (key, value) tuples in a list.\nThen to look up an item, we would search the list by iterating through and looking for the key. This would be \\(O(N)\\) (or \\(O(\\log N)\\) if we can keep the table sorted).\nLooking up items in a hash table or dictionary is an important task, almost everything in Python relies on the performance of dictionaries.\nAs we’ll see, we can instead write algorithms that will make modifying & accessing individual hash table cells \\(O(1)\\).\n\nHashing\nA key piece of writing a hash table is to use a hashing function.\nThis is a function that will convert a value (often a string) to an arbitrary but consistent integer.\nTo see how this will help, let’s first model a simple hash table with fixed capacity of 10 using a list of 10 empty elements:\n\ncapacity = 10\nstorage = [None] * capacity\n\nFor simplicity we’ll stick to string keys.\nWhen we get a key-value pair, we need to assign it a bucket.\nHow can we write a function that takes a string and assigns it to a bucket?\n\nTurn the string into a number. This is our hash function\nTake (number % capacity) and assign the item to that cell in our array.\n\nFor example:\n\ndef strhash(key):\n    # ord converts a character to it's numeric representation\n    #   ord(\"A\") == 65\n    #   ord(\"z\") == 122\n    # etc.\n    return sum(ord(letter) for letter in key)\n\n\nfor word in (\"bear\", \"fox\"):\n    print(f\"strhash({word}) =\", strhash(word), \"    % 10 = \", strhash(word) % 10)\n\nstrhash(bear) = 410     % 10 =  0\nstrhash(fox) = 333     % 10 =  3\n\n\nSo we would store our items in cells 0 and 3.\n\n# we can use the numeric indices from our hash to read and write from storage\nstorage[strhash(\"bear\") % capacity] = \"cub\"\nstorage[strhash(\"fox\") % capacity] = \"kit\"\n\nfor word in (\"bear\", \"fox\"):\n    print(f\"A baby {word} is called a {storage[strhash(word) % capacity]}.\")\n\nA baby bear is called a cub.\nA baby fox is called a kit.\n\n\n\n\nCollisions\nIf two pieces of data hash to the same value (modulo capacity), we have a collision. Attempting to store the key ‘kangaroo’ would generate such a collision:\n\nprint(\"strhash('kangaroo') % 10 = \", strhash(\"kangaroo\") % capacity)\nstorage[strhash(\"kangaroo\") % capacity] = \"joey\"\n\nprint(\"\\n\" + str(storage))\n\nstrhash('kangaroo') % 10 =  0\n\n['joey', None, None, 'kit', None, None, None, None, None, None]\n\n\nWe’ve overwritten “cub” with “joey”!\nWhile a better hash function might have spread these values out more in the table, no matter what we’ll eventually see collisions.\nThe second thing we’ll need in addition to our hash function is collision resolution.\n\n\nCollision Resolution\nLike hash functions, we have choices available to us.\nThe two most common solutions are separate chaining and open addressing.\nSeparate Chaining\nIn this approach each hash cell itself contains a linked list. (Our underlying structure is then an array of lists.)\nWhenever two keys collide, we will just append the new (key, value) pair to the end of the list.\nTODO: draw picture\nThe other family of approaches is open addressing.\nThis approach includes many algorithms that resolve the collision by picking a new location within the still-flat array, but we will focus on linear probing.\nWhen attempting to write to a key that collided, we will look and see if the next cell is open, and if not that, the next, and so on.\n\n# NOTE: this implementation is intentionally incomplete!\n\ndef set_with_linear_probe(ht_storage, key, value):\n    \"\"\" add a key to our hash table using linear probing algorithm \"\"\"\n    capacity = len(ht_storage)\n    index = strhash(key) % capacity\n   \n    # search until a space is found\n    while True:\n       if ht_storage[index] is None:\n          # a space has been found, add and exit the loop\n          ht_storage[index] = value\n          break\n       else:\n          # move forward looking for space\n          index += 1\n\nNow, when we see a collision, we walk forward a step.\n\nstorage = [None] * 10\nset_with_linear_probe(storage, \"bear\", \"cub\")\nset_with_linear_probe(storage, \"fox\", \"kit\")\nset_with_linear_probe(storage, \"kangaroo\", \"joey\")\nprint(storage)\n\n['cub', 'joey', None, 'kit', None, None, None, None, None, None]\n\n\n‘joey’ is now stored in the second index, since index 0 was full.\nTODO: show storing keys as well\nWhen does this still fail?\n\n\nIf the hash value is near the end of the list, it may reach the end before finding a space. In this case, we wrap around, if there is no room to move forward in the list we loop back to index zero, similarly to how our % capacity operation works.\nEventually however, there will not be any room left in the hashtable.\n\n\n\nResizing & Rehashing\nLike Python’s list, we will maintain some empty cells, additional capacity beyond what is being stored.\nIt is tempting to just grow the capacity:\nht_storage += [None] * 10\nBut what happens if we do this?\nAll of our access rules are based upon hash % capacity!\n\nprint(\"strhash('bear') % 10 = \", strhash(\"bear\") % 10)\nprint(\"strhash('bear') % 20 = \", strhash(\"bear\") % 20)\n\nstrhash('bear') % 10 =  0\nstrhash('bear') % 20 =  10\n\n\nWith positions 11-19 now available, the correct location for items will have changed.\nSince we use the hash to look items up as well as set them, this means that items would go missing if capacity changed!\nInstead, we have to rehash.\nThis means we need to go through all items & compute new hashes whenever we resize.\nWhen to rehash?\nIn practice, we will want to keep our usage close to 50% of our capacity.\nIf you were to wait until the number of items was very close to capacity, the linear probing would be on average \\(O(N)\\).\nConsider the case where our capacity is 10 and we have 9 items already.\nIt would seek forward, but all but one cell would be occupied, so it would be searching through \\(O(N)\\) spots. (In truth closer to N/2, but still \\(O(N)\\) growth.)\nWith 50% capacity, and a good hash function that evenly spreads items through our table, it would typically only step forward 0 or 1 space, keeping average runtime close to \\(O(1)\\).\n\n\nHash Table Performance\nThe performance of our hash table is determined by the algorithms we choose for our hash function and collision resolution.\nWe are aiming for average performance of \\(O(1)\\), but there will be cases that become \\(O(N)\\) as we’ve seen.\n\n\n\nOperation\nAverage\nWorst Case\n\n\n\n\nlookup\nO(1)\nO(n)\n\n\ninsert\nO(1)\nO(n)\n\n\ndelete\nO(1)\nO(n)\n\n\n\nA key property for hash tables is that we do not need to linearly search through them for our data.\nIf you find yourself scanning every element in a hash table, you’re doing something wrong.\n\n\nPolynomial Hash Function\nA good hash function will evenly distribute values across the collection.\nThis can be visualized by imagining the worst possible hash function:\ndef badhash(key):\n    return 7000  # every key hashes to same value\nThis maximizes our collisions. While we can resolve this with linear probing, we wind up with a situation where each item is just stored in the next available spot, and we’re back to \\(O(N)\\) run time.\nThe strhash we defined above isn’t much better in practice: strings tend to be short and use common letters.\nstrhash(\"cat\") == strhash(\"act\")\nand\nstrhash(\"car\") is just two away from to strhash(\"cat\")\nPerformance will improve if our hash function distributes the values more evenly.\nA common pattern is to use a polynomial hash function.\n\\[h(x_0, ..., x_n) = (\\sum_{i=0}^{k-1}{c_ip^i})\\mod{m}\\]\nWhere: - $x_0…x_i $ is the sequence - \\(k = len(x)\\) - \\(c_i\\) is the numeric value of the character \\(x_i\\) (\\(ord(x\\) in Python) - \\(p\\) is an arbitrary constant. - and \\(m\\) is the size of the collection.\nAn effective approach is to use Horner’s method to compute a polynomial whose coefficients are the integer values of the characters in a string:\n\\[\np(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + ... + a_nx^n\n\\]\nwhich, via Horner’s rule is the same as:\n\\[\n= a_0 + x ( a_1 + x ( a_2 + x( a_3 + ... + x ( a_{n-1} + xa_n) ... )))\n\\]\nWhere \\(a_i\\) is the integer value for the character at position \\(i\\) in the string and \\(x\\) is a prime constant integer.\nIn Python:\nmultiplier = 37 # prime\nhash_value = 0\nhash_value = (hash_value * multiplier + ord(\"a\"))\nhash_value = (hash_value * multiplier + ord(\"b\"))\nhash_value = (hash_value * multiplier + ord(\"c\"))\nhash_value = hash_value % self._capacity",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data-structures/index.html#further-exploration",
    "href": "data-structures/index.html#further-exploration",
    "title": "19  Data Structures",
    "section": "Further Exploration",
    "text": "Further Exploration\n\nHash Table Visualization",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "testing/index.html",
    "href": "testing/index.html",
    "title": "20  Testing",
    "section": "",
    "text": "Writing Testable Code\nGoals\nAs you’ve discovered through working on assignments, tests are useful for ensuring that code works as expected.\nYou’ve been using pytest to run tests that have been provided for you, approximating something known as test-driven development.\nTest-driven development (TDD) is a software development process that involves writing tests before writing the code that will be tested. By recognizing the need for a function & reasoning about what the expected output is, you can write tests that will fail if the code is not working correctly.\nThis process helps you think through problems, and you will often find that reaching a solution is much easier if you write tests first.\nAs you venture into writing larger programs, whether you adopt a TDD approach or write your tests as you go, you’ll find it valuable to write your own tests.\nWe break our code into functions and classes to encapsulate functionality that we intend to reuse. These boundaries also provide a natural place to test our code.\nIf you only have one big function that does everything, it can be difficult to test:\nHow would you test this function? You’d need to have a database with a specific set of data in it and then run the function and check that the data was updated as expected.\nIf you break the function up into smaller functions, you can test each function in isolation:\nNow you can test each function in isolation.\nBy having the function take parameters, you can also test the function with different inputs.\nIt is also possible to test the function with a mock database connection that doesn’t actually connect to a database but provides the same interface.\nThis is called “mocking” and is a useful technique for testing code that interacts with external systems.",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "testing/index.html#writing-testable-code",
    "href": "testing/index.html#writing-testable-code",
    "title": "20  Testing",
    "section": "",
    "text": "def advance_all_students_with_passing_grades():\n    conn = sqlite3.connect('students.db')\n    c = conn.cursor()\n    c.execute('''\n    SELECT student.id, avg(class.grade) as average \n    FROM students JOIN classes ON students.id = classes.student_id\n    GROUP BY student.id HAVING average &gt;= 70\n    ''')\n    students = c.fetchall()\n    for student in students:\n        c.execute('UPDATE student_enrollment SET grade = grade + 1 WHERE student_id = ?', (student[0],))\n    conn.commit()\n    conn.close()\n\n\n\ndef get_students(conn, grade_threshold=70):\n    ...\n\ndef advance_student(conn, student):\n    ...",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "testing/index.html#writing-tests",
    "href": "testing/index.html#writing-tests",
    "title": "20  Testing",
    "section": "Writing Tests",
    "text": "Writing Tests\nThere are many types of tests, but we’ll primarily focus on tests that verify a single behavior.\nSo if a function should sum a list of positive integers, we might write three distinct tests:\n\ntest that a list of positive integers is correctly summed\ntest that negative numbers raise an error (or whatever the intended behavior is)\ntest that an empty list sums to zero\n\nEach of these could be considered a “unit” of the overall behavior. This kind of testing is known as unit testing.\n\npytest\npytest is a third-party library that makes writing tests in Python easier & less verbose than the built-in unittest module.\nWhen you run pytest it will look for files named test_*.py in the current directory and its sub-directories. It will then run any functions in those files that start with test_.\n\n\nassert statements\nIn Python, the assert statement is used to ensure that a condition is true.\nIf the condition is True, nothing happens. If the condition is False, an AssertionError is raised.\nYou can also provide a message to be printed if the assertion fails:\nassert 1 == 2, \"1 is not equal to 2\"\n\n\n\n\n\n\nImportantassert is not a function!\n\n\n\nA common mistake is to treat assert like a function, and use parentheses.\nThis leads to tests passing unexpectedly when they should fail:\nassert(1 == 2, \"1 is not equal to 2\")\n\n# is equivalent to:\nassert (1 == 2, \"1 is not equal to 2\")\n\n# which becomes:\nassert (False, \"1 is not equal to 2\")\nAnd a tuple with two elements is always True!\n\n\n\n\nTruthiness\nIn Python, every type has an implicit conversion to a boolean value. This is called “truthiness”.\nThe following values are considered “falsey”:\n\nFalse\nNone\n0 # int\n0.0 # float\n0j # complex\n\"\" # empty string\n[] # empty list\n() # empty tuple\n{} # empty dict\nset() # empty set\n\nAll other values are considered True.\nTruthiness Demo:\n\nvalues = [False, None, 0, 0.0, 0j, \"\", [], (), {}, set()]\nvalues += [True, 42, 3.14, \"hello\", [1, 2, 3], {\"a\": 1}]\nfor value in values:\n    # notice we're using the value as a boolean expression here\n    if value:\n        print(f\"{value} is True\")\n    else:\n        print(f\"{value} is False\")\n\nFalse is False\nNone is False\n0 is False\n0.0 is False\n0j is False\n is False\n[] is False\n() is False\n{} is False\nset() is False\nTrue is True\n42 is True\n3.14 is True\nhello is True\n[1, 2, 3] is True\n{'a': 1} is True",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "testing/index.html#writing-good-tests",
    "href": "testing/index.html#writing-good-tests",
    "title": "20  Testing",
    "section": "Writing good tests",
    "text": "Writing good tests\nNext, let’s take a look at some simple code and some appropriate unit tests:\n# my_module.py\nfrom collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef circle_contains(radius: float, center: Point, point: Point):\n    return (point.x - center.x) ** 2 + (point.y - center.y) ** 2 &lt;= radius ** 2\n\ndef points_within(radius: float, center: Point, points: list[Point]):\n    \"\"\" Find all points within a circle. \"\"\"\n    return [point for point in points if circle_contains(radius, center, point)]\n# test_my_module.py\n\nfrom my_module import circle_contains, points_within\n\norigin = Point(0, 0)\n\ndef test_circle_contains():\n    # centered at origin, radius 1\n    assert circle_contains(1, origin, origin)\n    assert circle_contains(1, origin, Point(.5, .5))\n\ndef test_circle_contains_edge():\n    assert circle_contains(1, origin, Point(1, 0))  # on the circle\n\ndef test_circle_contains_outside():\n    assert not circle_contains(1, origin, Point(1.1, 0))\n\nOne test per “behavior”\nYou may wonder, why did we write three tests instead of one?\ndef test_circle_contains():\n    # centered at origin, radius 1\n    assert circle_contains(1, origin, origin)\n    assert circle_contains(1, origin, Point(.5, .5))\n    assert circle_contains(1, origin, Point(1, 0))  # on the circle\n    assert not circle_contains(1, origin, Point(1.1, 0))\nIf the first assertion fails, the second assertion will not be run.\nThis makes it harder to debug the problem:\nIf a test named test_circle_contains_edge fails that only tests one thing, you have an idea of where to look.\nGranular tests make debugging easier. Consider assignments you’ve worked on, and whether or not you’d have appreciated a single test that tested a dozen different expected behaviors.\n\n\nTest Readability\nTests should be easy to understand. This means that the test should be written in a way that makes it clear what is being tested and what the expected result is.\nMake liberal use of comments and descriptive test names to make it clear what is being tested so that when a modification to the code in the future breaks a test, it is easy to understand why.\n\n\nTest Independence\nTests should be independent of each other. This means that if one test fails, it should not affect the outcome of any other test.\nThis can be a challenge when testing functions that modify data or global state.\nFor example:\ndef test_create_user():\n    db = Database(\"test.db\")\n    db.create_user(username=\"alice\")\n    assert db.get_user(username=\"alice\").id == 1\n\ndef test_delete_user():\n    db = Database(\"test.db\")\n    db.delete_user(username=\"alice\")\n    assert db.get_user(username=\"alice\") is None\nThese tests are not independent. If the first test fails, the second test will fail because the database will be empty.\nYou’d instead likely need to do something like this:\ndef create_test_database():\n    remove_file_if_exists(\"test.db\")\n    db = Database(\"test.db\")\n    db.init_schema()\n    return db\n\ndef test_create_user():\n    db = create_test_database()\n    db.create_user(username=\"alice\")\n    assert db.get_user(username=\"alice\").id == 1\n\ndef test_delete_user():\n    db = create_test_database()\n    db.create_user(username=\"alice\")\n    db.delete_user(username=\"alice\")\n    assert db.get_user(username=\"alice\") is None\nYou may note that test_delete_user will fail if create_user doesn’t work. There’s still a dependency in terms of behavior in this case, but you can see that the tests can now be run independently of one another since each starts with a blank database.\n\n\nTest Repeatability\nTests should be repeatable. This means that if a test fails, it should be possible to run it again and get the same result.\nThis means that tests should not depend on external factors such as:\n\nThe current time or date\nRandom numbers\nThe state of the network\nThe state of the database\n\nTo reduce the chance of a test failing due to an external factor, you can use a library like freezegun to freeze the current time that a test sees. The mock module can be used to mock out external functions so they return consistent data for the purpose of the test.",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "testing/index.html#what-tests-to-write",
    "href": "testing/index.html#what-tests-to-write",
    "title": "20  Testing",
    "section": "What tests to write?",
    "text": "What tests to write?\nWhen considering what to test, usually there are a 1-2 clear behaviors that need to be verified.\nFor a string comparison function, you would need to test that strmatch(\"abc\", \"abc\") and strmatch(\"abc\", \"xyz\") return the expected values.\nIt is then worth considering edge cases: what about empty strings? Does the function need to handle non-string input?\nA helpful checklist to run through is: Zero, One, Many, Errors\nIf a function takes a collection of some kind, ensure that it performs as expected with an empty collection, a collection with one element, a collection with many elements, and an expected error condition, such as a dictionary passed instead of a list.\nYou do not need to test multiple iterations of the same behavior. If sum works with 4 elements, it probably works with 3 and 5 as well.\n# example tests for the sum() function\ndef test_sum_empty():\n    assert sum([]) == 0\n\ndef test_sum_one():\n    assert sum([1]) == 1\n\ndef test_sum_many():\n    assert sum([1, 2, 3]) == 6\n\ndef test_sum_type_error():\n    with pytest.raises(TypeError):\n        sum([1, \"hello\"])",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "testing/index.html#pytest-features",
    "href": "testing/index.html#pytest-features",
    "title": "20  Testing",
    "section": "pytest Features",
    "text": "pytest Features\nWe use pytest because it is easy to use and provides a lot of useful features, especially when contrasted with Python’s built-in unittest.\npytest provides both a command line tool pytest, which you’ve been using, and a library that you can use to help you write tests.\n\nCLI Flags\npytest has some helpful command line options, among them:\n\nPassing a filename like tests/test_markov.py will run only the tests in that file.\n-v will print out more information about each test and give more detailed error output.\n-vv will print out even more information about each test, particularly useful when comparing expected output vs. actual.\n-s will include any output from print statements (normally suppressed by pytest).\n-k &lt;pattern&gt; will only run tests whose names match the pattern. (So pytest -k frontend would match test_frontend_template and test_frontend_call but not test_database_setup)\n-x will stop running tests after the first failure.\n\n\n\nFixtures\nA fixture is a function that is run before each test. It can be used to set up the test environment or provide consistent test data.\nimport pytest\n\n@pytest.fixture\ndef user_list()\n    return [\n        {\"name\": \"alice\", \"id\": 1, \"email\": \"alice@domain\"},\n        {\"name\": \"carol\", \"id\": 3, \"email\": \"carol@domain\"},\n        {\"name\": \"bob\", \"id\": 2, \"email\": \"bob@domain\"},\n        {\"name\": \"diego\", \"id\": 4, \"email\": \"diego@otherdomain\"},\n    ]\n\ndef test_sort_users(user_list):\n    sorted_list = sort_users(user_list)\n    assert sorted_list == [\n        {\"name\": \"alice\", \"id\": 1, \"email\": \"alice@domain\"},\n        {\"name\": \"bob\", \"id\": 2, \"email\": \"bob@domain\"},\n        {\"name\": \"carol\", \"id\": 3, \"email\": \"carol@domain\"},\n        {\"name\": \"diego\", \"id\": 4, \"email\": \"diego@otherdomain\"},\n    ]\n\ndef test_filter_users(user_list):\n    filtered_list = filter_users(user_list, domain=\"domain\")\n    assert filtered_list == [\n        {\"name\": \"alice\", \"id\": 1, \"email\": \"alice@domain\"},\n        {\"name\": \"bob\", \"id\": 2, \"email\": \"bob@domain\"},\n        {\"name\": \"carol\", \"id\": 3, \"email\": \"carol@domain\"},\n    ]\nThis is a powerful feature that can be used to set up complex test environments and ensure test independence as described above.\nimport pytest\n\n@pytest.fixture\ndef db():\n    remove_file_if_exists(\"test.db\")\n    db = Database(\"test.db\")\n    db.init_schema()\n    return db\n\n# parameter names must match fixture names\ndef test_create_user(db):\n    db.create_user(username=\"alice\")\n    assert db.get_user(username=\"alice\").id == 1\n\ndef test_delete_user(db):\n    db.create_user(username=\"alice\")\n    db.delete_user(username=\"alice\")\n    assert db.get_user(username=\"alice\") is None\n\n\nTesting Exceptions\nEnsuring that your functions handle errors as intended is an important behavior to include in your tests.\npytest.raises can be used to ensure that a function raises an exception.\ndef test_reject_invalid_domain():\n    with pytest.raises(ValueError):\n        validate_email(\"alice@invalid$\")\nIf the exception is not raised within the with block, pytest will mark the test as failed.\n\n\nParameterized Tests\nSometimes the same test needs to be run with different inputs. pytest provides a way to do this with parameterized tests.\n@pytest.mark.parametrize(\"str1,str2,expected\", [\n    (\"abc\", \"abd\", 1),\n    (\"abc\", \"abc\", 0),\n    (\"abc\", \"xyz\", 3),\n])\ndef test_hamming_distance(str1, str2, expected):\n    assert hamming_distance(str1, str2) == expected\nThis runs as three distinct tests in pytest, converting each input to a distinct test by calling the test function with the parameters.",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "testing/index.html#beyond-unit-testing",
    "href": "testing/index.html#beyond-unit-testing",
    "title": "20  Testing",
    "section": "Beyond Unit Testing",
    "text": "Beyond Unit Testing\nWhile unit testing is the most common type of testing, it can be important to test that the various components work together as expected as well. This is known as integration testing.\nYou will also encounter functional testing and end-to-end testing which are similar concepts, ensuring that the system works as intended, not just the individual parts.\nThese tests are typically much more complex and take a longer amount of time to run. In practice, you may run the unit tests every time you make a commit, but only run larger tests before a release.\nPerformance testing focuses on the speed at which a piece of code runs, often set up to watch for regressions where a change makes the code notably slower.",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "testing/index.html#further-exploration",
    "href": "testing/index.html#further-exploration",
    "title": "20  Testing",
    "section": "Further Exploration",
    "text": "Further Exploration\n\npytest\nfreezegun\nmock",
    "crumbs": [
      "Odds & Ends",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Testing</span>"
    ]
  },
  {
    "objectID": "files/index.html",
    "href": "files/index.html",
    "title": "Files & Paths",
    "section": "",
    "text": "File I/O\nAs you’ve likely already realized, variables only exist while a program is running.\nIf we want to persist data between runs of the program, we need to read & write files.\nThis is a good time to look at an important concept in programming, looking at the same thing through levels of abstraction.\nYour hard drive is a piece of physical media: it stores electrical charges representing the 0s and 1s that make up our data. Over the years, this format has changed: magnetic tape, hard drive platters, optical drives, flash storage. Each of these stores the 0s and 1s differently, but when we are writing programs we rarely want to worry about the distinct medium.\nOne of the jobs of the operating system is to provide a layer of abstraction for accessing hardware, including the hard drive. This takes the form of a filesystem, a way of mapping a hierarchy of names to physical locations on the hard drive.\nWhen we refer to /home/user/code/proj/example.py – our operating system maps this to a location on the hard drive. In order to write to, or read from that location, it provides an interface that has remained relatively unchanged since 1970.\nWhile the OS-level file API is typically a C API, most languages provide a low-level API that is very similar to the C API.\nIn Python, that is present in the form of the open function and related types.\nFirst, we create a “file handle”, a special type that allows us to interact with an opened file. The built-in open() method returns this kind of handle.\nfh = open(\"file.txt\")\nOnce opened, you will use methods to read/modify the file:\n# read entire file as a string\ntext = fh.read()\nprint(text)\n\nText file contents",
    "crumbs": [
      "Appendices",
      "Files & Paths"
    ]
  },
  {
    "objectID": "files/index.html#file-io",
    "href": "files/index.html#file-io",
    "title": "Files & Paths",
    "section": "",
    "text": "File Modes\nThere is a second parameter to open(), which control what our intention is with the file.\n\n\n\nmode\nbehavior\n\n\n\n\n\"r\"\nread-only, default behavior\n\n\n\"w\"\nwrite mode, will erase entire file upon opening\n\n\n\"a\"\nappend mode, will place “cursor” at end of file\n\n\n\"rb\"\nread-only binary mode\n\n\n\"wb\"\nwrite binary mode\n\n\n\nSee more: https://docs.python.org/3/library/functions.html#open\nNote that write mode erases the file upon opening, this may seem unintuitive but it is quite common to want to replace the entire contents of a file with an edited copy in memory. Take care if using this mode that that is what you want.\n\n\nfile methods\nAs we’ve seen, file objects have methods. The methods available depend on what mode was specified upon opening. Attempting to use a method that is invalid (e.g. write on a read-only file) will result in an error.\n\n\n\n\n\n\n\nmethod\npurpose\n\n\n\n\nread\nread entire file as a single str (or bytes depending on mode)\n\n\nreadline\nread a single line of text\n\n\nwrite\nwrite string (or bytes) to file, can be called multiple times\n\n\nseek\nmove the “cursor” to a different position\n\n\ntell\nreturn the current cursor position\n\n\nclose\nclose a file, syncing the contents back to disk*\n\n\n\nSee more: https://docs.python.org/3/tutorial/inputoutput.html#tut-files\nForgetting to call close on a file could potentially lead to lost data. Until it is called, data is not guaranteed to be saved to disk, instead existing in a temporary buffer Python maintains for you.\nBecause of this, the recommended way to use open() has become:\n# read from a text file that already exists\nwith open(\"filename.txt\") as f:\n    text = f.read()\n\n# open a new file for writing (erases existing contents)\nwith open(\"newfile.txt\", \"w\") as f:\n    f.write(\"hello filesystem!\\n\")\nThe with statement is something we will come back to later, it creats a temporary variable (f in the examples above) that is only usable within the indented block. When the block is exited close() is automatically called.\nThis is particularly useful when you are concerned about an exception being raised within the block, exiting the block in any way, error or not, will still call close().\n\n\nIn Practice: json, csv, etc.\nWhile it is possible to have multiple read/write statements within the block, writing data out one line at a time it is more common to use libraries that handle common file formats.\nThese built-in libraries take a file handle, then take care of properly formatting the output for you:\n# writing a CSV file\nwith open('some.csv', 'w') as f:\n    writer = csv.writer(f)\n    # data is an iterable of tuples\n    writer.writerows(data)\n# reading a CSV file\nwith open('some.csv', 'r') as f:\n    reader = csv.reader(f)\n    # reader is an iterable that yields tuples\n    for row in reader:\n        print(row)\n# writing to JSON\nwith open(\"newfile.json\", \"w\") as f:\n    # data is list or dict\n    json.dump(data, f)\n# writing to JSON\nwith open(\"newfile.json\", \"w\") as f:\n    # reads dict or list from JSON file\n    data = json.load(f)",
    "crumbs": [
      "Appendices",
      "Files & Paths"
    ]
  },
  {
    "objectID": "files/index.html#manipulating-paths",
    "href": "files/index.html#manipulating-paths",
    "title": "Files & Paths",
    "section": "Manipulating Paths",
    "text": "Manipulating Paths\nIn practice, with most of the actual complexities of output abstracted away, many will find the hardest part of working with files understanding paths.\npathlib is a relatively new addition to Python, which accounts for the fact that you’ll still see examples using less effective methods, particularly those from the os and os.path modules.\npathlib makes working with file paths much easier, and should be preferred to the os methods.\nThe primary thing the module contains is a type called Path 1\nThe Path class represents a single file path, the path to the file I’m writing these words in for instance might be\nPath(\"/home/james/sites/map-python-data/pathlib/index.qmd\")`\nWhile paths may resemble strings, and can be instantiated from them, the Path class offers additional behaviors that are specific to file paths.\n\n.parent\nPath objects have a .parent property that is equivalent to going up a directory:\n\nfrom pathlib import Path\n\npath = Path(\"/home/user/projects/proj-1\")\nprint(path.parent)\nprint(path.parent.parent)\n\n/home/user/projects\n/home/user\n\n\n\n\nConcatenation\nPath objects use / to concatenate parts of a path. (Instead of the + used by strings.)\nWe can use this to build paths out of components:\n\nBASE_DIR = Path(\"/home/james/sites/map-python-data\")\n\nfor name in [\"pathlib\", \"web-scraping\", \"debugging\"]:\n    # Path overrides the \"/\" operator to work as concatenation\n    # this works with strings and Paths\n    file_path = BASE_DIR / name / \"index.qmd\"\n    print(file_path)\n\n/home/james/sites/map-python-data/pathlib/index.qmd\n/home/james/sites/map-python-data/web-scraping/index.qmd\n/home/james/sites/map-python-data/debugging/index.qmd\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis works on Windows as well as Unix-based systems. The path separators will be converted by the library so you can use / and Windows will see \\ where appropriate.",
    "crumbs": [
      "Appendices",
      "Files & Paths"
    ]
  },
  {
    "objectID": "files/index.html#getting-the-right-path",
    "href": "files/index.html#getting-the-right-path",
    "title": "Files & Paths",
    "section": "Getting the Right Path",
    "text": "Getting the Right Path\nIf you’ve written a file that works with paths you may have run into issues where it doesn’t always read the correct file.\nPerhaps you had code like:\nwith open(\"filename.txt\") as f:\n    f.read()\nAnd found that sometimes it couldn’t find the file in question. Or if writing files, perhaps sometimes it wrote the file to a different directory than the one you expected.\nThe reason for this is that if a file path does not start with the root / (or C:/ on Windows) it is relative.\nThese paths will be interpreted as if they begin with the current working directory.\nThis is an opaque concept, and a perfect example of why we tell you to avoid global variables.\nEvery running program has a global variable representing the “current working directory”, often the directory it was run from. When you are in your terminal you can see your terminal’s current working directory by typing pwd. Similarly Python has functions to let you examine (os.getcwd) and change (os.chdir) the current working directory.\nAs you may recall, global variables can make it hard to reason about programs, since any function might modify them in unexpected ways.\n# global variables create hard-to-follow code\nsome_variable = 100\nf()\ng()\nh()\nprint(some_variable)\nWhat will print? That depends on what f, g, and h do to the global state!\nAs we’ll see, the key to robust file-handling that works equally well on your system as it does on your peers’ is to generally avoid using this global state altogether.\n\nAbsolute Paths\nOne solution to this problem is to use absolute paths, you may find that instead of open(\"data/target.json\") you can get your code to work when you use open(\"/home/user/projects/proj-2/data/target.json\").\nBut this path is unique to your computer. On my machine I may need \"/home/james/dev/proj2/data/target.json\".\nHow can we do this without constantly dueling edits in our Git repository?\n\n\n__file__\nIf we’re concerned about portability we want to have a way to say “the directory next to this one” or “the directory that is a parent of this one”.\nOften we’re trying to create a layout like this:\nproj-dir/\n├── data\n│   └── target.json\n└── src\n    └── script.py\nscript.py would like to be able to write to data/target.json in a reliable way regardless of what the current working directory is.\nWe’d like to do this without knowing exactly where proj-dir is as well, since it may be in /Users/james/projects on one machine and /home/stephen/my-homework on another.\nTo do this, we can define our paths using the relationship between the two files.\nThe algorithm for doing this is:\n\nHave the Python file get the path to itself.\nDetermine the relative path from the Python file in question to the data file.\nUse pathlib to combine these.\n\nPython has a special variable __file__ that’ll help with step 1, and the rest of the steps we can do with standard path operators:\n# assume we're in /home/james/projects/proj-dir/src/script.py\nfrom pathlib import Path\n\n# this creates a Path object that is the full path to script.py\n# and then uses .parent to go up one level, to\n# \"/home/james/projects/proj-dir/src/\"\nBASE_DIR = Path(__file__).parent\n\n# Combine that path with a relative path from 'src'\n# to the file in question.\n#  - up one directory, then into the data directory\ndata_path = BASE_DIR / \"../data/target.json\"\nForming paths using __file__ makes them consistent as long as the .py files do not move relative to the data.",
    "crumbs": [
      "Appendices",
      "Files & Paths"
    ]
  },
  {
    "objectID": "files/index.html#using-path-objects",
    "href": "files/index.html#using-path-objects",
    "title": "Files & Paths",
    "section": "Using Path objects",
    "text": "Using Path objects\nPath objects can typically be passed in anywhere a filename is expected, so open(\"filename.txt\", \"w\") can become open(path_obj, \"w\"). You can also write this as path.open(\"w\"). (See pathlib.Path.open.)\nPath objects also have quite a few helper methods that can make your life easier:\n\nPath.exists\nIf you want to check if a given file exists, you can construct a path to it and then call .exists:\npath = BASE_DIR / \"data.csv\"\nif path.exists():\n    read_and_process(path)\nelse:\n    create_initial_data(path)\n\n\nPath.mkdir\nA common pattern is to want to create a directory if it doesn’t exist:\nlog_directory = BASE_DIR / \"logs\"\nlog_directory.mkdir(exist_ok=True, parents=True)\nThis also demonstrates two useful parameters:\n\nexist_ok=True makes it so that the function will not raise an error if the directory already exists.\nparents=True will also create parent directories if needed.\n\n\n\nQuick Reading/Writing\nIf you are reading/writing the entire file in one go, instead of using the IO object returned by open, you can call read_text and write_text directly on the Path as a shortcut.\n\np = Path(\"file.txt\")\np.write_text('Text file contents')\np.read_text()\n\n'Text file contents'",
    "crumbs": [
      "Appendices",
      "Files & Paths"
    ]
  },
  {
    "objectID": "files/index.html#further-exploration",
    "href": "files/index.html#further-exploration",
    "title": "Files & Paths",
    "section": "Further Exploration",
    "text": "Further Exploration\nSee the official pathlib documentation for more methods and examples.",
    "crumbs": [
      "Appendices",
      "Files & Paths"
    ]
  },
  {
    "objectID": "files/index.html#footnotes",
    "href": "files/index.html#footnotes",
    "title": "Files & Paths",
    "section": "",
    "text": "If you look at the documentation, you’ll see a few related classes like PurePath and PosixPath. You can ignore those differences for the most part and use Path.↩︎",
    "crumbs": [
      "Appendices",
      "Files & Paths"
    ]
  }
]